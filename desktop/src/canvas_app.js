import { invoke } from "@tauri-apps/api/tauri";
import { listen } from "@tauri-apps/api/event";
import { open } from "@tauri-apps/api/dialog";
import { homeDir, join } from "@tauri-apps/api/path";
import {
  readDir,
  exists,
  readTextFile,
  readBinaryFile,
  removeFile,
  writeTextFile,
  writeBinaryFile,
  createDir,
  copyFile,
} from "@tauri-apps/api/fs";

import { computeActionGridSlots } from "./action_grid_logic.js";
import { createEffectsRuntime } from "./effects_runtime.js";
import { effectTypeFromTokenType } from "./effect_specs.js";
import {
  mergeAmbientSuggestions,
  placeAmbientSuggestions,
  shouldScheduleAmbientIntent,
} from "./intent_ambient.js";
import {
  EFFECT_TOKEN_LIFECYCLE,
  beginEffectTokenApply,
  beginEffectTokenDrag,
  cancelEffectTokenDrag,
  consumePendingEffectSourceSlot,
  consumeEffectToken,
  createEffectTokenState,
  createPendingEffectExtractionState,
  effectTokenCanDispatchApply,
  isValidEffectDrop,
  recoverEffectTokenApply,
  updateEffectTokenDrag,
} from "./effect_interactions.js";
import {
  MOTHER_IDLE_EVENTS,
  MOTHER_IDLE_STATES,
  motherIdleInitialState,
  motherIdleTransition,
  motherIdleUsesRealtimeVisual,
} from "./mother_idle_flow.js";
import { DESKTOP_EVENT_TYPES, PTY_COMMANDS, quoteForPtyArg as quoteForPtyArgUtil } from "./canvas_protocol.js";
import { appendTextWithFallback } from "./jsonl_io.js";
import {
  classifyIntentIconsRouting as classifyIntentIconsRoutingUtil,
  intentIconsPayloadChecksum as intentIconsPayloadChecksumUtil,
  intentIconsPayloadSafeSnippet as intentIconsPayloadSafeSnippetUtil,
  parseIntentIconsJson as parseIntentIconsJsonUtil,
  parseIntentIconsJsonDetailed as parseIntentIconsJsonDetailedUtil,
} from "./intent_icons_parser.js";
import {
  nextMotherRealtimeIntentFailureAction,
} from "./realtime_intent_recovery.js";
import { createDesktopEventHandlerMap } from "./event_handlers/index.js";
import { installCanvasGestureHandlers } from "./canvas_handlers/gesture_handlers.js";
import { installCanvasKeyboardHandlers } from "./canvas_handlers/keyboard_handlers.js";
import { installCanvasPointerHandlers } from "./canvas_handlers/pointer_handlers.js";
import { installCanvasWheelHandlers } from "./canvas_handlers/wheel_handlers.js";
import { POINTER_KINDS, isEffectTokenPath, isMotherRolePath } from "./canvas_handlers/pointer_paths.js";

/*
Compatibility sentinel for source-shape tests.
const toggle = Boolean(event.metaKey || event.ctrlKey || (event.shiftKey && state.tool !== "annotate"));
*/

const THUMB_PLACEHOLDER_SRC = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";

const MOTHER_VIDEO_IDLE_SRC = new URL("./assets/mother/mother_idle.mirrored.mp4", import.meta.url).href;
const MOTHER_VIDEO_WORKING_SRC = new URL("./assets/mother/mother_working.mp4", import.meta.url).href;
const MOTHER_VIDEO_TAKEOVER_SRC = new URL("./assets/mother/mother_takeover.mp4", import.meta.url).href;
const MOTHER_VIDEO_REALTIME_SRC = new URL("./assets/mother/mother_realtime.mp4", import.meta.url).href;
const OPENROUTER_ONBOARDING_SORA_VIDEO_SRC = new URL(
  "./assets/onboarding/videos/openrouter_onboarding.mp4",
  import.meta.url
).href;
const MOTHER_REALTIME_MIN_MS = 4000;
const MOTHER_USER_HOT_IDLE_MS = 10_000;
// Avoid brief watch-phase spikes from flashing realtime chrome/video.
const MOTHER_RT_VISUAL_ON_DELAY_MS = 820;
const MOTHER_RT_VISUAL_MIN_ON_MS = 2200;
const MOTHER_IDLE_TAKEOVER_IDLE_MS = 10_000;
// Mother drafts can exceed 14s on real providers; keep timeout generous to avoid false failures.
const MOTHER_GENERATION_TIMEOUT_MS = 90_000;
const MOTHER_GENERATION_TIMEOUT_EXTENSION_MS = 90_000;
const MOTHER_GENERATION_POST_VERSION_TIMEOUT_MS = 240_000;
const DEFAULT_IMAGE_MODEL = "gemini-3-pro-image-preview";
const LEGACY_DEFAULT_IMAGE_MODEL = "gemini-2.5-flash-image";
const IMAGE_MODEL_DEFAULT_MIGRATION_KEY = "brood.imageModel.default.v2";
const PROMPT_STRATEGY_MODE_KEY = "brood.promptStrategyMode.v1";
const PROMPT_REPEAT_FULL_KEY = "brood.promptRepeatFull.v1";
const PROMPT_BENCHMARK_LS_KEY = "brood.promptBenchmark.v1";
const PROMPT_BENCHMARK_MAX_TRIALS = 600;
const MOTHER_GENERATION_MODEL = DEFAULT_IMAGE_MODEL;
const MOTHER_GENERATED_SOURCE = "mother_generated";
const AESTHETIC_ONBOARDING_COMPLETED_KEY = "brood.aestheticOnboarding.completed.v1";
const AESTHETIC_ONBOARDING_PROFILE_KEY = "brood.aestheticOnboarding.profile.v1";
const OPENROUTER_ONBOARDING_COMPLETED_KEY = "brood.openrouterOnboarding.completed.v1";
const OPENROUTER_ONBOARDING_PROFILE_KEY = "brood.openrouterOnboarding.profile.v1";
const AESTHETIC_ONBOARDING_PROMPT =
  "Hyper-real modern loft interior with warm sunbeams, layered textures, and a hero seating area staged for a magazine shoot. Style focus: Interior designs.";
const AESTHETIC_ONBOARDING_MODEL_CHOICES = Object.freeze([
  {
    id: "gemini-3-pro-image-preview",
    modelValue: "gemini-3-pro-image-preview",
    label: "Gemini 3 Pro Preview",
    imageUrl: new URL("./assets/onboarding/aesthetic/gemini-3-pro-image-preview.png", import.meta.url).href,
    note: "Strong multi-image editing and workflow consistency.",
  },
  {
    id: "gpt-image-1.5",
    modelValue: "gpt-image-1.5",
    label: "gpt-image-1.5",
    imageUrl: new URL("./assets/onboarding/aesthetic/gpt-image-1.5.jpg", import.meta.url).href,
    note: "Balanced realism and art direction.",
  },
  {
    id: "flux-2-max",
    modelValue: "flux-2-max",
    label: "flux-2-max",
    imageUrl: new URL("./assets/onboarding/aesthetic/flux-2-max.jpeg", import.meta.url).href,
    note: "High-fidelity Flux default for detail-heavy composites.",
  },
  {
    id: "flux-2-flex",
    modelValue: "flux-2-flex",
    label: "flux-2-flex",
    imageUrl: new URL("./assets/onboarding/aesthetic/flux-2-flex.png", import.meta.url).href,
    note: "Fast, flexible mutation-friendly output.",
  },
]);
const AESTHETIC_FEATURE_OPTIONS = Object.freeze([
  {
    id: "reproducible_receipts",
    title: "Reproducible run receipts",
    description: "I want tight version tracking and repeatability.",
  },
  {
    id: "image_mutations",
    title: "Image mutations",
    description: "I mostly iterate quickly and explore many variants.",
  },
  {
    id: "multi_model_workflows",
    title: "Multi-model editing workflows",
    description: "I combine tools and need reliable cross-model edits.",
  },
  {
    id: "something_else",
    title: "Something else",
    description: "I am still exploring what my workflow will be.",
  },
]);
const AESTHETIC_DIRECTION_OPTIONS = Object.freeze([
  {
    id: "fidelity",
    title: "Prioritize fidelity",
    description: "I want the most polished output even if it is slower.",
  },
  {
    id: "balanced",
    title: "Keep it balanced",
    description: "I want a middle ground between speed and polish.",
  },
  {
    id: "speed",
    title: "Prioritize speed",
    description: "I want fast ideation and quick mutation loops.",
  },
]);
const MOTHER_SUGGESTION_LOG_FILENAME = "mother_suggestions.jsonl";
const MOTHER_TRACE_FILENAME = "mother_trace.jsonl";
const MOTHER_V2_WATCH_IDLE_MS = 100;
const MOTHER_V2_INTENT_IDLE_MS = 0;
const MOTHER_V2_MULTI_UPLOAD_WATCH_IDLE_MS = 100;
const MOTHER_V2_MULTI_UPLOAD_INTENT_IDLE_MS = 0;
const MOTHER_V2_MULTI_UPLOAD_IDLE_BOOST_WINDOW_MS = 20_000;
const MOTHER_V2_UPLOAD_SETTLE_MS = 120;
const MOTHER_V2_UPLOAD_PREFETCH_WINDOW_MS = 120_000;
const MOTHER_V2_SPECULATIVE_PREFETCH_DELAY_MS = 40;
const MOTHER_V2_ENABLE_SPECULATIVE_PREFETCH = false;
const MOTHER_V2_LIVE_PROPOSAL_REFRESH_DEBOUNCE_MS = 170;
const MOTHER_V2_LIVE_PROPOSAL_REFRESH_MIN_INTERVAL_MS = 550;
const MOTHER_V2_SINGLE_RESULT_GUARD_WINDOW_MS = 20_000;
const MOTHER_V2_PROMPT_COMPILE_FALLBACK_MS = 520;
const MOTHER_V2_INTENT_TARGET_IMAGE_LIMIT = 2;
const MOTHER_V2_INTENT_REFERENCE_IMAGE_LIMIT = 1;
const MOTHER_SELECTION_SEMANTIC_DRAG_PX = 10;
const MOTHER_V2_COOLDOWN_AFTER_COMMIT_MS = 2000;
const MOTHER_V2_COOLDOWN_AFTER_REJECT_MS = 1200;
const MOTHER_V2_VISION_RETRY_MS = 220;
const MOTHER_V2_INTENT_RT_TIMEOUT_MS = 30_000;
const MOTHER_V2_INTENT_RT_WORKER_TIMEOUT_MS = 42_000;
const MOTHER_V2_INTENT_RT_TIMEOUT_DEFER_GRACE_MS = 250;
const MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX = 2;
const MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_DELAY_MS = 220;
const MOTHER_V2_INTENT_RT_BUSY_TTL_MS = 44_000;
const MOTHER_V2_INTENT_LATE_REALTIME_UPGRADE_MS = 12000;
const MOTHER_V2_INTENT_CONTEXT_REF_RETRY_MAX = 0;
const MOTHER_V2_INTENT_CONTEXT_REF_RETRY_DELAY_MS = 220;
const MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL = 2;
const MOTHER_V2_UPLOAD_FAST_INTENT_SNAPSHOT_WAIT_MS = 50;
const MOTHER_V2_UPLOAD_FAST_INTENT_SNAPSHOT_MAX_DIM_PX = 560;
const MOTHER_V2_UPLOAD_VISION_DEFER_MS = 1800;
const MOTHER_V2_DISPATCH_TRANSFORM_EXPORT_LIMIT = 4;
const MOTHER_V2_DISPATCH_TRANSFORM_EXPORT_MAX_DIM_PX = 1500;
const MOTHER_V2_DISPATCH_TRANSFORM_EXPORT_MIN_DIM_PX = 420;
const MOTHER_V2_MAX_RANKED_PROPOSALS = 3;
const MOTHER_V2_ROLE_KEYS = Object.freeze(["subject", "model", "mediator", "object"]);
const MOTHER_V2_ROLE_LABEL = Object.freeze({
  subject: "SUBJECT",
  model: "MODEL",
  mediator: "MEDIATOR",
  object: "OBJECT",
});
const GOOGLE_BRAND_RECT_PALETTE_RGB = Object.freeze([
  [66, 133, 244], // blue
  [234, 67, 53], // red
  [251, 188, 5], // yellow
  [52, 168, 83], // green
]);
const MOTHER_V2_ROLE_GLYPH = Object.freeze({
  subject: "â—",
  model: "â—†",
  mediator: "â–³",
  object: "â– ",
});
const IS_MAC = /Mac|iPhone|iPad|iPod/.test(navigator?.platform || "");
// Use a more intuitive hold key for Mother option/hints reveal on macOS.
const MOTHER_OPTION_REVEAL_HOLD_KEY = IS_MAC ? "h" : "i";
const MOTHER_MOOD_PROFILE_KEY = "brood.motherMood.v1";
const MOTHER_MOOD_PLACEHOLDER_EMOJI = "â˜º";
const MOTHER_CREATIVE_DIRECTIVE_BASE = "stunningly awe-inspiring";
const MOTHER_CREATIVE_DIRECTIVE_MOOD_PREFIX = "";
const MOTHER_MOOD_OPTIONS = Object.freeze({
  joyous: Object.freeze({ emoji: "ðŸ˜„", label: "Joyous", directive: "joyous" }),
  nefarious: Object.freeze({ emoji: "ðŸ˜ˆ", label: "Nefarious", directive: "nefarious" }),
  somber: Object.freeze({ emoji: "ðŸ˜”", label: "Somber", directive: "somber" }),
  angry: Object.freeze({ emoji: "ðŸ˜¡", label: "Angry", directive: "angry" }),
});
function motherNormalizeMood(raw = "") {
  const key = String(raw || "")
    .trim()
    .toLowerCase();
  return Object.prototype.hasOwnProperty.call(MOTHER_MOOD_OPTIONS, key) ? key : "";
}

function motherMoodConfig(raw = null) {
  const key = motherNormalizeMood(raw);
  return key ? MOTHER_MOOD_OPTIONS[key] || null : null;
}

function loadMotherMoodPreference() {
  try {
    // Session-scoped behavior: always start with an unset vibe.
    localStorage.removeItem(MOTHER_MOOD_PROFILE_KEY);
  } catch {
    // ignore localStorage failures
  }
  return null;
}

function saveMotherMoodPreference(mood = null) {
  void mood;
  // Session-scoped behavior: do not persist vibe across app restarts.
}

function motherCurrentCreativeDirective() {
  const mood = motherMoodConfig(state?.motherMood)?.directive || "";
  if (!mood) return MOTHER_CREATIVE_DIRECTIVE_BASE;
  const prefix = String(MOTHER_CREATIVE_DIRECTIVE_MOOD_PREFIX || "").trim();
  if (!prefix) return `${MOTHER_CREATIVE_DIRECTIVE_BASE} and ${mood}`;
  return `${MOTHER_CREATIVE_DIRECTIVE_BASE} and ${prefix} ${mood}`;
}

function motherCurrentOptimizationTarget() {
  return motherCurrentCreativeDirective();
}

function motherCurrentCreativeDirectiveSentence() {
  return `Create outputs that are ${motherCurrentCreativeDirective()}.`;
}
const MOTHER_V2_TRANSFORMATION_MODES = Object.freeze([
  "amplify",
  "transcend",
  "destabilize",
  "purify",
  "hybridize",
  "mythologize",
  "monumentalize",
  "fracture",
  "romanticize",
  "alienate",
]);
const MOTHER_V2_DEFAULT_TRANSFORMATION_MODE = "hybridize";
const MOTHER_V2_PROPOSAL_BY_MODE = Object.freeze({
  amplify: "Fuse motion and comfort into something cinematic.",
  transcend: "Turn momentum into a sculptural interior moment.",
  destabilize: "Bend familiar structure into a charged visual tension.",
  purify: "Dissolve room geometry into fluid light and calm.",
  hybridize: "Fuse both references into one coherent visual world.",
  mythologize: "Recast the scene as mythic visual storytelling.",
  monumentalize: "Elevate the composition into a monumental hero frame.",
  fracture: "Split form and light into a deliberate expressive fracture.",
  romanticize: "Soften the scene into intimate emotional warmth.",
  alienate: "Shift the familiar into a precise uncanny atmosphere.",
});
const MOTHER_V2_SHOT_HINTS_BY_MODE = Object.freeze({
  amplify: Object.freeze({
    primary: "close-up detail shot",
    alternate: "dynamic medium tracking shot",
    rationale: "amplify tactile detail and motion energy",
    lighting_profile: "high-contrast practical key with crisp specular highlights",
    alternate_lighting_profile: "kinetic mixed-source edge lighting",
    lens_guidance: "50-85mm detail-forward close perspective",
    alternate_lens_guidance: "35mm dynamic medium tracking perspective",
  }),
  transcend: Object.freeze({
    primary: "elevated wide atmospheric shot",
    alternate: "overhead drift shot",
    rationale: "lift the scene into a sculptural, airy frame",
    lighting_profile: "volumetric skylight diffusion with soft glow rolloff",
    alternate_lighting_profile: "cool dawn haze with gentle top-light wrap",
    lens_guidance: "24-35mm elevated wide perspective",
    alternate_lens_guidance: "35mm overhead float perspective",
  }),
  destabilize: Object.freeze({
    primary: "dutch-angle medium shot",
    alternate: "off-axis close-up shot",
    rationale: "heighten controlled visual tension",
    lighting_profile: "hard cross-lighting with unstable shadow breaks",
    alternate_lighting_profile: "staccato practical contrast with uneven falloff",
    lens_guidance: "28-40mm skewed medium perspective",
    alternate_lens_guidance: "50mm off-axis close perspective",
  }),
  purify: Object.freeze({
    primary: "centered minimal medium shot",
    alternate: "soft overhead shot",
    rationale: "reduce clutter and preserve calm geometry",
    lighting_profile: "high-key soft diffusion with restrained contrast",
    alternate_lighting_profile: "clean top-light wash with minimal shadow noise",
    lens_guidance: "40-50mm neutral medium perspective",
    alternate_lens_guidance: "35mm soft overhead perspective",
  }),
  hybridize: Object.freeze({
    primary: "balanced medium fusion shot",
    alternate: "wide integrated scene shot",
    rationale: "merge references into one coherent world",
    lighting_profile: "balanced cinematic key/fill with coherent directionality",
    alternate_lighting_profile: "soft directional fill with shared ambient bounce",
    lens_guidance: "35-50mm balanced fusion perspective",
    alternate_lens_guidance: "24-35mm integrated wide perspective",
  }),
  mythologize: Object.freeze({
    primary: "low-angle hero shot",
    alternate: "epic wide establishing shot",
    rationale: "create mythic scale and reverence",
    lighting_profile: "high-contrast directional key with rim backlight and atmospheric haze",
    alternate_lighting_profile: "golden-hour edge light with deep sculpted shadows",
    lens_guidance: "24-35mm low-angle heroic perspective",
    alternate_lens_guidance: "24mm epic establishing perspective",
  }),
  monumentalize: Object.freeze({
    primary: "low-angle wide hero shot",
    alternate: "symmetrical frontal hero shot",
    rationale: "emphasize monumentality and presence",
    lighting_profile: "architectural hard key with stately shadow geometry",
    alternate_lighting_profile: "broad frontal key with monumental silhouette separation",
    lens_guidance: "24-32mm low-angle monumental perspective",
    alternate_lens_guidance: "35-50mm symmetrical frontal perspective",
  }),
  fracture: Object.freeze({
    primary: "oblique fragmented close-up shot",
    alternate: "split-perspective medium shot",
    rationale: "intentionally break form while preserving intent",
    lighting_profile: "broken directional light with deliberate contrast discontinuities",
    alternate_lighting_profile: "multi-source edge lighting with fractured shadow planes",
    lens_guidance: "50-85mm oblique detail perspective",
    alternate_lens_guidance: "35-50mm split-perspective framing",
  }),
  romanticize: Object.freeze({
    primary: "intimate medium close-up shot",
    alternate: "soft backlit wide shot",
    rationale: "push emotional warmth and tenderness",
    lighting_profile: "warm soft key with gentle halation and lifted shadows",
    alternate_lighting_profile: "backlit golden diffusion with subtle bloom",
    lens_guidance: "50-85mm intimate portrait perspective",
    alternate_lens_guidance: "35mm soft backlit wide perspective",
  }),
  alienate: Object.freeze({
    primary: "detached wide observational shot",
    alternate: "telephoto compressed shot",
    rationale: "introduce precise emotional distance",
    lighting_profile: "cool controlled contrast with sparse practical pools",
    alternate_lighting_profile: "flat ambient light with isolated hard accents",
    lens_guidance: "24-35mm detached observational perspective",
    alternate_lens_guidance: "85-135mm compressed observational perspective",
  }),
});
const MOTHER_V2_OPERATION_TYPE_BY_MODE = Object.freeze({
  amplify: "dna_apply",
  hybridize: "hybridize",
});
const MOTHER_V2_PROPOSAL_ICON_ACCENT_BY_MODE = Object.freeze({
  amplify: "rgba(99, 224, 255, 0.96)",
  transcend: "rgba(132, 189, 255, 0.96)",
  destabilize: "rgba(255, 145, 114, 0.96)",
  purify: "rgba(126, 255, 209, 0.96)",
  hybridize: "rgba(255, 224, 120, 0.96)",
  mythologize: "rgba(189, 162, 255, 0.96)",
  monumentalize: "rgba(255, 196, 136, 0.96)",
  fracture: "rgba(255, 127, 164, 0.96)",
  romanticize: "rgba(255, 160, 203, 0.96)",
  alienate: "rgba(152, 255, 174, 0.96)",
});
const MOTHER_V2_ROLE_PREVIEW_PANEL_FILL_RATIO = 0.95;
const MOTHER_V2_ROLE_PREVIEW_PANEL_ZOOM_MAX = 4.2;
const MOTHER_V2_ROLE_PREVIEW_PANEL_PAD_PX = 0;
const MOTHER_OFFER_PREVIEW_SCALE = 1.62;
const MOTHER_OFFER_PREVIEW_MIN_VIEWPORT_COVER = 0.46;
const MOTHER_OFFER_PREVIEW_MAX_VIEWPORT_COVER = 0.92;
// World-projection overscan: keep viewport boxes from filling panel projections immediately when zooming out.
const WORLD_PROJECTION_OVERSCAN_RATIO = 0.75;
const ENABLE_FILE_BROWSER_DOCK = true;
const FILE_BROWSER_ROOT_DIR_LS_KEY = "brood.fileBrowser.rootDir";
const FILE_BROWSER_DRAG_MIME = "application/x-brood-local-image-path";
const FILE_BROWSER_IMAGE_EXTS = new Set([".png", ".jpg", ".jpeg", ".webp", ".heic"]);
const TOP_METRICS_WINDOW_MINUTES = 30;
const TOP_METRICS_RENDER_SAMPLE_MAX = 20;
const TOP_METRICS_THRESHOLDS = Object.freeze({
  tokens_per_minute: { cool_max: 2000, warm_max: 8000 },
  session_cost_usd: { cool_max: 1, warm_max: 5 },
  queued_calls: { cool_max: 1, warm_max: 3 },
  avg_render_s: { cool_max: 8, warm_max: 18 },
});
const SPARKLINE_GLYPHS = Object.freeze(["â–", "â–‚", "â–ƒ", "â–„", "â–…", "â–†", "â–‡", "â–ˆ"]);
// Per-1K-token estimates for realtime text calls (input/output priced separately).
const REALTIME_TOKEN_PRICING_USD_PER_1K = Object.freeze({
  "gpt-realtime-mini": Object.freeze({ input: 0.0006, output: 0.0024 }),
  "gpt-4o-mini": Object.freeze({ input: 0.00015, output: 0.0006 }),
  "gemini-3-flash-preview": Object.freeze({ input: 0.0005, output: 0.003 }),
});
const REEL_PRESET = Object.freeze({
  width: 540,
  height: 960,
});

const els = {
  runInfo: document.getElementById("run-info"),
  engineStatus: document.getElementById("engine-status"),
  topMetricsRoot: document.getElementById("top-metrics"),
  topMetricTokens: document.getElementById("top-metric-tokens"),
  topMetricTokensValue: document.getElementById("top-metric-tokens-value"),
  topMetricTokensSparkIn: document.getElementById("top-metric-tokens-spark-in"),
  topMetricTokensSparkOut: document.getElementById("top-metric-tokens-spark-out"),
  topMetricApiCalls: document.getElementById("top-metric-api-calls"),
  topMetricApiCallsValue: document.getElementById("top-metric-api-calls-value"),
  topMetricCost: document.getElementById("top-metric-cost"),
  topMetricCostValue: document.getElementById("top-metric-cost-value"),
  topMetricQueue: document.getElementById("top-metric-queue"),
  topMetricQueueValue: document.getElementById("top-metric-queue-value"),
  topMetricQueueTrend: document.getElementById("top-metric-queue-trend"),
  topMetricRender: document.getElementById("top-metric-render"),
  topMetricRenderValue: document.getElementById("top-metric-render-value"),
  brandStrip: document.querySelector(".brand-strip"),
  appMenuToggle: document.getElementById("app-menu-toggle"),
  appMenu: document.getElementById("app-menu"),
  newRun: document.getElementById("new-run"),
  openRun: document.getElementById("open-run"),
  import: document.getElementById("import"),
  canvasImport: document.getElementById("canvas-import"),
  export: document.getElementById("export"),
  reelAdminToggle: document.getElementById("reel-admin-toggle"),
  settingsToggle: document.getElementById("settings-toggle"),
  settingsDrawer: document.getElementById("settings-drawer"),
  settingsClose: document.getElementById("settings-close"),
  memoryToggle: document.getElementById("memory-toggle"),
  alwaysOnVisionToggle: document.getElementById("always-on-vision-toggle"),
  alwaysOnVisionReadout: document.getElementById("always-on-vision-readout"),
  autoAcceptSuggestedAbilityToggle: document.getElementById("auto-accept-suggested-ability-toggle"),
  canvasContextSuggest: document.getElementById("canvas-context-suggest"),
  canvasContextSuggestBtn: document.getElementById("canvas-context-suggest-btn"),
  textModel: document.getElementById("text-model"),
  imageModel: document.getElementById("image-model"),
  promptStrategyMode: document.getElementById("prompt-strategy-mode"),
  promptRepeatFullToggle: document.getElementById("prompt-repeat-full-toggle"),
  promptBenchmarkReadout: document.getElementById("prompt-benchmark-readout"),
  promptBenchmarkReset: document.getElementById("prompt-benchmark-reset"),
  aestheticOnboardingStatus: document.getElementById("aesthetic-onboarding-status"),
  aestheticOnboardingOpen: document.getElementById("aesthetic-onboarding-open"),
  aestheticOnboardingClear: document.getElementById("aesthetic-onboarding-clear"),
  openrouterOnboardingStatus: document.getElementById("openrouter-onboarding-status"),
  openrouterOnboardingOpen: document.getElementById("openrouter-onboarding-open"),
  openrouterOnboardingReset: document.getElementById("openrouter-onboarding-reset"),
  portraitsDir: document.getElementById("portraits-dir"),
  portraitsDirPick: document.getElementById("portraits-dir-pick"),
  portraitsDirClear: document.getElementById("portraits-dir-clear"),
  keyStatus: document.getElementById("key-status"),
  motherIntentSourceIndicator: document.getElementById("mother-intent-source-indicator"),
  canvasWrap: document.getElementById("canvas-wrap"),
  dropHint: document.getElementById("drop-hint"),
  workCanvas: document.getElementById("work-canvas"),
  effectsCanvas: document.getElementById("effects-canvas"),
  imageFx: document.getElementById("image-fx"),
  imageFx2: document.getElementById("image-fx-2"),
  overlayCanvas: document.getElementById("overlay-canvas"),
  controlStrip: document.getElementById("control-strip"),
  fileBrowserDock: document.getElementById("file-browser-dock"),
  fileBrowserHeader: document.getElementById("file-browser-header"),
  fileBrowserChoose: document.getElementById("file-browser-choose"),
  fileBrowserUp: document.getElementById("file-browser-up"),
  fileBrowserRefresh: document.getElementById("file-browser-refresh"),
  fileBrowserPath: document.getElementById("file-browser-path"),
  fileBrowserList: document.getElementById("file-browser-list"),
  annotatePanel: document.getElementById("annotate-panel"),
  annotateClose: document.getElementById("annotate-close"),
  annotateMeta: document.getElementById("annotate-meta"),
  annotateModel: document.getElementById("annotate-model"),
  annotateText: document.getElementById("annotate-text"),
  annotateCancel: document.getElementById("annotate-cancel"),
  annotateSend: document.getElementById("annotate-send"),
  promptGeneratePanel: document.getElementById("prompt-generate-panel"),
  promptGenerateClose: document.getElementById("prompt-generate-close"),
  promptGenerateMeta: document.getElementById("prompt-generate-meta"),
  promptGenerateModel: document.getElementById("prompt-generate-model"),
  promptGenerateText: document.getElementById("prompt-generate-text"),
  promptGenerateCancel: document.getElementById("prompt-generate-cancel"),
  promptGenerateSend: document.getElementById("prompt-generate-send"),
  markPanel: document.getElementById("mark-panel"),
  markTitle: document.getElementById("mark-title"),
  markClose: document.getElementById("mark-close"),
  markMeta: document.getElementById("mark-meta"),
  markText: document.getElementById("mark-text"),
  markDelete: document.getElementById("mark-delete"),
  markSave: document.getElementById("mark-save"),
  hud: document.getElementById("hud"),
  hudLineUnit: document.getElementById("hud-line-unit"),
  hudLineDirector: document.getElementById("hud-line-director"),
  hudDirectorKey: document.getElementById("hud-director-k"),
  hudDirectorVal: document.getElementById("hud-director-v"),
  hudLineDesc: document.getElementById("hud-line-desc"),
  hudLineSel: document.getElementById("hud-line-sel"),
  hudUnitName: document.getElementById("hud-unit-name"),
  hudUnitDesc: document.getElementById("hud-unit-desc"),
  hudUnitSel: document.getElementById("hud-unit-sel"),
  filmstrip: document.getElementById("filmstrip"),
  spawnbar: document.getElementById("spawnbar"),
  toast: document.getElementById("toast"),
  portraitDock: document.getElementById("portrait-dock"),
  agentSlotPrimary: document.getElementById("agent-slot-primary"),
  agentSlotSecondary: document.getElementById("agent-slot-secondary"),
  portraitTitle: document.getElementById("portrait-title"),
  portraitAvatar: document.getElementById("portrait-avatar"),
  portraitVideo: document.getElementById("portrait-video"),
  portraitTitle2: document.getElementById("portrait-title-2"),
  portraitAvatar2: document.getElementById("portrait-avatar-2"),
  portraitVideo2: document.getElementById("portrait-video-2"),
  selectionMeta: document.getElementById("selection-meta"),
  motherState: document.getElementById("mother-state"),
  motherRolePreview: document.getElementById("mother-role-preview"),
  tipsText: document.getElementById("tips-text"),
  motherOverlay: document.getElementById("mother-overlay"),
  motherPanelStack: document.getElementById("mother-panel-stack"),
  motherPanel: document.getElementById("mother-panel"),
  motherRefineToggle: document.getElementById("mother-refine-toggle"),
  motherAdvanced: document.getElementById("mother-advanced"),
  motherTransformationMode: document.getElementById("mother-transformation-mode"),
  motherRoleSubject: document.getElementById("mother-role-subject"),
  motherRoleModel: document.getElementById("mother-role-model"),
  motherRoleMediator: document.getElementById("mother-role-mediator"),
  motherRoleObject: document.getElementById("mother-role-object"),
  motherAvatar: document.getElementById("mother-avatar"),
  motherVideo: document.getElementById("mother-video"),
  motherAbilityIcon: document.getElementById("mother-ability-icon"),
  motherConfirm: document.getElementById("mother-confirm"),
  motherStop: document.getElementById("mother-stop"),
  canvasMoodStatus: document.getElementById("canvas-mood-status"),
  motherMoodToggle: document.getElementById("mother-mood-toggle"),
  motherMoodMenu: document.getElementById("mother-mood-menu"),
  actionGrid: document.getElementById("action-grid"),
  imageMenu: document.getElementById("image-menu"),
  motherWheelMenu: document.getElementById("mother-wheel-menu"),
  quickActions: document.getElementById("quick-actions"),
  timelineToggle: document.getElementById("timeline-toggle"),
  timelineOverlay: document.getElementById("timeline-overlay"),
  timelineClose: document.getElementById("timeline-close"),
  timelineStrip: document.getElementById("timeline-strip"),
  timelineDetail: document.getElementById("timeline-detail"),
  openrouterOnboardingModal: document.getElementById("openrouter-onboarding-modal"),
  openrouterOnboardingHeader: document.getElementById("openrouter-onboarding-header"),
  openrouterOnboardingTitle: document.getElementById("openrouter-onboarding-title"),
  openrouterOnboardingSubtitle: document.getElementById("openrouter-onboarding-subtitle"),
  openrouterOnboardingProgress: document.getElementById("openrouter-onboarding-progress"),
  openrouterOnboardingBody: document.getElementById("openrouter-onboarding-body"),
  openrouterOnboardingClose: document.getElementById("openrouter-onboarding-close"),
  openrouterOnboardingBack: document.getElementById("openrouter-onboarding-back"),
  openrouterOnboardingSkip: document.getElementById("openrouter-onboarding-skip"),
  openrouterOnboardingNext: document.getElementById("openrouter-onboarding-next"),
  openrouterOnboardingMediaVideo: document.getElementById("openrouter-onboarding-media-video"),
  aestheticOnboardingModal: document.getElementById("aesthetic-onboarding-modal"),
  aestheticOnboardingTitle: document.getElementById("aesthetic-onboarding-title"),
  aestheticOnboardingSubtitle: document.getElementById("aesthetic-onboarding-subtitle"),
  aestheticOnboardingProgress: document.getElementById("aesthetic-onboarding-progress"),
  aestheticOnboardingBody: document.getElementById("aesthetic-onboarding-body"),
  aestheticOnboardingClose: document.getElementById("aesthetic-onboarding-close"),
  aestheticOnboardingBack: document.getElementById("aesthetic-onboarding-back"),
  aestheticOnboardingSkip: document.getElementById("aesthetic-onboarding-skip"),
  aestheticOnboardingNext: document.getElementById("aesthetic-onboarding-next"),
};

localStorage.setItem("brood.rsNative", "1");
localStorage.setItem("brood.rsNative.default.v2", "1");
localStorage.removeItem("brood.emergencyCompatFallback");

function normalizePromptStrategyMode(raw) {
  const value = String(raw || "").trim().toLowerCase();
  if (value === "auto") return "auto";
  if (value === "baseline") return "baseline";
  return "tail";
}

function loadPromptBenchmarkTrials() {
  try {
    const raw = localStorage.getItem(PROMPT_BENCHMARK_LS_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    if (!Array.isArray(parsed)) return [];
    return parsed
      .map((row) => (row && typeof row === "object" ? row : null))
      .filter(Boolean)
      .map((row) => ({
        id: Number(row.id) || 0,
        strategy: (() => {
          const s = String(row.strategy || "").trim().toLowerCase();
          if (s === "baseline" || s === "tail" || s === "repeat") return s;
          return "tail";
        })(),
        model: String(row.model || "").trim() || "unknown",
        startedAt: Number(row.startedAt) || Date.now(),
        status: String(row.status || "").trim().toLowerCase() === "failed" ? "failed" : "success",
        versionId: row.versionId ? String(row.versionId) : null,
        promptChars: Math.max(0, Number(row.promptChars) || 0),
        constraintCount: Math.max(0, Number(row.constraintCount) || 0),
        costUsd: Number.isFinite(Number(row.costUsd)) ? Number(row.costUsd) : null,
        latencyS: Number.isFinite(Number(row.latencyS)) ? Number(row.latencyS) : null,
        error: row.error ? String(row.error) : null,
      }))
      .filter((row) => row.id > 0)
      .slice(-PROMPT_BENCHMARK_MAX_TRIALS);
  } catch {
    return [];
  }
}

function normalizePromptBenchmarkStrategy(raw) {
  const value = String(raw || "").trim().toLowerCase();
  if (value === "baseline" || value === "tail" || value === "repeat") return value;
  return "tail";
}

function normalizePromptBenchmarkModel(raw) {
  const value = String(raw || "").trim();
  return value || "unknown";
}

function promptBenchmarkHydrateState() {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return;
  const history = Array.isArray(bench.trials) ? bench.trials.slice(-PROMPT_BENCHMARK_MAX_TRIALS) : [];
  bench.trials = history;
  bench.pendingIds = [];
  bench.versionToTrialId = new Map();
  bench.awaitingCostTrialIds = [];
  bench.trialById = new Map();
  let maxId = 0;
  for (const row of history) {
    if (!row || typeof row !== "object") continue;
    const id = Number(row.id) || 0;
    if (id <= 0) continue;
    row.id = id;
    row.strategy = normalizePromptBenchmarkStrategy(row.strategy);
    row.model = normalizePromptBenchmarkModel(row.model);
    row.status = String(row.status || "").trim().toLowerCase() === "failed" ? "failed" : "success";
    row.versionId = row.versionId ? String(row.versionId) : null;
    row.promptChars = Math.max(0, Number(row.promptChars) || 0);
    row.constraintCount = Math.max(0, Number(row.constraintCount) || 0);
    row.costUsd = Number.isFinite(Number(row.costUsd)) ? Number(row.costUsd) : null;
    row.latencyS = Number.isFinite(Number(row.latencyS)) ? Number(row.latencyS) : null;
    row.error = row.error ? String(row.error) : null;
    bench.trialById.set(id, row);
    if (id > maxId) maxId = id;
  }
  bench.nextId = Math.max(1, maxId + 1);
}

function promptBenchmarkPersistHistory() {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return;
  const serializable = (Array.isArray(bench.trials) ? bench.trials : [])
    .slice(-PROMPT_BENCHMARK_MAX_TRIALS)
    .map((row) => ({
      id: Number(row?.id) || 0,
      strategy: normalizePromptBenchmarkStrategy(row?.strategy),
      model: normalizePromptBenchmarkModel(row?.model),
      startedAt: Number(row?.startedAt) || Date.now(),
      status: String(row?.status || "").trim().toLowerCase() === "failed" ? "failed" : "success",
      versionId: row?.versionId ? String(row.versionId) : null,
      promptChars: Math.max(0, Number(row?.promptChars) || 0),
      constraintCount: Math.max(0, Number(row?.constraintCount) || 0),
      costUsd: Number.isFinite(Number(row?.costUsd)) ? Number(row.costUsd) : null,
      latencyS: Number.isFinite(Number(row?.latencyS)) ? Number(row.latencyS) : null,
      error: row?.error ? String(row.error) : null,
    }))
    .filter((row) => row.id > 0);
  try {
    localStorage.setItem(PROMPT_BENCHMARK_LS_KEY, JSON.stringify(serializable));
  } catch {
    // ignore localStorage failures
  }
}

function promptBenchmarkSyncHistoryRow(trialId) {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return;
  const id = Number(trialId) || 0;
  if (id <= 0) return;
  const trial = bench.trialById.get(id);
  if (!trial) return;
  const index = bench.trials.findIndex((row) => Number(row?.id) === id);
  if (index >= 0) {
    bench.trials[index] = trial;
  } else {
    bench.trials.push(trial);
  }
  if (bench.trials.length > PROMPT_BENCHMARK_MAX_TRIALS) {
    const dropCount = bench.trials.length - PROMPT_BENCHMARK_MAX_TRIALS;
    const removed = bench.trials.splice(0, dropCount);
    for (const row of removed) {
      const removedId = Number(row?.id) || 0;
      if (!removedId) continue;
      bench.trialById.delete(removedId);
      bench.pendingIds = bench.pendingIds.filter((value) => Number(value) !== removedId);
      bench.awaitingCostTrialIds = bench.awaitingCostTrialIds.filter((value) => Number(value) !== removedId);
    }
  }
}

function promptBenchmarkRenderReadout() {
  if (!els.promptBenchmarkReadout) return;
  const bench = state.promptBenchmark;
  const trials = Array.isArray(bench?.trials) ? bench.trials : [];
  const currentModel = normalizePromptBenchmarkModel(settings?.imageModel);
  const configuredMode = normalizePromptStrategyMode(settings?.promptStrategyMode || "tail");
  if (configuredMode === "auto") {
    const auto = promptBenchmarkAutoStrategyForModel(currentModel, { fallback: "tail" });
    const reason =
      auto.reason === "insufficient_data"
        ? `insufficient data (${auto.totalAttempts})`
        : auto.reason === "no_model_data"
          ? "no model data"
          : `benchmark (${auto.totalAttempts})`;
    const summaryLine = `Auto active: ${auto.strategy} for ${currentModel} (${reason})`;
    if (!trials.length) {
      els.promptBenchmarkReadout.textContent = `${summaryLine}\nNo benchmark data yet`;
      return;
    }
  }
  if (!trials.length) {
    els.promptBenchmarkReadout.textContent = "No benchmark data yet";
    return;
  }

  const strategyOrder = ["baseline", "tail", "repeat"];
  const modelRows = new Map();
  for (const row of trials) {
    if (!row || typeof row !== "object") continue;
    const model = normalizePromptBenchmarkModel(row.model);
    const strategy = normalizePromptBenchmarkStrategy(row.strategy);
    if (!modelRows.has(model)) {
      modelRows.set(model, {
        total: 0,
        byStrategy: new Map(strategyOrder.map((key) => [key, []])),
      });
    }
    const bucket = modelRows.get(model);
    bucket.total += 1;
    if (!bucket.byStrategy.has(strategy)) bucket.byStrategy.set(strategy, []);
    bucket.byStrategy.get(strategy).push(row);
  }

  const lines = [];
  if (configuredMode === "auto") {
    const auto = promptBenchmarkAutoStrategyForModel(currentModel, { fallback: "tail" });
    const reason =
      auto.reason === "insufficient_data"
        ? `insufficient data (${auto.totalAttempts})`
        : auto.reason === "no_model_data"
          ? "no model data"
          : `benchmark (${auto.totalAttempts})`;
    lines.push(`Auto active: ${auto.strategy} for ${currentModel} (${reason})`);
  }
  lines.push(`Total trials: ${trials.length}`);
  const orderedModels = Array.from(modelRows.entries()).sort((a, b) => {
    const totalA = Number(a?.[1]?.total) || 0;
    const totalB = Number(b?.[1]?.total) || 0;
    if (totalB !== totalA) return totalB - totalA;
    return String(a?.[0] || "").localeCompare(String(b?.[0] || ""));
  });
  for (const [model, bucket] of orderedModels) {
    lines.push(`${model} (${bucket.total})`);
    for (const strategy of strategyOrder) {
      const rows = Array.isArray(bucket.byStrategy.get(strategy)) ? bucket.byStrategy.get(strategy) : [];
      if (!rows.length) {
        lines.push(`  ${strategy}: no runs`);
        continue;
      }
      const success = rows.filter((row) => row.status === "success").length;
      const attempts = rows.length;
      const successPct = Math.round((success / Math.max(1, attempts)) * 100);
      const costRows = rows.map((row) => Number(row.costUsd)).filter((value) => Number.isFinite(value));
      const latencyRows = rows.map((row) => Number(row.latencyS)).filter((value) => Number.isFinite(value));
      const charsRows = rows.map((row) => Number(row.promptChars)).filter((value) => Number.isFinite(value));
      const avgCost = costRows.length ? costRows.reduce((sum, value) => sum + value, 0) / costRows.length : null;
      const avgLatency = latencyRows.length
        ? latencyRows.reduce((sum, value) => sum + value, 0) / latencyRows.length
        : null;
      const avgChars = charsRows.length ? Math.round(charsRows.reduce((sum, value) => sum + value, 0) / charsRows.length) : 0;
      lines.push(
        `  ${strategy}: ${successPct}% (${success}/${attempts}) | cost ${formatUsd(avgCost) || "n/a"} | latency ${
          avgLatency !== null ? `${avgLatency.toFixed(1)}s` : "n/a"
        } | prompt ${avgChars} chars`
      );
    }
  }
  els.promptBenchmarkReadout.textContent = lines.join("\n");
}

function promptBenchmarkAutoStrategyForModel(model = "", { fallback = "tail", minTrials = 4 } = {}) {
  const fallbackMode = normalizePromptStrategyMode(fallback) === "baseline" ? "baseline" : "tail";
  const modelKey = normalizePromptBenchmarkModel(model);
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") {
    return {
      strategy: fallbackMode,
      reason: "no_benchmark_state",
      totalAttempts: 0,
    };
  }
  const sourceRows = Array.isArray(bench.trials) ? bench.trials : [];
  const rows = sourceRows.filter((row) => {
    const rowModel = normalizePromptBenchmarkModel(row?.model);
    if (rowModel !== modelKey) return false;
    const strategy = normalizePromptBenchmarkStrategy(row?.strategy);
    return strategy === "tail" || strategy === "baseline";
  });
  if (!rows.length) {
    return {
      strategy: fallbackMode,
      reason: "no_model_data",
      totalAttempts: 0,
    };
  }
  const byStrategy = new Map([
    ["tail", []],
    ["baseline", []],
  ]);
  for (const row of rows) {
    const strategy = normalizePromptBenchmarkStrategy(row?.strategy);
    if (!byStrategy.has(strategy)) continue;
    byStrategy.get(strategy).push(row);
  }
  const totalAttempts = rows.length;
  if (totalAttempts < Math.max(2, Number(minTrials) || 4)) {
    return {
      strategy: fallbackMode,
      reason: "insufficient_data",
      totalAttempts,
    };
  }

  const summarize = (list = []) => {
    const attempts = list.length;
    const success = list.filter((row) => String(row?.status || "").trim().toLowerCase() === "success").length;
    const smoothedSuccess = (success + 1) / (attempts + 2); // Beta(1,1) prior
    const latencyRows = list
      .map((row) => Number(row?.latencyS))
      .filter((value) => Number.isFinite(value) && value > 0);
    const costRows = list
      .map((row) => Number(row?.costUsd))
      .filter((value) => Number.isFinite(value) && value >= 0);
    const avgLatency = latencyRows.length
      ? latencyRows.reduce((sum, value) => sum + value, 0) / latencyRows.length
      : null;
    const avgCost = costRows.length
      ? costRows.reduce((sum, value) => sum + value, 0) / costRows.length
      : null;
    return { attempts, success, smoothedSuccess, avgLatency, avgCost };
  };

  const ranked = ["tail", "baseline"]
    .map((strategy) => ({
      strategy,
      metrics: summarize(byStrategy.get(strategy)),
    }))
    .filter((row) => row.metrics.attempts > 0)
    .sort((a, b) => {
      const aMetrics = a.metrics;
      const bMetrics = b.metrics;
      if (bMetrics.smoothedSuccess !== aMetrics.smoothedSuccess) {
        return bMetrics.smoothedSuccess - aMetrics.smoothedSuccess;
      }
      const aLatency = Number.isFinite(aMetrics.avgLatency) ? aMetrics.avgLatency : Number.POSITIVE_INFINITY;
      const bLatency = Number.isFinite(bMetrics.avgLatency) ? bMetrics.avgLatency : Number.POSITIVE_INFINITY;
      if (aLatency !== bLatency) return aLatency - bLatency;
      const aCost = Number.isFinite(aMetrics.avgCost) ? aMetrics.avgCost : Number.POSITIVE_INFINITY;
      const bCost = Number.isFinite(bMetrics.avgCost) ? bMetrics.avgCost : Number.POSITIVE_INFINITY;
      if (aCost !== bCost) return aCost - bCost;
      if (bMetrics.attempts !== aMetrics.attempts) return bMetrics.attempts - aMetrics.attempts;
      return a.strategy.localeCompare(b.strategy);
    });

  if (!ranked.length) {
    return {
      strategy: fallbackMode,
      reason: "no_ranked_data",
      totalAttempts,
    };
  }
  return {
    strategy: ranked[0].strategy,
    reason: "benchmark",
    totalAttempts,
  };
}

function promptBenchmarkRegisterDispatch({ strategy = "tail", model = "unknown", promptChars = 0, constraintCount = 0 } = {}) {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return 0;
  const trialId = Math.max(1, Number(bench.nextId) || 1);
  bench.nextId = trialId + 1;
  const trial = {
    id: trialId,
    strategy: normalizePromptBenchmarkStrategy(strategy),
    model: normalizePromptBenchmarkModel(model),
    startedAt: Date.now(),
    status: "pending",
    versionId: null,
    promptChars: Math.max(0, Number(promptChars) || 0),
    constraintCount: Math.max(0, Number(constraintCount) || 0),
    costUsd: null,
    latencyS: null,
    error: null,
  };
  bench.trialById.set(trialId, trial);
  bench.pendingIds.push(trialId);
  while (bench.pendingIds.length > 24) {
    const dropped = Number(bench.pendingIds.shift()) || 0;
    if (!dropped) break;
    if (!bench.trials.some((row) => Number(row?.id) === dropped)) {
      bench.trialById.delete(dropped);
    }
  }
  promptBenchmarkRenderReadout();
  return trialId;
}

function promptBenchmarkBindVersion(versionId) {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return 0;
  const normalizedVersionId = String(versionId || "").trim();
  if (!normalizedVersionId) return 0;
  if (bench.versionToTrialId.has(normalizedVersionId)) return Number(bench.versionToTrialId.get(normalizedVersionId)) || 0;
  while (bench.pendingIds.length) {
    const candidate = Number(bench.pendingIds.shift()) || 0;
    if (!candidate) continue;
    const trial = bench.trialById.get(candidate);
    if (!trial) continue;
    if (trial.status !== "pending") continue;
    trial.versionId = normalizedVersionId;
    bench.versionToTrialId.set(normalizedVersionId, candidate);
    return candidate;
  }
  return 0;
}

function promptBenchmarkResolveTrialIdForFailure(versionId = null) {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return 0;
  const normalizedVersionId = String(versionId || "").trim();
  if (normalizedVersionId && bench.versionToTrialId.has(normalizedVersionId)) {
    return Number(bench.versionToTrialId.get(normalizedVersionId)) || 0;
  }
  for (const rawId of bench.pendingIds) {
    const id = Number(rawId) || 0;
    if (!id) continue;
    const trial = bench.trialById.get(id);
    if (trial && trial.status === "pending") return id;
  }
  return 0;
}

function promptBenchmarkFinalizeTrial(trialId, { status = "success", error = null, costUsd = null, latencyS = null } = {}) {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return false;
  const id = Number(trialId) || 0;
  if (!id) return false;
  const trial = bench.trialById.get(id);
  if (!trial) return false;
  if (trial.status !== "pending" && trial.status !== "success" && trial.status !== "failed") return false;
  const nextStatus = String(status || "").trim().toLowerCase() === "failed" ? "failed" : "success";
  if (trial.status !== "pending" && trial.status === nextStatus && nextStatus === "success") {
    // Allow metrics hydration for already completed successful rows.
  } else if (trial.status !== "pending") {
    return false;
  }
  trial.status = nextStatus;
  trial.error = nextStatus === "failed" ? (error ? String(error) : null) : null;
  if (Number.isFinite(Number(costUsd))) trial.costUsd = Number(costUsd);
  if (Number.isFinite(Number(latencyS))) trial.latencyS = Number(latencyS);

  bench.pendingIds = bench.pendingIds.filter((value) => Number(value) !== id);
  if (trial.versionId) {
    bench.versionToTrialId.delete(String(trial.versionId));
  }
  if (nextStatus === "success" && (trial.costUsd === null || trial.latencyS === null)) {
    if (!bench.awaitingCostTrialIds.includes(id)) bench.awaitingCostTrialIds.push(id);
  } else {
    bench.awaitingCostTrialIds = bench.awaitingCostTrialIds.filter((value) => Number(value) !== id);
  }

  promptBenchmarkSyncHistoryRow(id);
  promptBenchmarkPersistHistory();
  promptBenchmarkRenderReadout();
  return true;
}

function promptBenchmarkMarkSuccessFromArtifactEvent(event = {}) {
  const versionId = motherEventVersionId(event);
  if (!versionId) return false;
  const trialId = Number(state.promptBenchmark?.versionToTrialId?.get(versionId)) || 0;
  if (!trialId) return false;
  const metrics = event.metrics && typeof event.metrics === "object" ? event.metrics : null;
  const costUsd = Number.isFinite(Number(metrics?.cost_total_usd)) ? Number(metrics.cost_total_usd) : null;
  const latencyS = Number.isFinite(Number(metrics?.latency_per_image_s)) ? Number(metrics.latency_per_image_s) : null;
  return promptBenchmarkFinalizeTrial(trialId, {
    status: "success",
    costUsd,
    latencyS,
  });
}

function promptBenchmarkMarkFailureFromGenerationFailedEvent(event = {}) {
  const versionId = motherEventVersionId(event);
  const trialId = promptBenchmarkResolveTrialIdForFailure(versionId);
  if (!trialId) return false;
  return promptBenchmarkFinalizeTrial(trialId, {
    status: "failed",
    error: event?.error ? String(event.error) : "generation_failed",
  });
}

function promptBenchmarkAttachCostLatencyEvent(event = {}) {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return false;
  if (!bench.awaitingCostTrialIds.length) return false;
  const incomingModel = normalizePromptBenchmarkModel(event?.model);
  let trialId = 0;
  if (incomingModel && incomingModel !== "unknown") {
    for (const candidateRaw of bench.awaitingCostTrialIds) {
      const candidate = Number(candidateRaw) || 0;
      if (!candidate) continue;
      const row = bench.trialById.get(candidate);
      if (!row) continue;
      if (normalizePromptBenchmarkModel(row.model) === incomingModel) {
        trialId = candidate;
        break;
      }
    }
  }
  if (!trialId) {
    trialId = Number(bench.awaitingCostTrialIds[0]) || 0;
  }
  if (!trialId) return false;
  const trial = bench.trialById.get(trialId);
  if (!trial) return false;
  if (Number.isFinite(Number(event?.cost_total_usd))) trial.costUsd = Number(event.cost_total_usd);
  if (Number.isFinite(Number(event?.latency_per_image_s))) trial.latencyS = Number(event.latency_per_image_s);
  bench.awaitingCostTrialIds = bench.awaitingCostTrialIds.filter((value) => Number(value) !== trialId);
  promptBenchmarkSyncHistoryRow(trialId);
  promptBenchmarkPersistHistory();
  promptBenchmarkRenderReadout();
  return true;
}

function promptBenchmarkReset() {
  const bench = state.promptBenchmark;
  if (!bench || typeof bench !== "object") return;
  bench.trials = [];
  bench.pendingIds = [];
  bench.trialById = new Map();
  bench.versionToTrialId = new Map();
  bench.awaitingCostTrialIds = [];
  bench.nextId = 1;
  try {
    localStorage.removeItem(PROMPT_BENCHMARK_LS_KEY);
  } catch {
    // ignore localStorage failures
  }
  promptBenchmarkRenderReadout();
}

// Product direction: use Mother intent realtime only; disable always-on canvas context.
const ALWAYS_ON_CANVAS_CONTEXT_ENABLED = false;

const settings = {
  memory: localStorage.getItem("brood.memory") === "1",
  alwaysOnVision: (() => {
    if (!ALWAYS_ON_CANVAS_CONTEXT_ENABLED) {
      try {
        localStorage.setItem("brood.alwaysOnVision", "0");
      } catch {
        // ignore localStorage failures
      }
      return false;
    }
    const raw = localStorage.getItem("brood.alwaysOnVision");
    // Default ON: Mother suggestions depend on realtime canvas context.
    if (raw === null) return true;
    return raw === "1";
  })(),
  autoAcceptSuggestedAbility: localStorage.getItem("brood.autoAcceptSuggestedAbility") === "1",
  textModel: localStorage.getItem("brood.textModel") || "gpt-5.2",
  imageModel: (() => {
    const storedRaw = String(localStorage.getItem("brood.imageModel") || "").trim();
    const migrated = localStorage.getItem(IMAGE_MODEL_DEFAULT_MIGRATION_KEY) === "1";
    if (!storedRaw) {
      if (!migrated) localStorage.setItem(IMAGE_MODEL_DEFAULT_MIGRATION_KEY, "1");
      return DEFAULT_IMAGE_MODEL;
    }
    if (!migrated && storedRaw === LEGACY_DEFAULT_IMAGE_MODEL) {
      localStorage.setItem("brood.imageModel", DEFAULT_IMAGE_MODEL);
      localStorage.setItem(IMAGE_MODEL_DEFAULT_MIGRATION_KEY, "1");
      return DEFAULT_IMAGE_MODEL;
    }
    if (!migrated) localStorage.setItem(IMAGE_MODEL_DEFAULT_MIGRATION_KEY, "1");
    return storedRaw;
  })(),
  promptStrategyMode: normalizePromptStrategyMode(localStorage.getItem(PROMPT_STRATEGY_MODE_KEY) || "auto"),
  promptRepeatFull: localStorage.getItem(PROMPT_REPEAT_FULL_KEY) === "1",
};

function defaultAestheticAnswers() {
  return {
    imageChoiceId: "",
    featurePriority: "",
    directionality: "",
  };
}

const aestheticOnboardingState = {
  open: false,
  stepIndex: 0,
  answers: defaultAestheticAnswers(),
  source: "first_run",
  applying: false,
  transitionTimer: null,
};

function defaultOpenRouterOnboardingDraft() {
  return {
    apiKey: "",
  };
}

const openrouterOnboardingState = {
  open: false,
  stepIndex: 0,
  source: "first_run",
  draft: defaultOpenRouterOnboardingDraft(),
  submitting: false,
  statusMessage: "",
  statusError: false,
  keyMasked: null,
  envPath: null,
  transitionTimer: null,
};

const state = {
  runDir: null,
  eventsPath: null,
  ptySpawned: false,
  ptySpawning: false,
  engineLaunchMode: "native",
  engineLaunchPath: null,
  pendingPtyExit: false,
  poller: null,
  pollInFlight: false,
  eventsByteOffset: 0,
  eventsTail: "",
  eventsDecoder: new TextDecoder("utf-8"),
  images: [],
  imagesById: new Map(),
  imagePaletteSeed: 0, // monotonic assignment for rotating Google palette accents
  imageEffectTokenByImageId: new Map(), // imageId -> effectTokenId (collapsed visual replacement)
  effectTokensById: new Map(), // effectTokenId -> token payload
  activeId: null,
  selectedIds: [], // imageId[] (multi-select in multi canvas; last entry is "active")
  imageCache: new Map(), // path -> { url: string|null, urlPromise: Promise<string>|null, imgPromise: Promise<HTMLImageElement>|null }
  thumbsById: new Map(), // artifactId -> { rootEl, imgEl, labelEl }
  // Hide the filmstrip by default (keeps the UI focused on the canvas). The feature remains
  // implemented; set `localStorage.brood.showFilmstrip = "1"` to re-enable in dev.
  filmstripVisible: localStorage.getItem("brood.showFilmstrip") === "1",
  timelineNodes: [], // [{ nodeId, imageId, path, receiptPath, label, action, parents, createdAt }]
  timelineNodesById: new Map(), // nodeId -> node
  timelineOpen: false,
  imageMenuTargetId: null,
  // Canvas rendering modes:
  // - "multi": freeform spatial canvas (primary mode; multiple images can be arranged on the canvas)
  // - "single": focused, zoomable view of the active image (secondary mode)
  canvasMode: "multi",
  // In multi/freeform mode we store rects in CSS pixels and derive device-pixel rects each render.
  freeformRects: new Map(), // imageId -> { x, y, w, h } in canvas CSS pixels (top-left anchored)
  freeformZOrder: [], // imageId[] draw/hit-test order (last is top)
  multiRects: new Map(), // imageId -> { x, y, w, h } in canvas device pixels (hit-testing + canvas->image mapping).
  // Used for local (non-engine) actions so the Action Grid can show the pressed state while running.
  runningActionKey: null, // string | null
  pendingBlend: null, // { sourceIds: [string, string], startedAt: number }
  pendingSwapDna: null, // { structureId: string, surfaceId: string, startedAt: number }
  pendingBridge: null, // { sourceIds: [string, string], startedAt: number }
  pendingExtractDna: null, // { sourceIds: string[], startedAt: number }
  pendingSoulLeech: null, // { sourceIds: string[], startedAt: number }
  pendingExtractRule: null, // { sourceIds: [string, string, string], startedAt: number }
  pendingOddOneOut: null, // { sourceIds: [string, string, string], startedAt: number }
  pendingTriforce: null, // { sourceIds: [string, string, string], startedAt: number }
  pendingCreateLayers: null, // { sourceId, sourcePath, layerSpecs, nextIndex, createdIds, startedAt }
  pendingPromptGenerate: null, // { prompt: string, model: string, startedAt: number, anchorCss?: {x,y}, anchorWorldCss?: {x,y} }
  pendingMotherDraft: null, // { sourceIds: string[], startedAt: number }
  pendingRecast: null, // { sourceId: string, startedAt: number }
  pendingGeneration: null, // { remaining: number, provider: string|null, model: string|null }
  pendingRecreate: null, // { startedAt: number } | null
  actionQueue: [],
  actionQueueActive: null, // { id, label, key, priority, enqueuedAt, source } | null
  actionQueueRunning: false,
  motherMood: loadMotherMoodPreference(),
  actionQueueStats: {
    replacedByKey: 0,
    droppedOverflow: 0,
    lastDropLabel: null,
  },
  view: {
    scale: 1,
    offsetX: 0,
    offsetY: 0,
  },
  // Multi-mode doesn't use the single-image view transform, but users still expect panning.
  multiView: {
    scale: 1,
    offsetX: 0,
    offsetY: 0,
  },
  tool: "pan",
  pointer: {
    active: false,
    kind: null, // POINTER_KINDS.FREEFORM_MOVE | POINTER_KINDS.FREEFORM_RESIZE | POINTER_KINDS.FREEFORM_ROTATE | POINTER_KINDS.FREEFORM_SKEW | POINTER_KINDS.FREEFORM_IMPORT | POINTER_KINDS.FREEFORM_WHEEL | POINTER_KINDS.MOTHER_ROLE_DRAG | POINTER_KINDS.EFFECT_TOKEN_DRAG
    imageId: null,
    role: null,
    corner: null, // "nw"|"ne"|"sw"|"se"
    startRectCss: null, // { x, y, w, h }
    transformHandleEdge: null, // "left" | "right"
    transformPivotX: 0,
    transformPivotY: 0,
    transformAnchorWidthPx: 0,
    transformStartAngleRad: 0,
    transformStartRotateDeg: 0,
    transformStartSkewXDeg: 0,
    startX: 0,
    startY: 0,
    lastX: 0,
    lastY: 0,
    startCssX: 0,
    startCssY: 0,
    startOffsetX: 0,
    startOffsetY: 0,
    importPointCss: null, // { x, y }
    wheelOnTap: false,
    moved: false,
    semanticInteractionEmitted: false,
  },
  promptGenerateHoverCss: null, // last known canvas hover point in CSS px
  reelTouch: {
    x: 0,
    y: 0,
    visibleUntil: 0,
    downUntil: 0,
    down: false,
  },
  effectTokenDrag: null, // { tokenId, sourceImageId, targetImageId, moved, x, y }
  effectTokenApplyLocks: new Map(), // tokenId -> { dispatchId, targetImageId, queued, startedAt }
  motherOverlayUiHits: [], // [{ kind, targetId?, rect: {x,y,w,h} }]
  activeImageTransformUiHits: [], // [{ kind, edge?, cursor?, targetId, rect: {x,y,w,h} }]
  motherResultDetailsOpenId: null, // imageId currently showing provenance popover
  wheelMenu: {
    open: false,
    hideTimer: null,
    anchorCss: null, // { x, y } | null
    anchorWorld: null, // { x, y } | null
  },
  selection: null, // { points: [{x,y}], closed: true }
  lassoDraft: [],
  annotateDraft: null, // { imageId, x0, y0, x1, y1, at } | null (image pixel space)
  annotateBox: null, // { imageId, x0, y0, x1, y1, at } | null (final box until dismissed)
  promptGenerateDraft: { prompt: "", model: "" },
  promptGenerateDraftAnchor: null, // { anchorCss: {x,y}, anchorWorldCss: {x,y} } | null
  circleDraft: null, // { imageId, cx, cy, r, color, at } | null (image pixel space)
  circlesByImageId: new Map(), // imageId -> [{ id, cx, cy, r, color, label, at }]
  activeCircle: null, // { imageId, id } | null
  tripletRuleAnnotations: new Map(), // imageId -> [{ x: number, y: number, label: string }]
  tripletOddOneOutId: null, // string|null
  needsEngineModelResync: false, // restore `/image_model` to settings after one-off overrides.
  engineImageModelRestore: null, // string|null
  needsRender: false,
  lastInteractionAt: Date.now(),
  lastMotherHotAt: Date.now(),
  userEvents: [], // scoring ring consumed by intent/proposal weighting
  userTelemetryEvents: [], // high-volume event log (not used for scoring)
  userEventSeq: 0,
  mother: {
    running: false,
    startedAt: 0,
    runId: 0,
    action: null, // string|null
    status: null, // string|null
    stopRequested: false,
    timer: null,
    rtHoldUntil: 0,
    rtHoldTimer: null,
    rtVisualActive: false,
    rtVisualRawSince: 0,
    rtVisualMinUntil: 0,
    hotSyncAt: 0,
  },
  motherIdle: {
    phase: motherIdleInitialState(),
    firstIdleTimer: null,
    intentIdleTimer: null,
    takeoverTimer: null,
    cooldownTimer: null,
    hasGeneratedSinceInteraction: false,
    generatedImageId: null,
    generatedVersionId: null,
    pendingDispatchToken: 0,
    dispatchTimeoutTimer: null,
    dispatchTimeoutExtensions: 0,
    pendingPromptLine: null,
    promptMotionProfile: null,
    pendingVersionId: null,
    ignoredVersionIds: new Set(),
    waitingSince: 0,
    pendingSuggestionLog: null, // { request_id, what, why, prompt, source_images, dispatched_at_iso } | null
    lastSuggestionAt: 0,
    suppressFailureUntil: 0,
    retryAttempted: false,
    lastDispatchModel: null,
    blockedUntilUserInteraction: false,
    actionVersion: 0,
    pendingActionVersion: 0,
    cooldownUntil: 0,
    multiUploadIdleBoostUntil: 0,
    lastUploadCompletedAt: 0,
    lastSpeculativePrefetchUploadAt: 0,
    speculativePrefetchTimer: null,
    speculativePrefetchInFlight: false,
    speculativePrefetchReadyMode: null,
    pendingIntent: false,
    pendingIntentRequestId: null,
    pendingIntentTransportRetryCount: 0,
    pendingIntentStartedAt: 0,
    pendingIntentUpgradeUntil: 0,
    pendingIntentRealtimePath: null,
    intentRealtimeBusyPath: null,
    intentRealtimeBusyRequestId: null,
    intentRealtimeBusyUntil: 0,
    intentReplayQueued: false,
    intentReplayReason: null,
    pendingIntentPath: null,
    pendingIntentPayload: null,
    pendingIntentTimeout: null,
    pendingPromptCompile: false,
    pendingPromptCompileSpeculative: false,
    pendingPromptCompilePath: null,
    pendingPromptCompileTimeout: null,
    pendingVisionImageIds: [],
    pendingVisionRetryTimer: null,
    pendingGeneration: false,
    pendingDispatchSpeculative: false,
    pendingDispatchProposalMode: null,
    liveProposalRefreshTimer: null,
    liveProposalUpdating: false,
    lastLiveProposalRefreshAt: 0,
    pendingFollowupAfterCooldown: false,
    pendingFollowupReason: null,
    lastRejectedProposal: null, // { contextSig, imageSetSig, mode, summary, at_ms } | null
    rejectedModeHistoryByContext: {}, // contextSig -> recently rejected transformation modes
    cancelArtifactUntil: 0,
    cancelArtifactReason: null,
    intent: null, // structured intent payload from intent realtime (with fallback inference)
    currentOperationSpec: null, // { op_id, op_type, target_id, reference_ids, mode, trigger_source } | null
    roles: { subject: [], model: [], mediator: [], object: [] },
    drafts: [], // [{ id, path, receiptPath, versionId, actionVersion, createdAt, img }]
    selectedDraftId: null,
    hoverDraftId: null,
    commitMutationInFlight: false,
    roleGlyphHits: [], // [{ role, imageId, rect }]
    offerDetailsOpen: false,
    roleGlyphDrag: null, // { role, imageId, startX, startY, moved }
    advancedOpen: false,
    optionReveal: false,
    hintLevel: 0, // 0 hidden, 1 subtle, 2 engaged
    hintVisibleUntil: 0,
    hintFadeTimer: null,
    intensity: 62, // optional UI steering dial
    commitUndo: null, // { expiresAt, mode, insertedId, targetId, before, removedSeeds }
    telemetry: {
      traceId: `mother-${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 8)}`,
      stateTransitions: [],
      accepted: 0,
      rejected: 0,
      deployed: 0,
      stale: 0,
    },
  },
  fileBrowser: {
    enabled: ENABLE_FILE_BROWSER_DOCK,
    rootDir: String(localStorage.getItem(FILE_BROWSER_ROOT_DIR_LS_KEY) || "").trim() || null,
    cwd: null,
    entries: [],
    importPathMap: new Map(),
    selectedPath: null,
    loading: false,
    error: null,
    draggingPath: null,
    history: [],
    loadSeq: 0,
    thumbCache: new Map(), // path -> { url, urlPromise, imgPromise }
    observer: null,
    clickImportTimer: null,
    dragClearTimer: null,
    suppressClickUntil: 0,
    manualDrag: {
      active: false,
      pointerId: null,
      path: null,
      previewPath: null,
      startX: 0,
      startY: 0,
      moved: false,
      ghostEl: null,
    },
  },
  spawnNodes: [],
  spawnTimer: null,
  larvaTargets: [], // { turbEl, dispEl, seed }
  larvaUid: 0,
  spawnCooldowns: new Map(), // `${imageId}::${nodeId}` -> untilMs
  describePendingPath: null,
  expectingArtifacts: false,
  pendingReplace: null, // { targetId, startedAt, label }
  lastRecreatePrompt: null,
  lastAction: null,
  lastTipText: null,
  lastDirectorText: null,
  lastDirectorMeta: null, // { kind, source, model, at, paths }
  lastCostLatency: null, // { provider, model, cost_total_usd, cost_per_1k_images_usd, latency_per_image_s, at }
  sessionApiCalls: 0,
  topMetrics: {
    tokenInByMinute: new Map(), // minute -> tokens in
    tokenOutByMinute: new Map(), // minute -> tokens out
    queueDepthByMinute: new Map(), // minute -> pending+running depth
    sessionEstimatedCostUsd: 0,
    renderDurationsS: [], // rolling last successful render durations
  },
  promptBenchmark: {
    trials: loadPromptBenchmarkTrials(),
    pendingIds: [],
    trialById: new Map(),
    versionToTrialId: new Map(),
    awaitingCostTrialIds: [],
    nextId: 1,
  },
  lastStatusText: "Engine: idle",
  lastStatusError: false,
  fallbackToFullRead: false,
  keyStatus: null, // { openai, openrouter, gemini, imagen, flux, anthropic, realtime_provider_*, realtime_ready_* }
  intent: {
    locked: true,
    lockedAt: 0,
    lockedBranchId: null,
    startedAt: 0,
    deadlineAt: 0,
    totalRounds: 3,
    round: 1,
    selections: [], // [{ round, branch_id, token }]
    focusBranchId: null,
    iconState: null, // last parsed JSON
    iconStateAt: 0,
    pending: false,
    pendingPath: null,
    pendingAt: 0,
    pendingFrameId: null,
    frameSeq: 0,
    rtState: "off", // "off" | "connecting" | "ready" | "failed"
    disabledReason: null, // non-null = show "hard" failure state (missing keys, etc.)
	    lastError: null, // string|null (non-hard last failure message)
	    lastErrorAt: 0,
	    lastSignature: null,
	    lastRunAt: 0,
	    forceChoice: false,
	    uiHideSuggestion: false,
	    uiHits: [], // [{ kind, id, rect }]
	  },
  intentAmbient: {
    enabled: false,
    pending: false,
    pendingPath: null,
    pendingAt: 0,
    pendingFrameId: null,
    frameSeq: 0,
    rtState: "off", // "off" | "connecting" | "ready" | "failed"
    disabledReason: null,
    lastError: null,
    lastErrorAt: 0,
    lastSignature: null,
    lastRunAt: 0,
    iconState: null,
    iconStateAt: 0,
    touchedImageIds: [],
    suggestions: [], // [{ id, asset_type, asset_key/src, anchor, confidence, world_rect, created_at_ms, updated_at_ms }]
    uiHits: [], // [{ kind, id, rect, branchId, assetKey, anchorImageIds }]
    lastReason: null,
  },
  alwaysOnVision: {
    enabled: settings.alwaysOnVision,
    pending: false,
    pendingPath: null,
    pendingAt: 0,
    contentDirty: false,
    dirtyReason: null,
    lastSignature: null,
    lastRunAt: 0,
    lastText: null,
    lastMeta: null, // { source, model, at, image_path }
    rtState: settings.alwaysOnVision ? "connecting" : "off", // "off" | "connecting" | "ready" | "failed"
    disabledReason: null, // string|null (set when auto-disabled due to a fatal realtime error)
    portraitOverride: null, // { slot: "primary"|"secondary", provider, title, busy } | null
  },
  canvasContextSuggestion: null, // { action: string, why: string|null, at: number, source: string|null, model: string|null } | null
  autoAcceptSuggestedAbility: {
    enabled: settings.autoAcceptSuggestedAbility,
    passes: 0,
    lastAcceptedAt: 0, // rec.at of the most recently auto-accepted suggestion
    inFlight: false,
  },
  imageFx: {
    active: false,
    label: null,
  },
  portrait: {
    provider: null,
    title: "",
    busy: false,
  },
  portrait2: {
    provider: null,
    title: "",
    busy: false,
  },
  portraitMedia: {
    dir: null, // string|null
    dirChecked: false,
    dirPromise: null, // Promise<string|null>|null
    diskDir: null, // string|null (persisted across dev/prod builds via ~/.brood)
    diskDirChecked: false,
    diskDirPromise: null, // Promise<string|null>|null
    urlCache: new Map(), // path -> { url, urlPromise, imgPromise } (separate from canvas image cache)
    index: null, // { [agent: string]: { idle: string|null, working: string|null } }|null
    indexChecked: false,
    indexPromise: null, // Promise<object>|null
    activeKey1: null,
    activeKey2: null,
    activeKeyMother: null,
    missingToastShown: false,
    loadErrorToastShown: false,
    lastResolveError: null, // string|null (debug aid shown in Settings readout)
  },
};

promptBenchmarkHydrateState();

let flushDeferredEnginePtyExit = async () => {};

const DEFAULT_TIP = "Click Studio White to replace the background. Use 4 (Lasso) if you want a manual mask.";
const VISUAL_PROMPT_FILENAME = "visual_prompt.json";
const VISUAL_PROMPT_SCHEMA_VERSION = 1;
const VISUAL_GRAMMAR_VERSION = "v0";

// Larva spawn buttons were a fun experiment, but we're turning them off for now.
// Keep the implementation in place so we can re-enable later.
const ENABLE_LARVA_SPAWN = false;
// Spawnbar actions (Studio White, Variations, etc) sit on the canvas "control surface".
// Disable by default; the inspector still contains Abilities.
const ENABLE_SPAWN_ACTIONS = false;
// Drag/drop import is currently disabled; we still prevent file-drop navigation
// to protect the session/run.
const ENABLE_DRAG_DROP_IMPORT = false;

// Intent Canvas feature flags. Keep the full implementation in place so we can
// re-enable specific behaviors without ripping out code.
const INTENT_CANVAS_ENABLED = false; // disable onboarding intent decider (keep code intact)
const INTENT_AMBIENT_ENABLED = false; // ambient intent disabled
const INTENT_AMBIENT_ICON_PLACEMENT_ENABLED = false; // keep ambient inference, disable icon nudges/placement
const INTENT_TIMER_ENABLED = false; // hide LED timer + disable timeout-based force-choice
const INTENT_ROUNDS_ENABLED = false; // disable "max rounds" gating
const INTENT_FORCE_CHOICE_ENABLED = INTENT_TIMER_ENABLED || INTENT_ROUNDS_ENABLED;
const INTENT_AMBIENT_MAX_NUDGES = 3;
const INTENT_AMBIENT_ICON_WORLD_SIZE = 136;
const INTENT_AMBIENT_FADE_IN_MS = 280;

// Temporarily disabled custom canvas cursor (kept as a single knob for quick restore).
const INTENT_IMPORT_CURSOR = "default";
const REEL_TOUCH_MOVE_VISIBLE_MS = 120;
const REEL_TOUCH_TAP_VISIBLE_MS = 280;
const REEL_TOUCH_RELEASE_VISIBLE_MS = 150;
const PROMPT_GENERATE_SHIMMER_LOOP_MS = 1700;

// Intent onboarding overlay icon assets.
// Keep a procedural fallback so the app still renders if assets fail to load.
const INTENT_UI_START_ICON_SCALE = 1.12; // modestly bigger than the original procedural glyphs
const INTENT_UI_CHOICE_ICON_SCALE = 3.0; // YES/NO + suggested branch glyph (requested: 300% larger)
const INTENT_UI_ICON_ASSETS = {
  start_lock: new URL("./assets/intent-icons-sc/icons/intent-start-lock.png", import.meta.url).href,
  token_yes: new URL("./assets/intent-icons-sc/icons/intent-token-yes.png", import.meta.url).href,
  token_no: new URL("./assets/intent-icons-sc/icons/intent-token-no.png", import.meta.url).href,
  usecases: {},
};

const intentUiIcons = {
  ready: false,
  loadPromise: null,
  startLock: null,
  tokenYes: null,
  tokenNo: null,
  usecases: {},
};

function _loadUiImage(url) {
  const u = String(url || "").trim();
  if (!u) return Promise.resolve(null);
  return new Promise((resolve, reject) => {
    const img = new Image();
    try {
      img.crossOrigin = "anonymous";
    } catch {
      // ignore
    }
    img.onload = () => resolve(img);
    img.onerror = (err) => reject(err);
    img.src = u;
  });
}

function ensureIntentUiIconsLoaded() {
  if (intentUiIcons.loadPromise) return intentUiIcons.loadPromise;
  intentUiIcons.loadPromise = (async () => {
    try {
      const [startLock, tokenYes, tokenNo] = await Promise.all([
        _loadUiImage(INTENT_UI_ICON_ASSETS.start_lock),
        _loadUiImage(INTENT_UI_ICON_ASSETS.token_yes),
        _loadUiImage(INTENT_UI_ICON_ASSETS.token_no),
      ]);
      intentUiIcons.startLock = startLock;
      intentUiIcons.tokenYes = tokenYes;
      intentUiIcons.tokenNo = tokenNo;

      const usecases = INTENT_UI_ICON_ASSETS.usecases || {};
      const entries = Object.entries(usecases);
      const loaded = await Promise.all(entries.map(([, url]) => _loadUiImage(url)));
      const out = {};
      for (let i = 0; i < entries.length; i += 1) {
        const [k] = entries[i];
        out[String(k)] = loaded[i] || null;
      }
      intentUiIcons.usecases = out;
      intentUiIcons.ready = true;
      requestRender();
    } catch (err) {
      console.warn("Failed to load intent UI icons; falling back to procedural glyphs.", err);
      intentUiIcons.ready = false;
    }
  })();
  return intentUiIcons.loadPromise;
}

const INTENT_DEADLINE_MS = 60_000;
const INTENT_ENVELOPE_VERSION = 1;
const INTENT_SNAPSHOT_MAX_DIM_PX = 1200;
const INTENT_INFERENCE_DEBOUNCE_MS = 260;
const INTENT_INFERENCE_THROTTLE_MS = 900;
const INTENT_INFERENCE_TIMEOUT_MS = 15_000;
const INTENT_SNAPSHOT_LOAD_TIMEOUT_MS = 900;
const INTENT_SNAPSHOT_FAST_LOAD_TIMEOUT_MS = 260;
const INTENT_AMBIENT_IMPORT_DELAY_MS = 1200;
const INTENT_PERSIST_FILENAME = "intent_state.json";
const INTENT_LOCKED_FILENAME = "intent_locked.json";
const INTENT_TRACE_FILENAME = "intent_trace.jsonl";

let visualPromptWriteTimer = null;
let intentTraceSeq = 0;
let intentRealtimePortraitBusy = false;
const OPENAI_REALTIME_PORTRAIT_COOLDOWN_MS = 5_000;
let openaiRealtimePortraitHotUntil = 0;
let openaiRealtimePortraitBoostActive = false;
let openaiRealtimePortraitCooldownTimer = null;
let effectsRuntime = null;

function _intentTracePath() {
  if (!state.runDir) return null;
  return `${state.runDir}/${INTENT_TRACE_FILENAME}`;
}

async function appendIntentTrace(entry) {
  const outPath = _intentTracePath();
  if (!outPath) return false;

  const payload = {
    schema: "brood.intent_trace",
    schema_version: 1,
    seq: (intentTraceSeq += 1),
    at_ms: Date.now(),
    ...entry,
  };
  const line = `${JSON.stringify(payload)}\n`;

  try {
    await appendTextWithFallback(outPath, line, { maxBytes: 1_200_000 });
    return true;
  } catch {
    return false;
  }
}
function scheduleVisualPromptWrite({ immediate = false } = {}) {
  if (!state.runDir) return;
  const delay = immediate ? 0 : 350;
  clearTimeout(visualPromptWriteTimer);
  visualPromptWriteTimer = setTimeout(() => {
    writeVisualPrompt().catch((err) => {
      console.warn("Failed to write visual prompt:", err);
    });
  }, delay);
}

function formatUsd(value) {
  if (typeof value !== "number" || !Number.isFinite(value)) return null;
  if (value === 0) return "$0.00";
  if (value < 0.01) return `$${value.toFixed(4)}`;
  return `$${value.toFixed(2)}`;
}

function topMetricMinuteAt(ms = Date.now()) {
  return Math.floor((Number(ms) || Date.now()) / 60_000);
}

function topMetricPruneMinuteMap(map, { keepMinutes = TOP_METRICS_WINDOW_MINUTES, nowMs = Date.now() } = {}) {
  if (!(map instanceof Map)) return;
  const cutoff = topMetricMinuteAt(nowMs) - Math.max(keepMinutes, 1) - 2;
  for (const key of map.keys()) {
    if (Number(key) < cutoff) map.delete(key);
  }
}

function topMetricBumpMinuteMap(map, minute, delta) {
  if (!(map instanceof Map)) return;
  const key = Math.floor(Number(minute) || 0);
  if (!Number.isFinite(key)) return;
  const add = Math.max(0, Number(delta) || 0);
  if (!Number.isFinite(add) || add <= 0) return;
  map.set(key, (Number(map.get(key)) || 0) + add);
}

function topMetricSetMinuteMap(map, minute, value) {
  if (!(map instanceof Map)) return;
  const key = Math.floor(Number(minute) || 0);
  if (!Number.isFinite(key)) return;
  const next = Math.max(0, Number(value) || 0);
  if (!Number.isFinite(next)) return;
  map.set(key, next);
}

function readFirstFinite(obj, keys) {
  if (!obj || typeof obj !== "object") return null;
  for (const key of keys) {
    const n = Number(obj[key]);
    if (Number.isFinite(n) && n >= 0) return n;
  }
  return null;
}

function extractTokenUsageFromObject(obj) {
  if (!obj || typeof obj !== "object") return null;
  let input = readFirstFinite(obj, [
    "input_tokens",
    "prompt_tokens",
    "prompt_token_count",
    "promptTokenCount",
    "promptTokens",
    "tokens_in",
    "tokensIn",
    "inputTokenCount",
    "input_text_tokens",
    "text_count_tokens",
  ]);
  let output = readFirstFinite(obj, [
    "output_tokens",
    "completion_tokens",
    "completion_token_count",
    "completionTokenCount",
    "tokens_out",
    "tokensOut",
    "outputTokenCount",
    "output_text_tokens",
    "candidates_token_count",
    "candidatesTokenCount",
  ]);
  const total = readFirstFinite(obj, [
    "total_token_count",
    "totalTokenCount",
    "total_tokens",
    "totalTokens",
    "token_count",
    "tokenCount",
  ]);
  if (!Number.isFinite(input) && Number.isFinite(total) && Number.isFinite(output) && total >= output) {
    input = total - output;
  }
  if (!Number.isFinite(output) && Number.isFinite(total) && Number.isFinite(input) && total >= input) {
    output = total - input;
  }
  if (!Number.isFinite(input) && !Number.isFinite(output) && Number.isFinite(total)) {
    input = total;
    output = 0;
  }
  if (!Number.isFinite(input) && !Number.isFinite(output)) return null;
  return {
    input_tokens: Math.max(0, Math.round(Number(input) || 0)),
    output_tokens: Math.max(0, Math.round(Number(output) || 0)),
  };
}

function extractTokenUsage(payload) {
  if (!payload || typeof payload !== "object") return null;
  const visited = new Set();
  const queue = [payload];
  let steps = 0;
  while (queue.length && steps < 180) {
    const node = queue.shift();
    steps += 1;
    if (!node || typeof node !== "object") continue;
    if (visited.has(node)) continue;
    visited.add(node);
    const direct = extractTokenUsageFromObject(node);
    if (direct) return direct;
    const usage = node.usage;
    if (usage && typeof usage === "object") {
      const nested = extractTokenUsageFromObject(usage);
      if (nested) return nested;
      queue.push(usage);
    }
    for (const value of Object.values(node)) {
      if (!value) continue;
      if (Array.isArray(value)) {
        for (let i = 0; i < value.length && i < 8; i += 1) queue.push(value[i]);
      } else if (typeof value === "object") {
        queue.push(value);
      }
    }
  }
  return null;
}

function topMetricMinuteSeries(map, { windowMinutes = TOP_METRICS_WINDOW_MINUTES, nowMs = Date.now() } = {}) {
  const nowMinute = topMetricMinuteAt(nowMs);
  const out = [];
  let hasData = false;
  for (let i = windowMinutes - 1; i >= 0; i -= 1) {
    const minute = nowMinute - i;
    const raw = Number(map.get(minute)) || 0;
    const value = Math.max(0, raw);
    if (value > 0) hasData = true;
    out.push(value);
  }
  return { values: out, hasData };
}

function topMetricSmoothedRolling(values, { minutes = 5 } = {}) {
  const list = Array.isArray(values) ? values.map((v) => Math.max(0, Number(v) || 0)) : [];
  const n = Math.max(1, Math.min(Math.floor(Number(minutes) || 5), list.length));
  const slice = list.slice(-n);
  if (!slice.length) return 0;
  // Triangular weighting favors the center of the short window for smoother readout.
  const weights = [];
  for (let i = 0; i < slice.length; i += 1) {
    const mid = (slice.length - 1) / 2;
    const dist = Math.abs(i - mid);
    weights.push(Math.max(1, Math.round(slice.length - dist)));
  }
  let sum = 0;
  let wsum = 0;
  for (let i = 0; i < slice.length; i += 1) {
    const w = Number(weights[i]) || 1;
    sum += (Number(slice[i]) || 0) * w;
    wsum += w;
  }
  return wsum > 0 ? sum / wsum : 0;
}

function sparkline(values, { fallback = "--", maxValue = null } = {}) {
  const list = Array.isArray(values) ? values.map((v) => Math.max(0, Number(v) || 0)) : [];
  if (!list.length) return fallback;
  const overrideMax = Number(maxValue);
  const maxVal = Number.isFinite(overrideMax) && overrideMax > 0 ? overrideMax : Math.max(...list);
  if (!maxVal) return "Â·".repeat(Math.min(20, list.length));
  const last = SPARKLINE_GLYPHS.length - 1;
  return list
    .map((v) => {
      const idx = Math.round((Math.max(0, Number(v) || 0) / maxVal) * last);
      return SPARKLINE_GLYPHS[clamp(idx, 0, last)];
    })
    .join("");
}

function topMetricHeat(metric, value) {
  const v = Number(value);
  if (!Number.isFinite(v)) return "nodata";
  const t = TOP_METRICS_THRESHOLDS[metric];
  if (!t) return "nodata";
  if (v < t.cool_max) return "cool";
  if (v <= t.warm_max) return "warm";
  return "hot";
}

function ribbonStatusLabel(raw) {
  const text = String(raw || "").trim();
  if (!text) return "idle";
  return text
    .replace(/^(engine|director|mother|app)\s*:\s*/i, "")
    .replace(/\s+/g, " ")
    .trim()
    .toLowerCase();
}

function ribbonStatusState(raw, isError = false) {
  if (isError) return "error";
  const label = ribbonStatusLabel(raw);
  if (!label) return "idle";
  if (/\b(idle|off|disabled|exited|stopped)\b/i.test(label)) return "idle";
  if (/\b(ready|started|connected|imported|enabled|locked|committed|exported)\b/i.test(label)) return "ready";
  if (/\b(failed|error|boot failed)\b/i.test(label)) return "error";
  return "busy";
}

function engineStatusDotTooltip(statusText = "", stateKey = "idle") {
  const stateLabel = String(stateKey || "idle").trim() || "idle";
  const detail = String(statusText || "").trim() || "Engine: idle";
  return `Engine status dot\nShows current engine activity.\nState: ${stateLabel}\n${detail}`;
}

function realtimeIntentModelLabel(raw = "") {
  const normalized = String(raw || "").trim().toLowerCase();
  if (!normalized) return "";
  if (normalized.includes("gpt-realtime-mini")) return "gpt-realtime-mini";
  if (
    normalized.includes("gemini-3.0-flash") ||
    normalized.includes("gemini-3-flash-preview") ||
    normalized.includes("gemini-3-flash")
  ) {
    return "gemini-3.0-flash";
  }
  return String(raw || "").trim();
}

function realtimeIntentModelTone(raw = "") {
  const label = realtimeIntentModelLabel(raw).toLowerCase();
  if (!label) return "";
  if (label === "gpt-realtime-mini") return "openai-mini";
  if (label === "gemini-3.0-flash") return "gemini-flash";
  return "";
}

function intentSourceDotTooltip(kind = "", model = "") {
  const normalized = String(kind || "").trim().toLowerCase();
  const source = normalized === "realtime" ? "realtime" : "idle";
  const modelLabel = source === "realtime" ? realtimeIntentModelLabel(model) : "";
  if (modelLabel) {
    return `Intent source dot\nShows where Mother intent came from.\nSource: ${source}\nModel: ${modelLabel}`;
  }
  return `Intent source dot\nShows where Mother intent came from.\nSource: ${source}`;
}

function topMetricQueueCounts() {
  const pending = Math.max(0, Number(state.actionQueue?.length) || 0);
  const running = state.actionQueueActive || isEngineBusy() ? 1 : 0;
  return { pending, running };
}

function queuePreviewItems({ limit = 3 } = {}) {
  const maxItems = clamp(Math.round(Number(limit) || 3), 1, 6);
  const list = Array.isArray(state.actionQueue) ? state.actionQueue.slice() : [];
  if (!list.length) return [];
  return list
    .sort((a, b) => {
      const ap = typeof a?.priority === "number" ? a.priority : 0;
      const bp = typeof b?.priority === "number" ? b.priority : 0;
      if (ap !== bp) return bp - ap;
      return (a?.enqueuedAt || 0) - (b?.enqueuedAt || 0);
    })
    .slice(0, maxItems)
    .map((item) => String(item?.label || "Action").trim() || "Action");
}

function queueChipTooltip() {
  const queue = topMetricQueueCounts();
  const runningLabel = String(state.actionQueueActive?.label || "").trim();
  const preview = queuePreviewItems({ limit: 3 });
  const stats = state.actionQueueStats && typeof state.actionQueueStats === "object" ? state.actionQueueStats : {};
  const replaced = Math.max(0, Number(stats.replacedByKey) || 0);
  const dropped = Math.max(0, Number(stats.droppedOverflow) || 0);
  const lines = [];
  lines.push("Action queue");
  lines.push(`Running: ${runningLabel || (queue.running ? "engine task" : "none")}`);
  lines.push(`Pending: ${queue.pending}`);
  if (preview.length) lines.push(`Next: ${preview.join(" -> ")}`);
  if (replaced) lines.push(`Merged duplicate requests: ${replaced}`);
  if (dropped) lines.push(`Dropped (queue full): ${dropped}`);
  if (stats.lastDropLabel) lines.push(`Last dropped: ${stats.lastDropLabel}`);
  return lines.join("\n");
}

function topMetricIngestTokens({ inputTokens = 0, outputTokens = 0, atMs = Date.now() } = {}) {
  const inTokens = Math.max(0, Math.round(Number(inputTokens) || 0));
  const outTokens = Math.max(0, Math.round(Number(outputTokens) || 0));
  if (!inTokens && !outTokens) return;
  const metrics = state.topMetrics || null;
  if (!metrics) return;
  const minute = topMetricMinuteAt(atMs);
  topMetricBumpMinuteMap(metrics.tokenInByMinute, minute, inTokens);
  topMetricBumpMinuteMap(metrics.tokenOutByMinute, minute, outTokens);
  topMetricPruneMinuteMap(metrics.tokenInByMinute, { nowMs: atMs });
  topMetricPruneMinuteMap(metrics.tokenOutByMinute, { nowMs: atMs });
}

function topMetricIngestTokensFromPayload(payload, { atMs = Date.now(), render = false } = {}) {
  const tokens = extractTokenUsage(payload);
  if (!tokens) return false;
  topMetricIngestTokens({
    inputTokens: tokens.input_tokens,
    outputTokens: tokens.output_tokens,
    atMs,
  });
  if (render) renderSessionApiCallsReadout();
  return true;
}

function topMetricRealtimePricingForModel(model) {
  const raw = String(model || "").trim().toLowerCase();
  if (!raw) return null;
  const normalized = raw
    .replace(/^openai\//, "")
    .replace(/^google\//, "")
    .replace(/^openrouter\//, "");
  if (normalized.startsWith("gpt-realtime-mini")) return REALTIME_TOKEN_PRICING_USD_PER_1K["gpt-realtime-mini"];
  if (normalized.startsWith("gpt-4o-mini")) return REALTIME_TOKEN_PRICING_USD_PER_1K["gpt-4o-mini"];
  if (
    normalized.startsWith("gemini-3-flash-preview") ||
    normalized.startsWith("gemini-3.0-flash") ||
    normalized.startsWith("gemini-3-flash") ||
    (normalized.startsWith("gemini-") && normalized.includes("flash"))
  ) {
    return REALTIME_TOKEN_PRICING_USD_PER_1K["gemini-3-flash-preview"];
  }
  return null;
}

function estimateRealtimeTokenCostUsd({ model = "", inputTokens = 0, outputTokens = 0 } = {}) {
  const pricing = topMetricRealtimePricingForModel(model);
  if (!pricing) return null;
  const input = Math.max(0, Number(inputTokens) || 0);
  const output = Math.max(0, Number(outputTokens) || 0);
  if (!input && !output) return null;
  const inputCost = (input / 1000) * (Number(pricing.input) || 0);
  const outputCost = (output / 1000) * (Number(pricing.output) || 0);
  const total = inputCost + outputCost;
  if (!Number.isFinite(total) || total <= 0) return null;
  return total;
}

function topMetricIngestRealtimeCostFromPayload(payload, { render = false } = {}) {
  if (!payload || typeof payload !== "object") return false;
  if (payload.partial) return false;
  const source = String(payload.source || "").trim().toLowerCase();
  if (!realtimeSourceSupported(source)) return false;
  const tokens = extractTokenUsage(payload);
  if (!tokens) return false;
  const pricingModel = payload.provider_model || payload.model;
  const estimate = estimateRealtimeTokenCostUsd({
    model: pricingModel,
    inputTokens: tokens.input_tokens,
    outputTokens: tokens.output_tokens,
  });
  if (!(Number.isFinite(estimate) && estimate > 0)) return false;
  topMetricIngestCost(estimate);
  if (render) renderSessionApiCallsReadout();
  return true;
}

function topMetricIngestCost(value) {
  const n = Number(value);
  if (!Number.isFinite(n) || n <= 0) return;
  const metrics = state.topMetrics || null;
  if (!metrics) return;
  metrics.sessionEstimatedCostUsd = Math.max(0, Number(metrics.sessionEstimatedCostUsd) || 0) + n;
}

function topMetricIngestRenderDuration(seconds) {
  const n = Number(seconds);
  if (!Number.isFinite(n) || n <= 0) return;
  const metrics = state.topMetrics || null;
  if (!metrics) return;
  metrics.renderDurationsS.push(n);
  while (metrics.renderDurationsS.length > TOP_METRICS_RENDER_SAMPLE_MAX) metrics.renderDurationsS.shift();
}

function topMetricSampleQueueDepth({ nowMs = Date.now() } = {}) {
  const metrics = state.topMetrics || null;
  if (!metrics) return;
  const minute = topMetricMinuteAt(nowMs);
  const counts = topMetricQueueCounts();
  topMetricSetMinuteMap(metrics.queueDepthByMinute, minute, counts.pending + counts.running);
  topMetricPruneMinuteMap(metrics.queueDepthByMinute, { nowMs });
}

function renderTopMetricsGrid() {
  if (!els.topMetricsRoot) return;
  const metrics = state.topMetrics || null;
  if (!metrics) return;
  const nowMs = Date.now();
  topMetricSampleQueueDepth({ nowMs });

  const tokenInSeries = topMetricMinuteSeries(metrics.tokenInByMinute, { nowMs });
  const tokenOutSeries = topMetricMinuteSeries(metrics.tokenOutByMinute, { nowMs });
  const tokenInSmooth5 = topMetricSmoothedRolling(tokenInSeries.values, { minutes: 5 });
  const tokenOutSmooth5 = topMetricSmoothedRolling(tokenOutSeries.values, { minutes: 5 });
  const tokenSmoothedPerMinute = tokenInSmooth5 + tokenOutSmooth5;
  const hasTokenData = tokenInSeries.hasData || tokenOutSeries.hasData;
  const tokenInWindow = tokenInSeries.values.slice(-10);
  const tokenOutWindow = tokenOutSeries.values.slice(-10);
  const sharedTokenMax = Math.max(
    0,
    ...tokenInWindow.map((v) => Math.max(0, Number(v) || 0)),
    ...tokenOutWindow.map((v) => Math.max(0, Number(v) || 0))
  );

  if (els.topMetricTokensValue) {
    const inSpark = sparkline(tokenInWindow, { fallback: "Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·", maxValue: sharedTokenMax });
    const outSpark = sparkline(tokenOutWindow, { fallback: "Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·", maxValue: sharedTokenMax });
    els.topMetricTokensValue.innerHTML = [
      `<span class="top-metric-token-in">â†“ ${escapeHtml(inSpark)}</span>`,
      `<span class="top-metric-token-out">â†‘ ${escapeHtml(outSpark)}</span>`,
    ].join("");
  }
  if (els.topMetricTokensSparkIn) {
    els.topMetricTokensSparkIn.textContent = "";
    els.topMetricTokensSparkIn.classList.add("hidden");
  }
  if (els.topMetricTokensSparkOut) {
    els.topMetricTokensSparkOut.textContent = "";
    els.topMetricTokensSparkOut.classList.add("hidden");
  }
  if (els.topMetricApiCalls) {
    els.topMetricApiCalls.dataset.heat = "nodata";
  }
  if (els.topMetricApiCallsValue) {
    const apiCalls = Math.max(0, Number(state.sessionApiCalls) || 0);
    els.topMetricApiCallsValue.textContent = Number.isFinite(apiCalls) ? `${Math.round(apiCalls).toLocaleString("en-US")}` : "0";
  }
  if (els.topMetricTokens) {
    els.topMetricTokens.dataset.heat = hasTokenData ? topMetricHeat("tokens_per_minute", tokenSmoothedPerMinute) : "nodata";
  }

  const sessionCost = Number(metrics.sessionEstimatedCostUsd);
  const hasCost = Number.isFinite(sessionCost) && sessionCost >= 0;
  if (els.topMetricCostValue) {
    els.topMetricCostValue.textContent = hasCost ? formatUsd(sessionCost) || "$0.00" : "--";
  }
  if (els.topMetricCost) {
    els.topMetricCost.dataset.heat = hasCost ? topMetricHeat("session_cost_usd", sessionCost) : "nodata";
  }

  const queue = topMetricQueueCounts();
  const queueDepth = queue.pending + queue.running;
  const queueSeries = topMetricMinuteSeries(metrics.queueDepthByMinute, { nowMs });
  const queuePreview = queuePreviewItems({ limit: 1 });
  const queueStats = state.actionQueueStats && typeof state.actionQueueStats === "object" ? state.actionQueueStats : {};
  const replacedCount = Math.max(0, Number(queueStats.replacedByKey) || 0);
  const droppedCount = Math.max(0, Number(queueStats.droppedOverflow) || 0);
  const queueFlags = [];
  if (replacedCount) queueFlags.push(`U${Math.min(99, replacedCount)}`);
  if (droppedCount) queueFlags.push(`D${Math.min(99, droppedCount)}`);
  if (els.topMetricQueueValue) {
    const flags = queueFlags.length ? ` ${queueFlags.join("/")}` : "";
    els.topMetricQueueValue.textContent = `P${queue.pending} R${queue.running}${flags}`;
  }
  if (els.topMetricQueueTrend) {
    const runningLabel = String(state.actionQueueActive?.label || "").trim();
    if (runningLabel) {
      els.topMetricQueueTrend.textContent = `run:${clampText(runningLabel, 10)}`;
    } else if (queuePreview.length) {
      els.topMetricQueueTrend.textContent = `next:${clampText(queuePreview[0], 9)}`;
    } else {
      els.topMetricQueueTrend.textContent = sparkline(queueSeries.values.slice(-10));
    }
  }
  if (els.topMetricQueue) {
    els.topMetricQueue.dataset.heat = topMetricHeat("queued_calls", queueDepth);
    const queueTitle = queueChipTooltip();
    els.topMetricQueue.title = queueTitle;
    els.topMetricQueue.setAttribute("aria-label", queueTitle.replace(/\n/g, ". "));
  }

  const durations = Array.isArray(metrics.renderDurationsS) ? metrics.renderDurationsS : [];
  const avgRender =
    durations.length > 0 ? durations.reduce((sum, v) => sum + (Number(v) || 0), 0) / Math.max(1, durations.length) : null;
  if (els.topMetricRenderValue) {
    const sampleCount = durations.length;
    els.topMetricRenderValue.textContent = Number.isFinite(avgRender)
      ? `${(Number(avgRender) || 0).toFixed(1)}s/${sampleCount}`
      : "--";
  }
  if (els.topMetricRender) {
    els.topMetricRender.dataset.heat = Number.isFinite(avgRender) ? topMetricHeat("avg_render_s", avgRender) : "nodata";
  }

  if (els.engineStatus) {
    const status = state.lastStatusText ? String(state.lastStatusText) : "Engine: idle";
    const stateKey = ribbonStatusState(status, Boolean(state.lastStatusError));
    els.engineStatus.dataset.state = stateKey;
    els.engineStatus.textContent = "";
    els.engineStatus.title = engineStatusDotTooltip(status, stateKey);
    els.engineStatus.setAttribute("aria-label", `Engine status: ${ribbonStatusLabel(status) || "idle"}`);
  }
}

function resetTopMetrics() {
  const metrics = state.topMetrics || null;
  if (!metrics) return;
  metrics.tokenInByMinute.clear();
  metrics.tokenOutByMinute.clear();
  metrics.queueDepthByMinute.clear();
  metrics.sessionEstimatedCostUsd = 0;
  metrics.renderDurationsS = [];
}

function extractReceiptMeta(payload) {
  if (!payload || typeof payload !== "object") return null;
  const request = payload?.request || {};
  const resolved = payload?.resolved || {};
  const result = payload?.result_metadata || {};
  const provider = resolved?.provider || request?.provider || null;
  const model = resolved?.model || request?.model || null;
  const operation =
    request?.metadata?.operation ||
    request?.metadata?.action ||
    result?.operation ||
    request?.mode ||
    null;
  const cost_total_usd = typeof result?.cost_total_usd === "number" ? result.cost_total_usd : null;
  const latency_per_image_s = typeof result?.latency_per_image_s === "number" ? result.latency_per_image_s : null;
  const tokens = extractTokenUsage(payload);
  const prompt_api_payload = extractReceiptPromptApiPayload(payload);
  const creative_cues = extractReceiptCreativeCues(payload);
  return {
    provider,
    model,
    operation,
    cost_total_usd,
    latency_per_image_s,
    input_tokens: tokens?.input_tokens ?? null,
    output_tokens: tokens?.output_tokens ?? null,
    prompt_api_payload,
    creative_cues,
  };
}

function extractReceiptCreativeCues(payload) {
  if (!payload || typeof payload !== "object") return null;
  const request = payload?.request && typeof payload.request === "object" ? payload.request : null;
  const metadata = request?.metadata && typeof request.metadata === "object" ? request.metadata : null;
  if (!metadata) return null;
  const geminiPacket = metadata?.gemini_context_packet && typeof metadata.gemini_context_packet === "object"
    ? metadata.gemini_context_packet
    : null;
  const modelContextEnvelopes = metadata?.model_context_envelopes && typeof metadata.model_context_envelopes === "object"
    ? metadata.model_context_envelopes
    : null;
  const firstEnvelope = modelContextEnvelopes
    ? Object.values(modelContextEnvelopes).find((entry) => entry && typeof entry === "object") || null
    : null;
  const firstText = (...values) => {
    for (const value of values) {
      const text = String(value || "").trim();
      if (text) return text;
    }
    return null;
  };
  const shotType = firstText(
    geminiPacket?.proposal_lock?.shot_type,
    geminiPacket?.camera?.shot_type,
    geminiPacket?.shot_type_hints?.primary_shot_type,
    firstEnvelope?.shot_type,
    firstEnvelope?.camera?.shot_type,
    firstEnvelope?.shot_type_hints?.primary_shot_type
  );
  const alternateShotType = firstText(
    geminiPacket?.proposal_lock?.alternate_shot_type,
    geminiPacket?.camera?.alternate_shot_type,
    geminiPacket?.shot_type_hints?.alternate_shot_type,
    firstEnvelope?.alternate_shot_type,
    firstEnvelope?.camera?.alternate_shot_type,
    firstEnvelope?.shot_type_hints?.alternate_shot_type
  );
  const lightingProfile = firstText(
    geminiPacket?.proposal_lock?.lighting_profile,
    geminiPacket?.lighting?.profile,
    geminiPacket?.style?.lighting_profile,
    geminiPacket?.shot_type_hints?.primary_lighting_profile,
    firstEnvelope?.lighting_profile,
    firstEnvelope?.lighting?.profile,
    firstEnvelope?.shot_type_hints?.primary_lighting_profile
  );
  const alternateLightingProfile = firstText(
    geminiPacket?.proposal_lock?.alternate_lighting_profile,
    geminiPacket?.lighting?.alternate_profile,
    geminiPacket?.shot_type_hints?.alternate_lighting_profile,
    firstEnvelope?.alternate_lighting_profile,
    firstEnvelope?.lighting?.alternate_profile,
    firstEnvelope?.shot_type_hints?.alternate_lighting_profile
  );
  const lensGuidance = firstText(
    geminiPacket?.proposal_lock?.lens_guidance,
    geminiPacket?.camera?.lens_guidance,
    geminiPacket?.style?.lens_guidance,
    geminiPacket?.shot_type_hints?.primary_lens_guidance,
    firstEnvelope?.lens_guidance,
    firstEnvelope?.camera?.lens_guidance,
    firstEnvelope?.shot_type_hints?.primary_lens_guidance
  );
  const alternateLensGuidance = firstText(
    geminiPacket?.proposal_lock?.alternate_lens_guidance,
    geminiPacket?.camera?.alternate_lens_guidance,
    geminiPacket?.shot_type_hints?.alternate_lens_guidance,
    firstEnvelope?.alternate_lens_guidance,
    firstEnvelope?.camera?.alternate_lens_guidance,
    firstEnvelope?.shot_type_hints?.alternate_lens_guidance
  );
  if (
    !shotType &&
    !alternateShotType &&
    !lightingProfile &&
    !alternateLightingProfile &&
    !lensGuidance &&
    !alternateLensGuidance
  ) {
    return null;
  }
  return {
    shot_type: shotType,
    alternate_shot_type: alternateShotType,
    lighting_profile: lightingProfile,
    alternate_lighting_profile: alternateLightingProfile,
    lens_guidance: lensGuidance,
    alternate_lens_guidance: alternateLensGuidance,
  };
}

function extractReceiptPromptApiPayload(payload) {
  if (!payload || typeof payload !== "object") return null;
  const providerRequest = payload?.provider_request && typeof payload.provider_request === "object"
    ? payload.provider_request
    : null;
  const request = payload?.request && typeof payload.request === "object" ? payload.request : null;
  const resolved = payload?.resolved && typeof payload.resolved === "object" ? payload.resolved : null;
  const providerPayload = providerRequest?.payload && typeof providerRequest.payload === "object"
    ? providerRequest.payload
    : null;
  const transport = String(providerPayload?.transport || providerRequest?.transport || "").trim() || null;
  const endpoint = String(providerRequest?.endpoint || "").trim() || null;
  const envelopePayload =
    providerPayload?.payload && typeof providerPayload.payload === "object"
      ? providerPayload.payload
      : providerPayload;
  const model =
    String(
      envelopePayload?.model ||
        resolved?.model ||
        request?.model ||
        ""
    ).trim() || null;

  const sanitizePromptContent = (value, keyHint = "") => {
    if (value === null || value === undefined) return value;
    if (typeof value === "string") {
      const lowerKey = String(keyHint || "").toLowerCase();
      if (value.startsWith("data:image/")) {
        const mediaType = value.slice(5, value.indexOf(";base64,") > 0 ? value.indexOf(";base64,") : 20);
        return `<omitted ${mediaType || "image"} data URI>`;
      }
      if (
        lowerKey === "image_url" ||
        lowerKey === "image" ||
        lowerKey === "b64_json" ||
        lowerKey === "data" ||
        lowerKey === "inline_data" ||
        lowerKey === "inlinedata"
      ) {
        if (value.length > 72) return `<omitted binary-like string (${value.length} chars)>`;
      }
      if (value.length > 900) return `${value.slice(0, 897)}...`;
      return value;
    }
    if (Array.isArray(value)) {
      return value.map((entry) => sanitizePromptContent(entry, keyHint));
    }
    if (typeof value === "object") {
      const out = {};
      for (const [key, raw] of Object.entries(value)) {
        const lowerKey = String(key || "").toLowerCase();
        if (
          lowerKey === "image_url" ||
          lowerKey === "image" ||
          lowerKey === "inline_data" ||
          lowerKey === "inlinedata" ||
          lowerKey === "b64_json" ||
          lowerKey === "bytes_base64"
        ) {
          if (typeof raw === "string" && raw) {
            out[key] = sanitizePromptContent(raw, lowerKey);
            continue;
          }
          if (raw && typeof raw === "object") {
            out[key] = "<omitted image payload>";
            continue;
          }
        }
        out[key] = sanitizePromptContent(raw, key);
      }
      return out;
    }
    return value;
  };

  const promptPayload = {};
  if (transport) promptPayload.transport = transport;
  if (endpoint) promptPayload.endpoint = endpoint;
  if (model) promptPayload.model = model;

  if (Array.isArray(envelopePayload?.input) && envelopePayload.input.length) {
    promptPayload.input = sanitizePromptContent(envelopePayload.input, "input");
  } else if (Array.isArray(envelopePayload?.messages) && envelopePayload.messages.length) {
    promptPayload.messages = sanitizePromptContent(envelopePayload.messages, "messages");
  } else if (Array.isArray(envelopePayload?.contents) && envelopePayload.contents.length) {
    promptPayload.contents = sanitizePromptContent(envelopePayload.contents, "contents");
  }

  const promptText = String(
    envelopePayload?.prompt ||
      request?.prompt ||
      resolved?.prompt ||
      ""
  ).trim();
  if (promptText) promptPayload.prompt = promptText;

  if (!Object.keys(promptPayload).length) return null;
  return promptPayload;
}

async function ensureReceiptMeta(item) {
  if (!item?.receiptPath) return;
  if (item.receiptMetaChecked) return;
  if (item.receiptMetaLoading) return;
  item.receiptMetaLoading = true;
  try {
    const payload = JSON.parse(await readTextFile(item.receiptPath));
    item.receiptMeta = extractReceiptMeta(payload);
  } catch {
    item.receiptMeta = null;
  } finally {
    item.receiptMetaChecked = true;
    item.receiptMetaLoading = false;
  }
  if (getActiveImage()?.id === item.id) {
    renderHudReadout();
  }
  requestRender();
}

async function ingestTopMetricsFromReceiptPath(receiptPath, { allowCostFallback = false, allowLatencyFallback = false } = {}) {
  const path = String(receiptPath || "").trim();
  if (!path) return;
  try {
    const payload = JSON.parse(await readTextFile(path));
    const meta = extractReceiptMeta(payload);
    if (!meta) return;
    if (allowCostFallback) topMetricIngestCost(meta.cost_total_usd);
    if (allowLatencyFallback) topMetricIngestRenderDuration(meta.latency_per_image_s);
    topMetricIngestTokens({
      inputTokens: meta.input_tokens,
      outputTokens: meta.output_tokens,
    });
    renderSessionApiCallsReadout();
  } catch {
    // ignore
  }
}

function clampText(text, maxLen) {
  const s = String(text || "").trim();
  if (!s) return "";
  if (s.length <= maxLen) return s;
  return `${s.slice(0, Math.max(0, maxLen - 1))}â€¦`;
}

let hudDescTypeoutTimer = null;
let hudDescTypeoutTarget = "";
let hudDescTypeoutIndex = 0;
let hudDescTypeoutImageId = null;

function stopHudDescTypeout() {
  clearTimeout(hudDescTypeoutTimer);
  hudDescTypeoutTimer = null;
  hudDescTypeoutTarget = "";
  hudDescTypeoutIndex = 0;
  hudDescTypeoutImageId = null;
  if (els.hudUnitDesc) els.hudUnitDesc.classList.remove("is-typing");
}

function hudDescTypeoutTick() {
  if (!els.hudUnitDesc) {
    stopHudDescTypeout();
    return;
  }
  const remaining = hudDescTypeoutTarget.length - hudDescTypeoutIndex;
  if (remaining <= 0) {
    els.hudUnitDesc.classList.remove("is-typing");
    hudDescTypeoutTimer = null;
    return;
  }
  let step = 1;
  if (remaining > 42) step = 3;
  else if (remaining > 18) step = 2;
  hudDescTypeoutIndex = Math.min(hudDescTypeoutTarget.length, hudDescTypeoutIndex + step);
  els.hudUnitDesc.textContent = hudDescTypeoutTarget.slice(0, hudDescTypeoutIndex);
  hudDescTypeoutTimer = setTimeout(hudDescTypeoutTick, 42);
}

function startHudDescTypeout(imageId, text) {
  const targetImageId = String(imageId || "").trim();
  const targetText = String(text || "").trim();
  if (!targetImageId || !targetText || !els.hudUnitDesc) return;
  if (hudDescTypeoutImageId === targetImageId && hudDescTypeoutTarget === targetText && hudDescTypeoutTimer) return;
  stopHudDescTypeout();
  hudDescTypeoutImageId = targetImageId;
  hudDescTypeoutTarget = targetText;
  hudDescTypeoutIndex = 0;
  els.hudUnitDesc.textContent = "";
  els.hudUnitDesc.classList.add("is-typing");
  hudDescTypeoutTick();
}

function hudDescShouldStartTypeout(imageId, text) {
  const targetImageId = String(imageId || "").trim();
  const targetText = String(text || "").trim();
  if (!targetImageId || !targetText) return false;
  return hudDescTypeoutImageId !== targetImageId || hudDescTypeoutTarget !== targetText;
}

function renderHudReadout() {
  if (!els.hud) return;
  const img = getActiveImage();
  const hasImage = Boolean(img);
  const zoomScale = state.canvasMode === "multi" ? state.multiView.scale || 1 : state.view.scale || 1;
  // HUD is always visible; show placeholders when no image is loaded.
  if (!hasImage) {
    stopHudDescTypeout();
    const sel = state.selection?.points?.length >= 3 ? `${state.selection.points.length} pts` : "none";
    const zoomPct = Math.round(zoomScale * 100);
    if (els.hudUnitName) els.hudUnitName.textContent = "NO IMAGE";
    if (els.hudUnitDesc) els.hudUnitDesc.textContent = "Tap or drag to add photos";
    if (els.hudUnitSel) els.hudUnitSel.textContent = `imgs:0 Â· ${sel} Â· ${state.tool} Â· ${zoomPct}%`;
    if (els.hudLineDirector) els.hudLineDirector.classList.add("hidden");
    if (els.hudDirectorVal) els.hudDirectorVal.textContent = "";
    if (els.hudDirectorKey) els.hudDirectorKey.textContent = "DIR";
    if (els.hudLineDesc) els.hudLineDesc.classList.remove("hidden");
    if (els.hudLineSel) els.hudLineSel.classList.remove("hidden");
    return;
  }

  // Best-effort per-image receipt metadata (provider/model/cost) for the HUD.
  if (img && img.receiptPath && !img.receiptMetaChecked && !img.receiptMetaLoading) {
    ensureReceiptMeta(img).catch(() => {});
  }

  const name = basename(img.path) || "Untitled";
  const dims = img?.width && img?.height ? ` (${img.width}x${img.height})` : "";
  if (els.hudUnitName) els.hudUnitName.textContent = `${name}${dims}`;

  let desc = "";
  let descFromVision = false;
  if (img?.visionDesc) {
    desc = String(img.visionDesc || "").trim();
    descFromVision = true;
  } else if (img?.visionPending) {
    desc = "ANALYZINGâ€¦";
  } else if (img?.path && describeQueued.has(img.path)) {
    desc = state.ptySpawned ? "QUEUEDâ€¦" : state.ptySpawning ? "STARTINGâ€¦" : "ENGINE OFFLINE";
  } else {
    const allowVision = state.keyStatus
      ? Boolean(state.keyStatus.openai || state.keyStatus.gemini || state.keyStatus.openrouter)
      : true;
    if (!state.ptySpawned) desc = "ENGINE OFFLINE";
    else desc = allowVision ? "â€”" : "NO VISION KEYS";
  }
  const descText = desc || "â€”";
  const activeImageId = String(img?.id || "").trim();
  const typeoutLocked =
    descFromVision &&
    hudDescTypeoutImageId === activeImageId &&
    hudDescTypeoutTarget === descText &&
    hudDescTypeoutTimer;
  if (descFromVision && !typeoutLocked && hudDescShouldStartTypeout(activeImageId, descText)) {
    startHudDescTypeout(activeImageId, descText);
  } else if (!typeoutLocked && els.hudUnitDesc) {
    els.hudUnitDesc.textContent = descText;
  }
  if (!descFromVision) {
    stopHudDescTypeout();
  }

  const sel = state.selection?.points?.length >= 3 ? `${state.selection.points.length} pts` : "none";
  const imgSel = selectedCount();
  const zoomPct = Math.round(zoomScale * 100);
  if (els.hudUnitSel) els.hudUnitSel.textContent = `imgs:${imgSel} Â· ${sel} Â· ${state.tool} Â· ${zoomPct}%`;

  const directorRaw = state.lastDirectorText ? String(state.lastDirectorText) : "";
  const directorMeta = state.lastDirectorMeta && typeof state.lastDirectorMeta === "object" ? state.lastDirectorMeta : null;
  const directorKind = directorMeta?.kind ? String(directorMeta.kind) : "";
  let directorText = directorRaw.trim();
  if (directorText.length > 8000) directorText = `${directorText.slice(0, 7999).trimEnd()}\nâ€¦`;
  const hasDirector = Boolean(directorText);

  if (els.hudDirectorKey) {
    let key = "DIR";
    if (directorKind === "extract_rule") key = "RULE";
    if (directorKind === "odd_one_out") key = "ODD";
    els.hudDirectorKey.textContent = key;
  }
  if (els.hudDirectorVal) els.hudDirectorVal.textContent = directorText || "";
  if (els.hudLineDirector) els.hudLineDirector.classList.toggle("hidden", !hasDirector);
  // Keep the HUD focused when CD output is present.
  if (els.hudLineDesc) els.hudLineDesc.classList.toggle("hidden", hasDirector);
  if (els.hudLineSel) els.hudLineSel.classList.toggle("hidden", hasDirector);
}

// Give vision requests enough time to complete under normal network conditions.
// (Engine-side OpenAI timeout is ~22s; keep a little buffer.)
const DESCRIBE_TIMEOUT_MS = 30000;
const DESCRIBE_MAX_IN_FLIGHT = 3;
const UPLOAD_DESCRIBE_PRIORITY_BURST = 3;
const VISION_FALLBACK_REFRESH_MIN_MS = 20000;
const motherDispatchTransformExportCache = new Map(); // signature -> exported image path
let describeQueue = [];
let describeQueued = new Set(); // path strings
let describeForceRefresh = new Set(); // path strings queued to refresh existing labels
let describeInFlightOrder = [];
let describeInFlightTimers = new Map(); // path -> timeout id
let ptyLineBuffer = "";

function syncDescribePendingPath() {
  let next = null;
  for (const path of describeInFlightOrder) {
    if (describeInFlightTimers.has(path)) {
      next = path;
      break;
    }
  }
  if (!next && describeQueue.length) {
    next = describeQueue[0] || null;
  }
  state.describePendingPath = next || null;
}

function describeHasInFlight(path) {
  return describeInFlightTimers.has(path);
}

function clearDescribeInFlightPath(path) {
  const target = String(path || "").trim();
  if (!target) return false;
  const timer = describeInFlightTimers.get(target);
  if (timer) clearTimeout(timer);
  const hadInFlight = describeInFlightTimers.delete(target);
  if (hadInFlight) {
    describeInFlightOrder = describeInFlightOrder.filter((queuedPath) => queuedPath !== target);
  }
  syncDescribePendingPath();
  return hadInFlight;
}

function dropDescribeQueuedPath(path) {
  const target = String(path || "").trim();
  if (!target) return false;
  const beforeLen = describeQueue.length;
  describeQueue = describeQueue.filter((queuedPath) => queuedPath !== target);
  const removedFromSet = describeQueued.delete(target);
  describeForceRefresh.delete(target);
  syncDescribePendingPath();
  return removedFromSet || beforeLen !== describeQueue.length;
}

function oldestDescribeInFlightPath() {
  while (describeInFlightOrder.length) {
    const candidate = describeInFlightOrder[0];
    if (describeInFlightTimers.has(candidate)) return candidate;
    describeInFlightOrder.shift();
  }
  syncDescribePendingPath();
  return null;
}

let ptyStatusPromise = null;
async function ensureEngineSpawned({ reason = "engine" } = {}) {
  if (state.ptySpawned) return true;
  if (state.ptySpawning) return false;
  if (!state.runDir || !state.eventsPath) return false;

  // Try to re-sync with the Rust backend in dev/HMR scenarios where the PTY
  // may still be alive but the frontend state was reset.
  try {
    if (!ptyStatusPromise) {
      ptyStatusPromise = invoke("get_pty_status").finally(() => {
        ptyStatusPromise = null;
      });
    }
    const status = await ptyStatusPromise;
    if (status && typeof status === "object" && status.running) {
      state.ptySpawned = true;
      setStatus("Engine: connected");
      return true;
    }
  } catch (_) {
    // Ignore and fall back to spawning.
  }

  await spawnEngine();
  if (!state.ptySpawned) {
    showToast(`Engine failed to start for ${reason}.`, "error", 3200);
  }
  return Boolean(state.ptySpawned);
}

function allowVisionDescribe() {
  return state.keyStatus
    ? Boolean(state.keyStatus.openai || state.keyStatus.gemini || state.keyStatus.openrouter)
    : true;
}

function preferRealtimeVisionDescriptions() {
  if (!INTENT_AMBIENT_ENABLED) return false;
  const ambient = state.intentAmbient;
  if (!ambient || !ambient.enabled) return false;
  // Keep /describe as a fallback if realtime is known-bad.
  if (ambient.rtState === "failed") return false;
  return allowAmbientIntentRealtime();
}

function allowVisionDescribeInCurrentMode({ fallback = false } = {}) {
  // Realtime intent labels are the default vision-description path.
  // Keep /describe only for explicit fallback paths.
  if (intentModeActive()) return false;
  if (preferRealtimeVisionDescriptions()) return Boolean(fallback);
  return true;
}

function resetDescribeQueue({ clearPending = false } = {}) {
  describeQueue = [];
  describeQueued.clear();
  describeForceRefresh.clear();
  for (const timer of describeInFlightTimers.values()) {
    if (timer) clearTimeout(timer);
  }
  describeInFlightTimers.clear();
  describeInFlightOrder = [];
  state.describePendingPath = null;

  if (!clearPending) return;
  for (const item of state.images) {
    if (item && item.visionPending && !item.visionDesc) {
      item.visionPending = false;
    }
  }
  renderHudReadout();
}

function dropVisionDescribePath(path, { cancelInFlight = true } = {}) {
  const target = String(path || "").trim();
  if (!target) return;
  const wasInFlight = describeHasInFlight(target);
  dropDescribeQueuedPath(target);
  if (cancelInFlight && wasInFlight) {
    const item = state.images.find((img) => img?.path === target) || null;
    if (item && item.visionPending && !item.visionDesc) item.visionPending = false;
    clearDescribeInFlightPath(target);
    processDescribeQueue();
  }
}

function processDescribeQueue() {
  if (describeInFlightOrder.length >= DESCRIBE_MAX_IN_FLIGHT) return;
  // Treat describe as background work; don't compete with queued actions.
  if (state.actionQueueActive || isEngineBusy()) return;
  if (!state.ptySpawned) {
    if (describeQueue.length > 0) {
      ensureEngineSpawned({ reason: "vision" })
        .then(() => {
          processDescribeQueue();
        })
        .catch(() => {});
    }
    return;
  }
  if (!allowVisionDescribe()) {
    resetDescribeQueue({ clearPending: true });
    return;
  }

  while (describeQueue.length && describeInFlightOrder.length < DESCRIBE_MAX_IN_FLIGHT) {
    const path = describeQueue.shift();
    if (typeof path !== "string" || !path) continue;
    describeQueued.delete(path);
    const forceRefresh = describeForceRefresh.delete(path);

    const item = state.images.find((img) => img?.path === path) || null;
    if (!item) continue;
    if (item && item.visionDesc && !forceRefresh) {
      item.visionPending = false;
      continue;
    }

    if (item) {
      item.visionPending = true;
      item.visionPendingAt = Date.now();
    }

    describeInFlightOrder.push(path);
    if (getActiveImage()?.path === path) renderHudReadout();
    syncDescribePendingPath();

    // NOTE: do not quote paths here. `/describe` uses a raw arg string (not shlex-split),
    // so adding quotes would become part of the path and fail to resolve.
    bumpSessionApiCalls();
    invoke("write_pty", { data: `${PTY_COMMANDS.DESCRIBE} ${path}\n` }).catch(() => {
      // Backend PTY might have exited; re-spawn and continue.
      state.ptySpawned = false;
      _completeDescribeInFlight({
        path,
        description: null,
        errorMessage: "Engine disconnected. Restartingâ€¦",
      });
      ensureEngineSpawned({ reason: "vision" }).catch(() => {});
    });

    const timer = setTimeout(() => {
      if (!describeHasInFlight(path)) return;
      const img = state.images.find((it) => it?.path === path) || null;
      if (img && img.visionPending && !img.visionDesc) img.visionPending = false;
      clearDescribeInFlightPath(path);
      if (getActiveImage()?.path === path) renderHudReadout();
      processDescribeQueue();
    }, DESCRIBE_TIMEOUT_MS);
    describeInFlightTimers.set(path, timer);
  }
}

function scheduleVisionDescribe(path, { priority = false, fallback = false, refresh = false } = {}) {
  if (!path) return;
  if (!allowVisionDescribe()) return;
  if (!allowVisionDescribeInCurrentMode({ fallback })) return;

  const item = state.images.find((img) => img?.path === path) || null;
  if (!item) return;
  if (item && item.visionDesc && !refresh) return;

  if (describeHasInFlight(path)) return;
  if (describeQueued.has(path)) {
    if (refresh) describeForceRefresh.add(path);
    // If a user focuses an image, bump it to the front of the queue.
    if (priority) {
      describeQueue = [path, ...describeQueue.filter((p) => p !== path)];
      syncDescribePendingPath();
      processDescribeQueue();
    }
    return;
  }
  if (priority) describeQueue.unshift(path);
  else describeQueue.push(path);
  describeQueued.add(path);
  if (refresh) describeForceRefresh.add(path);
  syncDescribePendingPath();
  if (getActiveImage()?.path === path) renderHudReadout();
  processDescribeQueue();
}

function scheduleVisionDescribeBurst(paths, { priority = true, maxConcurrent = UPLOAD_DESCRIBE_PRIORITY_BURST } = {}) {
  const list = Array.isArray(paths) ? paths : [];
  if (!list.length) return;
  const burstLimit = Math.max(1, Number(maxConcurrent) || 1);
  const unique = [];
  const seen = new Set();
  for (const rawPath of list) {
    const path = String(rawPath || "").trim();
    if (!path || seen.has(path)) continue;
    seen.add(path);
    unique.push(path);
  }
  if (!unique.length) return;
  for (let i = 0; i < unique.length; i += 1) {
    scheduleVisionDescribe(unique[i], { priority: Boolean(priority) && i < burstLimit, fallback: true });
  }
}

function _completeDescribeInFlight({
  path = null,
  description = null,
  meta = null, // { source, model }
  errorMessage = null,
} = {}) {
  let inflight = typeof path === "string" ? path.trim() : "";
  if (!inflight) inflight = oldestDescribeInFlightPath() || "";
  if (!inflight) inflight = typeof state.describePendingPath === "string" ? state.describePendingPath.trim() : "";
  if (!inflight) return;
  const item = state.images.find((img) => img?.path === inflight) || null;
  const cleanedDesc = typeof description === "string" ? description.trim() : "";
  if (item) {
    if (cleanedDesc) {
      item.visionDesc = cleanedDesc;
      item.visionDescMeta = {
        source: meta?.source || null,
        model: meta?.model || null,
        at: Date.now(),
      };
    }
    item.visionPending = false;
  }
  dropDescribeQueuedPath(inflight);
  clearDescribeInFlightPath(inflight);

  if (errorMessage) {
    showToast(errorMessage, "error", 3200);
  }
  if (cleanedDesc) {
    // Persist new per-image descriptions into run artifacts.
    scheduleVisualPromptWrite();
    if (intentAmbientActive()) {
      // Treat new vision descriptions as an intent signal.
      scheduleAmbientIntentInference({ immediate: true, reason: "describe", imageIds: [item?.id] });
    }
  }
  if (getActiveImage()?.path === inflight) renderHudReadout();
  processDescribeQueue();
}

function _handlePtyLine(line) {
  const trimmed = String(line || "").trim();
  if (!trimmed) return;

  // Successful describe output from engine:
  //   Description (openai_vision, gpt-5-nano): Purple surface plastic
  if (trimmed.startsWith("Description")) {
    const parts = trimmed.split(":", 2);
    if (parts.length >= 2) {
      const metaPart = parts[0] || "";
      const descPart = parts[1] || "";
      const desc = descPart.trim();
      if (!desc) return;

      let source = null;
      let model = null;
      const openIdx = metaPart.indexOf("(");
      const closeIdx = metaPart.indexOf(")");
      if (openIdx >= 0 && closeIdx > openIdx) {
        const raw = metaPart.slice(openIdx + 1, closeIdx);
        const items = raw
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);
        if (items.length >= 1) source = items[0];
        if (items.length >= 2) model = items[1];
      }

      _completeDescribeInFlight({ description: desc, meta: { source, model } });
    }
    return;
  }

  // Common failure paths from engine when describe can't run.
  if (trimmed.startsWith("Describe unavailable")) {
    _completeDescribeInFlight({
      description: null,
      errorMessage: "Vision describe unavailable. Check OpenAI/Gemini/OpenRouter keys and network.",
    });
    return;
  }
  if (trimmed.startsWith("Describe failed")) {
    _completeDescribeInFlight({
      description: null,
      errorMessage: trimmed,
    });
  }
}

function scheduleVisionDescribeAll() {
  if (!allowVisionDescribe()) return;
  if (!allowVisionDescribeInCurrentMode()) return;
  const active = getActiveImage();
  if (active?.path) scheduleVisionDescribe(active.path, { priority: true, fallback: true });
  for (const item of state.images) {
    if (!item?.path) continue;
    if (active?.path && item.path === active.path) continue;
    scheduleVisionDescribe(item.path, { fallback: true });
  }
}

const ALWAYS_ON_VISION_DEBOUNCE_MS = 260;
const ALWAYS_ON_VISION_THROTTLE_MS = 4000;
const ALWAYS_ON_VISION_IDLE_MS = 1200;
const ALWAYS_ON_VISION_URGENT_IDLE_MS = 180;
const ALWAYS_ON_VISION_URGENT_THROTTLE_MS = 700;
const ALWAYS_ON_VISION_TIMEOUT_MS = 45000;
const ALWAYS_ON_VISION_URGENT_DIRTY_REASONS = new Set(["aov_enable", "image_replace"]);

let alwaysOnVisionTimer = null;
let alwaysOnVisionTimeout = null;

let intentInferenceTimer = null;
let intentInferenceTimeout = null;
let intentTicker = null;
let intentStateWriteTimer = null;
let intentAmbientInferenceTimer = null;
let intentAmbientInferenceTimeout = null;

function extractCanvasContextSummary(text) {
  const raw = String(text || "").trim();
  if (!raw) return "";
  const lines = raw.split(/\r?\n/).map((line) => String(line || "").trim());
  const headerRe = /^(CANVAS|SUBJECTS|STYLE|NEXT ACTIONS)\s*:/i;
  let idx = lines.findIndex((line) => /^CANVAS\s*:/i.test(line));
  if (idx >= 0) {
    const line = lines[idx] || "";
    const inline = line.replace(/^CANVAS\s*:\s*/i, "").trim();
    if (inline) return inline;
    for (let j = idx + 1; j < lines.length; j += 1) {
      const next = lines[j] || "";
      if (!next) continue;
      if (headerRe.test(next)) break;
      return next;
    }
  }
  // Fallback: first non-header, non-empty line.
  for (const line of lines) {
    if (!line) continue;
    if (headerRe.test(line)) continue;
    return line;
  }
  return "";
}

function extractCanvasContextTopAction(text) {
  const raw = String(text || "").trim();
  if (!raw) return null;
  const lines = raw.split(/\r?\n/);
  let nextIdx = -1;
  for (let i = 0; i < lines.length; i += 1) {
    const line = String(lines[i] || "").trim();
    if (/^NEXT ACTIONS\s*:/i.test(line)) {
      nextIdx = i;
      break;
    }
  }
  if (nextIdx < 0) return null;

  const extractListItemRest = (lineRaw) => {
    const line = String(lineRaw || "").trim();
    if (!line) return null;
    // Bullets: "- Foo", "* Foo", "â€¢ Foo"
    let match = line.match(/^(?:[-*â€¢])\s+(.*)$/);
    if (match) return String(match[1] || "").trim() || null;
    // Numbered: "1. Foo", "2) Foo"
    match = line.match(/^\d+\s*[\.\)]\s+(.*)$/);
    if (match) return String(match[1] || "").trim() || null;
    // Numbered: "1: Foo"
    match = line.match(/^\d+\s*:\s+(.*)$/);
    if (match) return String(match[1] || "").trim() || null;
    // Numbered: "1 - Foo" / "1 â€” Foo"
    match = line.match(/^\d+\s*[-â€”â€“]\s+(.*)$/);
    if (match) return String(match[1] || "").trim() || null;
    return null;
  };

  const parseActionLine = (restRaw) => {
    const rest = String(restRaw || "").trim();
    if (!rest) return null;

    // Prefer matching exact action names (including ones with colons like "Background: White").
    try {
      const allowed = Array.isArray(CANVAS_CONTEXT_ALLOWED_ACTIONS) ? CANVAS_CONTEXT_ALLOWED_ACTIONS : [];
      const sorted = allowed
        .map((s) => String(s || ""))
        .filter(Boolean)
        .sort((a, b) => b.length - a.length);
      const lower = rest.toLowerCase();
      for (const candidate of sorted) {
        const candLower = candidate.toLowerCase();
        if (!lower.startsWith(candLower)) continue;
        const boundary = rest.slice(candidate.length, candidate.length + 1);
        // Reject partial-word matches (ex: "Bridgework" shouldn't match "Bridge").
        if (boundary && /[a-z0-9]/i.test(boundary)) continue;

        let remainder = rest.slice(candidate.length).trim();
        remainder = remainder.replace(/^[\s:â€”â€“-]+/, "").trim();
        return { action: candidate, why: remainder || null };
      }
    } catch (_) {
      // ignore
    }

    // Fallback: treat "Action: why" as a hint, but don't over-parse (actions can contain colons).
    const parts = rest.split(":", 2);
    const action = String(parts[0] || "").trim();
    const why = parts.length >= 2 ? String(parts[1] || "").trim() : "";
    if (!action) return null;
    return { action, why: why || null };
  };

  for (let i = nextIdx + 1; i < lines.length; i += 1) {
    const rest = extractListItemRest(lines[i]);
    if (!rest) continue;
    const parsed = parseActionLine(rest);
    if (!parsed?.action) continue;
    return parsed;
  }
  return null;
}

function updateAlwaysOnVisionReadout() {
  const aov = state.alwaysOnVision;
  const meta = aov?.lastMeta || null;

  const title =
    meta && (meta.source || meta.model)
      ? [meta.source, meta.model].filter(Boolean).join(" Â· ")
      : "";

  const hasOutput = typeof aov?.lastText === "string" && aov.lastText.trim();
  let text = "";

  if (!ALWAYS_ON_CANVAS_CONTEXT_ENABLED) {
    text = "Disabled";
  } else if (!aov?.enabled) {
    if (aov?.disabledReason) {
      const cleaned = String(aov.disabledReason || "").trim();
      text = cleaned.length > 1400 ? `${cleaned.slice(0, 1399).trimEnd()}\nâ€¦` : cleaned;
    } else {
      text = "Off";
    }
  } else if (aov.rtState === "connecting" && !aov.pending && !hasOutput) {
    text = "Connectingâ€¦";
  } else if (aov.pending) {
    text = "ANALYZINGâ€¦";
  } else if (hasOutput) {
    const cleaned = aov.lastText.trim();
    text = cleaned.length > 1400 ? `${cleaned.slice(0, 1399).trimEnd()}\nâ€¦` : cleaned;
  } else {
    text = getVisibleCanvasImages().length ? "On (waitingâ€¦)" : "On (no images loaded)";
  }

  if (els.alwaysOnVisionReadout) {
    els.alwaysOnVisionReadout.title = title;
    els.alwaysOnVisionReadout.textContent = text;
  }

  renderMotherReadout();
}

function normalizeRealtimeProviderName(raw) {
  const value = String(raw || "").trim().toLowerCase();
  if (value === "openai" || value === "openai_realtime") return "openai_realtime";
  if (value === "gemini" || value === "gemini_flash") return "gemini_flash";
  return "";
}

function realtimeProviderForScope(scope = "intent") {
  const status = state.keyStatus;
  if (!status || typeof status !== "object") return "";
  const key =
    scope === "canvas_context"
      ? "realtime_provider_canvas_context"
      : scope === "mother_intent"
      ? "realtime_provider_mother_intent"
      : "realtime_provider_intent";
  const scoped = normalizeRealtimeProviderName(status[key]);
  if (scoped) return scoped;
  const fallback = normalizeRealtimeProviderName(status.realtime_provider_default);
  if (fallback) return fallback;
  if (status.openai) return "openai_realtime";
  if (status.openrouter || status.gemini) return "gemini_flash";
  return "openai_realtime";
}

function realtimeScopeReady(scope = "intent") {
  const status = state.keyStatus;
  if (!status || typeof status !== "object") return false;
  const key =
    scope === "canvas_context"
      ? "realtime_ready_canvas_context"
      : scope === "mother_intent"
      ? "realtime_ready_mother_intent"
      : "realtime_ready_intent";
  if (typeof status[key] === "boolean") return status[key];
  const provider = realtimeProviderForScope(scope);
  if (provider === "openai_realtime") return Boolean(status.openai);
  if (provider === "gemini_flash") return Boolean(status.gemini || status.openrouter);
  return Boolean(status.openai || status.gemini || status.openrouter);
}

function realtimeSourceSupported(source) {
  const normalized = String(source || "").trim().toLowerCase();
  return normalized === "openai_realtime" || normalized === "gemini_flash";
}

function isOpenAiProvider(provider) {
  return String(provider || "").trim().toLowerCase() === "openai";
}

function isOpenAiRealtimeSignal({ source = null, model = null } = {}) {
  const sourceRaw = String(source || "").trim().toLowerCase();
  if (sourceRaw === "openai_realtime" || sourceRaw.startsWith("openai_realtime_")) return true;
  const modelRaw = String(model || "").trim().toLowerCase();
  return modelRaw.startsWith("gpt-realtime");
}

function realtimeScopeUnavailableMessage(scope = "intent") {
  const status = state.keyStatus;
  if (!status || typeof status !== "object") {
    return "Realtime key status still loading. Wait a moment and retry.";
  }
  const provider = realtimeProviderForScope(scope);
  if (provider === "gemini_flash") {
    if (status && !status.gemini && !status.openrouter) {
      return "Realtime provider gemini_flash requires GEMINI_API_KEY (or GOOGLE_API_KEY) or OPENROUTER_API_KEY.";
    }
    return "Intent realtime disabled.";
  }
  if (provider === "openai_realtime") {
    if (status && !status.openai) {
      if (status.openrouter) {
        return "Realtime provider openai_realtime requires OPENAI_API_KEY. OpenRouter websocket realtime is unsupported; use gemini_flash (OPENROUTER_API_KEY or GEMINI_API_KEY).";
      }
      return "Realtime provider openai_realtime requires OPENAI_API_KEY (or OPENAI_API_KEY_BACKUP).";
    }
    return "Intent realtime disabled.";
  }
  return "Intent realtime disabled.";
}

function realtimePortraitProviderForScope(scope = "intent") {
  const provider = realtimeProviderForScope(scope);
  if (provider === "gemini_flash") return "gemini";
  return "openai";
}

function allowAlwaysOnVision() {
  if (!ALWAYS_ON_CANVAS_CONTEXT_ENABLED) return false;
  if (intentModeActive()) return false;
  if (!state.alwaysOnVision?.enabled) return false;
  if (!getVisibleCanvasImages().length) return false;
  if (!state.runDir) return false;
  // Fail closed until key status resolves, then enforce provider-specific readiness.
  if (!realtimeScopeReady("canvas_context")) return false;
  return true;
}

function intentModeActive() {
  if (!INTENT_CANVAS_ENABLED) return false;
  return Boolean(state.intent && !state.intent.locked);
}

function intentAmbientActive() {
  if (!INTENT_AMBIENT_ENABLED) return false;
  const ambient = state.intentAmbient;
  if (!ambient || !ambient.enabled) return false;
  return true;
}

function normalizeIntentReason(reason) {
  return String(reason || "")
    .trim()
    .toLowerCase();
}

function isIntentFastTrackReason(reason) {
  const normalized = normalizeIntentReason(reason);
  return normalized === "add" || normalized === "import" || normalized === "replace";
}

function intentSnapshotLoadTimeoutForReason(reason) {
  return isIntentFastTrackReason(reason) ? INTENT_SNAPSHOT_FAST_LOAD_TIMEOUT_MS : INTENT_SNAPSHOT_LOAD_TIMEOUT_MS;
}

function rememberAmbientTouchedImageIds(ids = []) {
  const ambient = state.intentAmbient;
  if (!ambient) return;
  const ordered = [];
  for (const raw of Array.isArray(ids) ? ids : []) {
    const id = String(raw || "").trim();
    if (!id) continue;
    if (!state.imagesById.has(id)) continue;
    if (!ordered.includes(id)) ordered.push(id);
  }
  if (!ordered.length) return;
  const prev = Array.isArray(ambient.touchedImageIds) ? ambient.touchedImageIds : [];
  const merged = [...ordered];
  for (const id of prev) {
    if (!id || merged.includes(id)) continue;
    merged.push(id);
  }
  ambient.touchedImageIds = merged.slice(0, 8);
}

function syncIntentModeClass() {
  if (!els.canvasWrap) return;
  els.canvasWrap.classList.toggle("intent-mode", intentModeActive());
  syncIntentRealtimeClass();
}

function intentRealtimePulseActive() {
  const intent = state.intent;
  if (!intent || !intentModeActive()) return false;
  // "Actively sending/receiving" for Intent Canvas: request in flight or session connecting.
  return Boolean(intent.pending || intent.rtState === "connecting");
}

function intentAmbientRealtimePulseActive() {
  if (!INTENT_AMBIENT_ICON_PLACEMENT_ENABLED) return false;
  const ambient = state.intentAmbient;
  if (!ambient || !intentAmbientActive()) return false;
  return Boolean(ambient.pending || ambient.rtState === "connecting");
}

function syncOpenAiRealtimePortraitBusyClasses() {
  const primaryBusy = Boolean(
    state.portrait?.busy || (openaiRealtimePortraitBoostActive && isOpenAiProvider(state.portrait?.provider))
  );
  const secondaryBusy = Boolean(
    state.portrait2?.busy || (openaiRealtimePortraitBoostActive && isOpenAiProvider(state.portrait2?.provider))
  );
  if (els.agentSlotPrimary) els.agentSlotPrimary.classList.toggle("busy", primaryBusy);
  if (els.agentSlotSecondary) els.agentSlotSecondary.classList.toggle("busy", secondaryBusy);
}

function setOpenAiRealtimePortraitBoost(active) {
  const next = Boolean(active);
  if (openaiRealtimePortraitBoostActive === next) return;
  openaiRealtimePortraitBoostActive = next;
  syncOpenAiRealtimePortraitBusyClasses();
  refreshAgentPortraitVideos().catch(() => {});
}

function scheduleOpenAiRealtimePortraitCooldownCheck() {
  if (openaiRealtimePortraitCooldownTimer) {
    clearTimeout(openaiRealtimePortraitCooldownTimer);
    openaiRealtimePortraitCooldownTimer = null;
  }
  if (openaiRealtimePortraitHotUntil <= 0) {
    setOpenAiRealtimePortraitBoost(false);
    return;
  }
  const msLeft = Math.max(0, openaiRealtimePortraitHotUntil - Date.now());
  if (msLeft <= 0) {
    openaiRealtimePortraitHotUntil = 0;
    setOpenAiRealtimePortraitBoost(false);
    return;
  }
  openaiRealtimePortraitCooldownTimer = setTimeout(() => {
    openaiRealtimePortraitCooldownTimer = null;
    if (Date.now() >= openaiRealtimePortraitHotUntil) {
      openaiRealtimePortraitHotUntil = 0;
      setOpenAiRealtimePortraitBoost(false);
      return;
    }
    scheduleOpenAiRealtimePortraitCooldownCheck();
  }, msLeft + 30);
}

function markOpenAiRealtimePortraitActivity({ extendMs = OPENAI_REALTIME_PORTRAIT_COOLDOWN_MS } = {}) {
  const extend = Math.max(250, Number(extendMs) || OPENAI_REALTIME_PORTRAIT_COOLDOWN_MS);
  const nextUntil = Date.now() + extend;
  if (nextUntil > openaiRealtimePortraitHotUntil) {
    openaiRealtimePortraitHotUntil = nextUntil;
  }
  setOpenAiRealtimePortraitBoost(true);
  scheduleOpenAiRealtimePortraitCooldownCheck();
}

function syncIntentRealtimePortrait() {
  // Keep portrait provider aligned with the active realtime provider.
  // Keep this scoped to intent mode so we don't fight foreground action portraits elsewhere.
  const intent = state.intent;
  const active = Boolean(intent && intentModeActive() && (intent.pending || intent.rtState === "connecting"));
  const intentRtProvider = realtimePortraitProviderForScope("intent");
  if (
    active &&
    isOpenAiProvider(intentRtProvider) &&
    Date.now() + 900 >= openaiRealtimePortraitHotUntil
  ) {
    markOpenAiRealtimePortraitActivity();
  }
  if (active) {
    if (
      !intentRealtimePortraitBusy ||
      !state.portrait?.busy ||
      String(state.portrait?.provider || "").toLowerCase() !== String(intentRtProvider)
    ) {
      intentRealtimePortraitBusy = true;
      portraitWorking("Intent Realtime", {
        providerOverride: intentRtProvider,
        forceProvider: true,
        clearDirector: false,
      });
    }
    return;
  }
  if (intentRealtimePortraitBusy) {
    intentRealtimePortraitBusy = false;
    updatePortraitIdle();
  }
}

function syncIntentRealtimeClass() {
  if (!els.canvasWrap) return;
  els.canvasWrap.classList.toggle("intent-rt-active", intentRealtimePulseActive());
  const ambientPulse = INTENT_AMBIENT_ICON_PLACEMENT_ENABLED && intentAmbientRealtimePulseActive();
  els.canvasWrap.classList.toggle("intent-ambient-rt-active", ambientPulse);
  syncIntentRealtimePortrait();
}

function updateEmptyCanvasHint() {
  // Hint is a keyboard-accessible fallback for click-to-upload when no images exist.
  showDropHint((state.images?.length || 0) === 0);
}

function ensureIntentTicker() {
  if (intentTicker) return;
  if (!intentModeActive()) return;
  if (!INTENT_TIMER_ENABLED) return;
  // Only tick once the countdown is actually running.
  if (!state.intent?.startedAt) return;
  intentTicker = setInterval(() => {
    if (!intentModeActive()) {
      stopIntentTicker();
      return;
    }
    updateIntentCountdown();
    requestRender();
  }, 200);
}

function stopIntentTicker() {
  clearInterval(intentTicker);
  intentTicker = null;
}

function intentRemainingMs(nowMs = Date.now()) {
  const intent = state.intent;
  if (!intent) return INTENT_DEADLINE_MS;
  if (!intent.startedAt || !intent.deadlineAt) return INTENT_DEADLINE_MS;
  return Math.max(0, (Number(intent.deadlineAt) || 0) - (Number(nowMs) || 0));
}

function updateIntentCountdown(nowMs = Date.now()) {
  const intent = state.intent;
  if (!intentModeActive() || !intent) return;
  if (!INTENT_TIMER_ENABLED) return;
  if (!intent.startedAt || !intent.deadlineAt) return;
  const remaining = intentRemainingMs(nowMs);
  if (remaining > 0) return;
  if (intent.forceChoice) return;
  if (!INTENT_FORCE_CHOICE_ENABLED) return;
  intent.forceChoice = true;
  // If the model hasn't produced branches yet, fall back to a minimal local default so we can force a choice.
  ensureIntentFallbackIconState("timeout");
  if (!intent.focusBranchId) {
    intent.focusBranchId = pickDefaultIntentFocusBranchId();
  }
  scheduleIntentStateWrite({ immediate: true });
}

function scheduleIntentStateWrite({ immediate = false } = {}) {
  if (!state.runDir) return;
  const delay = immediate ? 0 : 320;
  clearTimeout(intentStateWriteTimer);
  intentStateWriteTimer = setTimeout(() => {
    intentStateWriteTimer = null;
    writeIntentState().catch((err) => {
      console.warn("Failed to write intent state:", err);
    });
  }, delay);
}

function buildIntentPersistedState() {
  const intent = state.intent || {};
  return {
    schema: "brood.intent_state",
    schema_version: 1,
    generated_at: new Date().toISOString(),
    locked: Boolean(intent.locked),
    locked_at_ms: Number(intent.lockedAt) || 0,
    locked_branch_id: intent.lockedBranchId ? String(intent.lockedBranchId) : null,
    started_at_ms: Number(intent.startedAt) || 0,
    deadline_at_ms: INTENT_TIMER_ENABLED ? Number(intent.deadlineAt) || 0 : 0,
    round: Math.max(1, Number(intent.round) || 1),
    total_rounds: INTENT_ROUNDS_ENABLED ? Math.max(1, Number(intent.totalRounds) || 3) : 0,
    selections: Array.isArray(intent.selections) ? intent.selections : [],
    focus_branch_id: intent.focusBranchId ? String(intent.focusBranchId) : null,
    icon_state: intent.iconState || null,
    icon_state_at_ms: Number(intent.iconStateAt) || 0,
    force_choice: INTENT_FORCE_CHOICE_ENABLED ? Boolean(intent.forceChoice) : false,
    rt_state: intent.rtState ? String(intent.rtState) : "off",
    disabled_reason: intent.disabledReason ? String(intent.disabledReason) : null,
    last_error: intent.lastError ? String(intent.lastError) : null,
    last_error_at_ms: Number(intent.lastErrorAt) || 0,
  };
}

async function writeIntentState() {
  if (!state.runDir) return false;
  const outPath = `${state.runDir}/${INTENT_PERSIST_FILENAME}`;
  const payload = buildIntentPersistedState();
  await writeTextFile(outPath, JSON.stringify(payload, null, 2));
  return true;
}

async function restoreIntentStateFromRunDir() {
  if (!state.runDir) return false;
  const lockedPath = `${state.runDir}/${INTENT_LOCKED_FILENAME}`;
  const statePath = `${state.runDir}/${INTENT_PERSIST_FILENAME}`;

  const loadJson = async (path) => {
    try {
      if (!(await exists(path))) return null;
      return JSON.parse(await readTextFile(path));
    } catch {
      return null;
    }
  };

  const locked = await loadJson(lockedPath);
  if (locked && typeof locked === "object") {
    state.intent.locked = true;
    state.intent.lockedAt = Number(locked.locked_at_ms) || 0;
    state.intent.lockedBranchId = locked.locked_branch_id ? String(locked.locked_branch_id) : null;
    state.intent.startedAt = Number(locked.started_at_ms) || 0;
    state.intent.deadlineAt = Number(locked.deadline_at_ms) || 0;
    state.intent.round = Math.max(1, Number(locked.round) || 1);
    state.intent.selections = Array.isArray(locked.selections) ? locked.selections : [];
    state.intent.focusBranchId = locked.focus_branch_id ? String(locked.focus_branch_id) : null;
    state.intent.iconState = locked.icon_state && typeof locked.icon_state === "object" ? locked.icon_state : null;
    state.intent.iconStateAt = Number(locked.icon_state_at_ms) || 0;
    state.intent.forceChoice = false;
    state.intent.pending = false;
    state.intent.pendingPath = null;
    state.intent.pendingAt = 0;
    state.intent.pendingFrameId = null;
    state.intent.rtState = "off";
    state.intent.disabledReason = null;
    state.intent.lastError = null;
    state.intent.lastErrorAt = 0;
    syncIntentModeClass();
    stopIntentTicker();
    renderQuickActions();
    requestRender();
    return true;
  }

  const persisted = await loadJson(statePath);
  if (persisted && typeof persisted === "object") {
    state.intent.locked = Boolean(persisted.locked);
    state.intent.lockedAt = Number(persisted.locked_at_ms) || 0;
    state.intent.lockedBranchId = persisted.locked_branch_id ? String(persisted.locked_branch_id) : null;
    state.intent.startedAt = Number(persisted.started_at_ms) || 0;
    state.intent.deadlineAt = Number(persisted.deadline_at_ms) || 0;
    state.intent.round = Math.max(1, Number(persisted.round) || 1);
    state.intent.totalRounds = Math.max(1, Number(persisted.total_rounds) || state.intent.totalRounds || 3);
    state.intent.selections = Array.isArray(persisted.selections) ? persisted.selections : [];
    state.intent.focusBranchId = persisted.focus_branch_id ? String(persisted.focus_branch_id) : null;
    state.intent.iconState = persisted.icon_state && typeof persisted.icon_state === "object" ? persisted.icon_state : null;
    state.intent.iconStateAt = Number(persisted.icon_state_at_ms) || 0;
    state.intent.forceChoice = Boolean(persisted.force_choice);
    state.intent.pending = false;
    state.intent.pendingPath = null;
    state.intent.pendingAt = 0;
    state.intent.pendingFrameId = null;
    state.intent.rtState = "off";
    state.intent.disabledReason = persisted.disabled_reason ? String(persisted.disabled_reason) : null;
    state.intent.lastError = persisted.last_error ? String(persisted.last_error) : null;
    state.intent.lastErrorAt = Number(persisted.last_error_at_ms) || 0;
    if (!INTENT_FORCE_CHOICE_ENABLED) {
      state.intent.forceChoice = false;
    } else if (INTENT_ROUNDS_ENABLED) {
      const total = Math.max(1, Number(state.intent.totalRounds) || 3);
      if (!state.intent.locked && state.intent.iconState && state.intent.round >= total) {
        state.intent.forceChoice = true;
      }
    }
    syncIntentModeClass();
    if (intentModeActive()) ensureIntentTicker();
    renderQuickActions();
    requestRender();
    return true;
  }
  return false;
}

const CANVAS_CONTEXT_ENVELOPE_VERSION = 2;
const CANVAS_CONTEXT_ALLOWED_ACTIONS = [
  "Create Layers",
  "Prompt Generate",
  "Combine",
  "Bridge",
  "Swap DNA",
  "Extract the Rule",
  "Odd One Out",
  "Triforce",
  "Recast",
  "Variations",
  "Background: White",
  "Background: Sweep",
  "Crop: Square",
  "Annotate",
];

const AUTO_ACCEPT_SUGGESTED_MAX_PASSES = 3;

const CANVAS_CONTEXT_ACTION_GLOSSARY = [
  {
    action: "Create Layers",
    what: "Generate semantic layer artifacts for background, main subject, and detachable props.",
    requires: "Exactly 1 active/selected image.",
  },
  {
    action: "Prompt Generate",
    what: "Generate a brand-new image from a custom text prompt and selected model.",
    requires: "No source image required.",
  },
  {
    action: "Combine",
    what: "Blend the two loaded photos into one output image.",
    requires: "Exactly 2 photos loaded (multi-image action).",
  },
  {
    action: "Bridge",
    what: "Generate the aesthetic midpoint between two images (not a collage).",
    requires: "Exactly 2 photos loaded (multi-image action).",
  },
  {
    action: "Swap DNA",
    what: "Use structure from one image and surface qualities from the other.",
    requires: "Exactly 2 photos loaded (multi-image action).",
  },
  {
    action: "Extract the Rule",
    what: "Extract the shared invisible rule/pattern across three images.",
    requires: "Exactly 3 photos loaded (multi-image action).",
  },
  {
    action: "Odd One Out",
    what: "Identify which of three images breaks the shared pattern, and explain why.",
    requires: "Exactly 3 photos loaded (multi-image action).",
  },
  {
    action: "Triforce",
    what: "Generate the centroid: one image equidistant from all three references.",
    requires: "Exactly 3 photos loaded (multi-image action).",
  },
  {
    action: "Recast",
    what: "Reimagine the image in a different medium/context.",
    requires: "An active image.",
  },
  {
    action: "Variations",
    what: "Generate zero-prompt variations of the active image.",
    requires: "An active image.",
  },
  {
    action: "Background: White",
    what: "Replace background with clean studio white (optionally uses lasso selection).",
    requires: "An active image.",
  },
  {
    action: "Background: Sweep",
    what: "Replace background with a soft sweep gradient (optionally uses lasso selection).",
    requires: "An active image.",
  },
  {
    action: "Crop: Square",
    what: "Crop the active image to a centered square.",
    requires: "An active image that is not already square.",
  },
  {
    action: "Annotate",
    what: "Select the Annotate tool so the user can draw a box and type an instruction.",
    requires: "An active image.",
  },
];

function _canvasContextSidecarPath(snapshotPath) {
  const raw = String(snapshotPath || "").trim();
  if (!raw) return null;
  const dot = raw.lastIndexOf(".");
  if (dot <= 0) return `${raw}.ctx.json`;
  return `${raw.slice(0, dot)}.ctx.json`;
}

function _stableQuickActionLabel(label) {
  return String(label || "")
    .replace(/\s*\(running\.\.\.\)\s*$/i, "")
    .replace(/\s*\(runningâ€¦\)\s*$/i, "")
    .trim();
}

function buildCanvasContextEnvelope() {
  const activeId = getVisibleActiveId();
  const active = activeId ? state.imagesById.get(activeId) || null : null;
  const wrap = els.canvasWrap;
  const dpr = getDpr();
  const canvasCssW = wrap?.clientWidth || 0;
  const canvasCssH = wrap?.clientHeight || 0;

  ensureFreeformLayoutRectsCss(state.images || [], canvasCssW, canvasCssH);

  const selectedIds = getVisibleSelectedIds();
  const selectedSet = new Set(selectedIds);
  const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder : [];
  const images = [];
  for (let idx = 0; idx < z.length; idx += 1) {
    const imageId = String(z[idx] || "").trim();
    if (!imageId) continue;
    if (!isVisibleCanvasImageId(imageId)) continue;
    const item = state.imagesById.get(imageId) || null;
    const rect = state.freeformRects.get(imageId) || null;
    if (!item?.path || !rect) continue;
    const x = Number(rect.x) || 0;
    const y = Number(rect.y) || 0;
    const w = Math.max(1, Number(rect.w) || 1);
    const h = Math.max(1, Number(rect.h) || 1);
    const cx = x + w / 2;
    const cy = y + h / 2;
    images.push({
      id: String(imageId),
      file: basename(item.path),
      z: idx,
      is_active: Boolean(activeId && String(activeId) === String(imageId)),
      is_selected: selectedSet.has(String(imageId)),
      rect_css: { x, y, w, h, cx, cy },
      rect_norm: {
        x: canvasCssW ? x / canvasCssW : 0,
        y: canvasCssH ? y / canvasCssH : 0,
        w: canvasCssW ? w / canvasCssW : 0,
        h: canvasCssH ? h / canvasCssH : 0,
        cx: canvasCssW ? cx / canvasCssW : 0,
        cy: canvasCssH ? cy / canvasCssH : 0,
      },
    });
  }

  const quickActions = (computeQuickActions() || [])
    .filter((action) => action && action.id && action.label)
    .map((action) => ({
      id: String(action.id),
      label: _stableQuickActionLabel(action.label),
      enabled: !action.disabled,
      title: action.title ? String(action.title) : null,
    }));

  const allowedAbilities = CANVAS_CONTEXT_ALLOWED_ACTIONS;
  const glossary = CANVAS_CONTEXT_ACTION_GLOSSARY;

  const nodes = Array.from(state.timelineNodes || []).sort((a, b) => (a?.createdAt || 0) - (b?.createdAt || 0));
  const timelineRecent = nodes.slice(-12).map((node) => ({
    at: node?.createdAt ? new Date(node.createdAt).toISOString() : null,
    action: node?.action ? String(node.action) : null,
    file: basename(node?.path),
    label: node?.label ? String(node.label) : null,
  }));

  const recentEventSource =
    Array.isArray(state.userTelemetryEvents) && state.userTelemetryEvents.length
      ? state.userTelemetryEvents
      : Array.isArray(state.userEvents)
      ? state.userEvents
      : [];
  const eventsRecent = recentEventSource
    .slice(-32)
    .map((ev) => {
      const out = {
        at_ms: Number(ev?.at_ms) || null,
        type: ev?.type ? String(ev.type) : null,
      };
      for (const key of ["tool", "key", "kind", "image_id", "corner", "canvas_mode", "active_id", "selected_ids", "file"]) {
        if (ev && Object.prototype.hasOwnProperty.call(ev, key)) {
          out[key] = ev[key];
        }
      }
      // Best-effort deltas (used by move/resize) but keep it compact.
      if (ev?.start && ev?.end) {
        out.start = ev.start;
        out.end = ev.end;
      }
      return out;
    })
    .filter((ev) => ev && ev.type);

  const visibleImageCount = getVisibleCanvasImages().length;

  return {
    schema_version: CANVAS_CONTEXT_ENVELOPE_VERSION,
    generated_at: new Date().toISOString(),
    canvas: {
      width_css: canvasCssW,
      height_css: canvasCssH,
      width_px: Math.max(0, Math.round(canvasCssW * dpr)),
      height_px: Math.max(0, Math.round(canvasCssH * dpr)),
      dpr,
    },
    canvas_mode: state.canvasMode,
    tool: state.tool,
    n_images: visibleImageCount,
    active_image: active?.path ? basename(active.path) : null,
    selection: {
      active_id: activeId ? String(activeId) : null,
      selected_ids: selectedIds.slice(0, 3),
    },
    images: images.slice(0, 12),
    allowed_abilities: allowedAbilities,
    abilities: quickActions,
    ability_glossary: glossary,
    timeline_recent: timelineRecent,
    events_recent: eventsRecent,
  };
}

async function writeCanvasContextEnvelope(snapshotPath) {
  if (!state.runDir) return null;
  const ctxPath = _canvasContextSidecarPath(snapshotPath);
  if (!ctxPath) return null;
  const envelope = buildCanvasContextEnvelope();
  const payload = JSON.stringify(envelope);
  await writeTextFile(ctxPath, payload);
  return ctxPath;
}

function normalizeSuggestedActionName(name) {
  return String(name || "")
    .trim()
    .replace(/\.+\s*$/g, "")
    .trim();
}

function canvasContextAllowedActions() {
  // Always-on realtime canvas context acts as a continual Diagnose; avoid exposing it as a suggestion.
  if (state.alwaysOnVision?.enabled) {
    return CANVAS_CONTEXT_ALLOWED_ACTIONS.filter((name) => name !== "Diagnose");
  }
  return CANVAS_CONTEXT_ALLOWED_ACTIONS;
}

function isCanvasContextAllowedAction(actionName) {
  const cleaned = normalizeSuggestedActionName(actionName).toLowerCase();
  if (!cleaned) return false;
  return canvasContextAllowedActions().some((cand) => String(cand || "").toLowerCase() === cleaned);
}

function canonicalizeCanvasContextAction(actionName, whyHint = null) {
  let cleaned = normalizeSuggestedActionName(actionName);
  if (!cleaned) return "";
  cleaned = cleaned.replace(/\s*:\s*/g, ": ").trim();

  const why = typeof whyHint === "string" ? whyHint.trim() : "";
  const lower = cleaned.toLowerCase();
  const whyLower = why.toLowerCase();

  // Common truncations: our action names include colons ("Background: White", "Crop: Square"),
  // but the realtime text often uses "Action: Variant: ..." which can get parsed as "Background".
  if (lower === "background" || lower === "background replace" || lower === "bg") {
    if (whyLower.includes("sweep") || whyLower.includes("gradient")) return "Background: Sweep";
    return "Background: White";
  }
  if (lower === "studio white") return "Background: White";
  if (lower === "studio sweep") return "Background: Sweep";

  if (lower === "crop" || lower === "crop square" || lower === "square crop") return "Crop: Square";

  const compact = lower.replace(/\s+/g, " ").trim();
  if (compact === "create layers" || compact === "layers" || compact === "split layers") return "Create Layers";
  if (compact === "prompt generate" || compact === "prompt" || compact === "text to image") return "Prompt Generate";
  if (compact === "extract rule" || compact === "extract the rule") return "Extract the Rule";
  if (compact === "odd one out") return "Odd One Out";
  if (compact === "swap dna" || compact.replace(/\s+/g, "") === "swapdna") return "Swap DNA";

  // Preserve canonical casing when the action is in our allowlist.
  const allow = CANVAS_CONTEXT_ALLOWED_ACTIONS.find((cand) => String(cand || "").toLowerCase() === lower);
  if (allow) return allow;

  return cleaned;
}

function _hideCanvasContextSuggestion(wrap, btn) {
  wrap.classList.remove("is-visible");
  wrap.setAttribute("aria-hidden", "true");
  btn.textContent = "";
  btn.disabled = true;
  btn.classList.remove("is-unavailable");
  btn.title = "";
}

function _canvasContextDisabledReason(action) {
  const nSelected = selectedCount();
  if (["Combine", "Bridge", "Swap DNA", "Argue"].includes(action)) {
    if (nSelected !== 2) return `Requires exactly 2 selected images (you have ${nSelected}).`;
    return "";
  }
  if (["Extract the Rule", "Odd One Out", "Triforce"].includes(action)) {
    if (nSelected !== 3) return `Requires exactly 3 selected images (you have ${nSelected}).`;
    return "";
  }
  if (action === "Create Layers") {
    if (nSelected !== 1) return `Requires exactly 1 selected image (you have ${nSelected}).`;
    return "";
  }
  if (action === "Prompt Generate") {
    return "";
  }
  if (!getActiveImage()) return "No active image.";
  if (action === "Crop: Square") {
    const active = getActiveImage();
    const iw = active?.img?.naturalWidth || active?.width || null;
    const ih = active?.img?.naturalHeight || active?.height || null;
    if (iw && ih && Math.abs(iw - ih) <= 8) return "Already square.";
  }
  return "";
}

function disableAutoAcceptSuggestedAbility(message = "") {
  settings.autoAcceptSuggestedAbility = false;
  localStorage.setItem("brood.autoAcceptSuggestedAbility", "0");
  if (state.autoAcceptSuggestedAbility) {
    state.autoAcceptSuggestedAbility.enabled = false;
  }
  if (els.autoAcceptSuggestedAbilityToggle) {
    els.autoAcceptSuggestedAbilityToggle.checked = false;
  }
  if (message) showToast(message, "tip", 2400);
}

function maybeAutoAcceptCanvasContextSuggestion(action, rec) {
  const auto = state.autoAcceptSuggestedAbility;
  if (!auto?.enabled) return;
  if (!rec?.at || !action) return;
  const autoAction = normalizeSuggestedActionName(action) || String(action || "").trim();
  // Prompt Generate requires manual prompt entry in a modal, so it is not safe to auto-accept.
  if (autoAction === "Prompt Generate") return;
  if (auto.inFlight) return;
  if (auto.passes >= AUTO_ACCEPT_SUGGESTED_MAX_PASSES) {
    disableAutoAcceptSuggestedAbility("Auto-accept: cap reached (3).");
    return;
  }
  if (auto.lastAcceptedAt === rec.at) return;

  auto.inFlight = true;
  auto.lastAcceptedAt = rec.at;
  auto.passes += 1;
  if (auto.passes >= AUTO_ACCEPT_SUGGESTED_MAX_PASSES) {
    // Disable after this pass to prevent runaway loops.
    disableAutoAcceptSuggestedAbility("Auto-accept: cap reached (3).");
  }

  triggerCanvasContextSuggestedAction(autoAction)
    .catch((err) => {
      const msg = err?.message || String(err);
      showToast(msg, "error", 2600);
    })
    .finally(() => {
      auto.inFlight = false;
    });
}

function renderCanvasContextSuggestion() {
  const wrap = els.canvasContextSuggest;
  const btn = els.canvasContextSuggestBtn;
  if (!wrap || !btn) return;

  const rec = state.canvasContextSuggestion;
  if (!state.alwaysOnVision?.enabled || !rec?.action) {
    _hideCanvasContextSuggestion(wrap, btn);
    return;
  }

  const action = canonicalizeCanvasContextAction(rec.action, rec.why);
  if (!action || !isCanvasContextAllowedAction(action)) {
    _hideCanvasContextSuggestion(wrap, btn);
    return;
  }

  // Only show enabled suggestions. If it's not currently usable (wrong image count, already in that mode),
  // hide it entirely so the Abilities panel stays clean.
  const disabledReason = _canvasContextDisabledReason(action);
  if (disabledReason) {
    _hideCanvasContextSuggestion(wrap, btn);
    return;
  }

  wrap.classList.add("is-visible");
  wrap.setAttribute("aria-hidden", "false");
  btn.textContent = action;
  btn.disabled = false;
  btn.classList.remove("is-unavailable");
  btn.title = String(rec.why || "").trim();

  maybeAutoAcceptCanvasContextSuggestion(action, rec);
}

async function triggerCanvasContextSuggestedAction(actionName) {
  const action = normalizeSuggestedActionName(actionName);
  if (!action) return;
  const active = getActiveImage();
  const nSelected = selectedCount();
  if (action === "Combine") {
    if (nSelected !== 2) throw new Error(`Combine requires exactly 2 selected images (you have ${nSelected}).`);
    if (state.canvasMode !== "multi") setCanvasMode("multi");
    await runBlendPair();
    return;
  }
  if (action === "Create Layers") {
    if (nSelected !== 1) throw new Error(`Create Layers requires exactly 1 selected image (you have ${nSelected}).`);
    await runCreateLayersFromSelection();
    return;
  }
  if (action === "Prompt Generate") {
    showPromptGeneratePanel();
    return;
  }
  if (action === "Bridge") {
    if (nSelected !== 2) throw new Error(`Bridge requires exactly 2 selected images (you have ${nSelected}).`);
    if (state.canvasMode !== "multi") setCanvasMode("multi");
    await runBridgePair();
    return;
  }
  if (action === "Swap DNA") {
    if (nSelected !== 2) throw new Error(`Swap DNA requires exactly 2 selected images (you have ${nSelected}).`);
    if (state.canvasMode !== "multi") setCanvasMode("multi");
    await runSwapDnaPair({ invert: false });
    return;
  }
  if (action === "Extract the Rule") {
    if (nSelected !== 3)
      throw new Error(`Extract the Rule requires exactly 3 selected images (you have ${nSelected}).`);
    if (state.canvasMode !== "multi") setCanvasMode("multi");
    await runExtractRuleTriplet();
    return;
  }
  if (action === "Odd One Out") {
    if (nSelected !== 3) throw new Error(`Odd One Out requires exactly 3 selected images (you have ${nSelected}).`);
    if (state.canvasMode !== "multi") setCanvasMode("multi");
    await runOddOneOutTriplet();
    return;
  }
  if (action === "Triforce") {
    if (nSelected !== 3) throw new Error(`Triforce requires exactly 3 selected images (you have ${nSelected}).`);
    if (state.canvasMode !== "multi") setCanvasMode("multi");
    await runTriforceTriplet();
    return;
  }
  if (action === "Recast") {
    if (!active) throw new Error("Recast requires an active image.");
    await runRecast();
    return;
  }
  if (action === "Variations") {
    if (!active) throw new Error("Variations requires an active image.");
    await runVariations();
    return;
  }
  if (action === "Background: White") {
    if (!active) throw new Error("Background replace requires an active image.");
    await applyBackground("white");
    return;
  }
  if (action === "Background: Sweep") {
    if (!active) throw new Error("Background replace requires an active image.");
    await applyBackground("sweep");
    return;
  }
  if (action === "Crop: Square") {
    if (!active) throw new Error("Crop requires an active image.");
    await cropSquare();
    return;
  }
  if (action === "Annotate") {
    if (!active) throw new Error("Annotate requires an active image.");
    setTool("annotate");
    showToast("Annotate tool selected.", "tip", 1800);
    return;
  }

  // Fallback: attempt to route to an existing skill by label.
  const match = (computeQuickActions() || []).find((qa) => {
    const label = _stableQuickActionLabel(qa?.label);
    return label && label.toLowerCase() === action.toLowerCase();
  });
  if (match && !match.disabled && typeof match.onClick === "function") {
    match.onClick();
    return;
  }
  throw new Error(`Unknown suggested action: ${action}`);
}

function requireIntentUnlocked(message = null) {
  if (!intentModeActive()) return true;
  const msg = message ? String(message) : "Lock an intent to unlock skills.";
  showToast(msg, "tip", 2200);
  return false;
}

function isForegroundActionRunning() {
  return Boolean(
    state.ptySpawning ||
      state.actionQueueActive ||
    state.pendingBlend ||
      state.pendingSwapDna ||
      state.pendingBridge ||
      state.pendingExtractDna ||
      state.pendingSoulLeech ||
      state.pendingExtractRule ||
      state.pendingOddOneOut ||
      state.pendingTriforce ||
      state.pendingRecast ||
      state.pendingCreateLayers ||
      state.pendingPromptGenerate ||
      state.expectingArtifacts ||
      state.pendingReplace
  );
}

function computeCanvasSignature() {
  const parts = [];
  for (const item of state.images) {
    const id = String(item?.id || "").trim();
    if (!id || !isVisibleCanvasImageId(id)) continue;
    parts.push(`id=${id}`);
    if (item?.path) parts.push(item.path);
  }
  // Spatial layout is a first-class signal; include freeform rects so background inference
  // reacts to user arrangement but ignore pure camera/view changes (pan/zoom/selection).
  const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder : [];
  for (const imageIdRaw of z) {
    const imageId = String(imageIdRaw || "").trim();
    if (!imageId || !isVisibleCanvasImageId(imageId)) continue;
    const rect = imageId ? state.freeformRects.get(imageId) : null;
    if (!rect) continue;
    parts.push(
      `rect:${imageId}:${Math.round(Number(rect.x) || 0)},${Math.round(Number(rect.y) || 0)},${Math.round(
        Number(rect.w) || 0
      )},${Math.round(Number(rect.h) || 0)}`
    );
  }
  return parts.join("|");
}

function markAlwaysOnVisionDirty(reason = null) {
  const aov = state.alwaysOnVision;
  if (!aov) return;
  aov.contentDirty = true;
  aov.dirtyReason = reason ? String(reason) : null;
}

function isAlwaysOnVisionUrgentDirtyReason(reason = null) {
  const key = String(reason || "")
    .trim()
    .toLowerCase();
  if (!key) return false;
  return ALWAYS_ON_VISION_URGENT_DIRTY_REASONS.has(key);
}

function scheduleAlwaysOnVision({ immediate = false, force = false } = {}) {
  if (!allowAlwaysOnVision()) {
    updateAlwaysOnVisionReadout();
    return;
  }
  clearTimeout(alwaysOnVisionTimer);
  const forced = Boolean(force);
  const urgent = isAlwaysOnVisionUrgentDirtyReason(state.alwaysOnVision?.dirtyReason);
  const delay = immediate ? 0 : urgent ? Math.min(ALWAYS_ON_VISION_DEBOUNCE_MS, 90) : ALWAYS_ON_VISION_DEBOUNCE_MS;
  alwaysOnVisionTimer = setTimeout(() => {
    alwaysOnVisionTimer = null;
    if (!immediate && !urgent && "requestIdleCallback" in window) {
      window.requestIdleCallback(
        () => {
          runAlwaysOnVisionOnce({ force: forced }).catch((err) => console.warn("Always-on vision failed:", err));
        },
        { timeout: 1200 }
      );
    } else {
      runAlwaysOnVisionOnce({ force: forced }).catch((err) => console.warn("Always-on vision failed:", err));
    }
  }, delay);
}

async function runAlwaysOnVisionOnce({ force = false } = {}) {
  if (!allowAlwaysOnVision()) {
    updateAlwaysOnVisionReadout();
    return false;
  }
  const aov = state.alwaysOnVision;
  if (aov.pending) {
    // Keep one pending refresh queued when canvas content changed during an in-flight pass.
    if (force || aov.contentDirty) {
      scheduleAlwaysOnVision({ force: force || aov.contentDirty });
    }
    return false;
  }
  if (!force && !aov.contentDirty) return false;

  const urgent = isAlwaysOnVisionUrgentDirtyReason(aov.dirtyReason);
  const now = Date.now();
  const quietFor = now - (state.lastInteractionAt || 0);
  const idleMs = urgent ? ALWAYS_ON_VISION_URGENT_IDLE_MS : ALWAYS_ON_VISION_IDLE_MS;
  if (quietFor < idleMs) {
    scheduleAlwaysOnVision({ force });
    return false;
  }
  if (isForegroundActionRunning()) {
    scheduleAlwaysOnVision({ force });
    return false;
  }

  const since = now - (aov.lastRunAt || 0);
  const throttleMs = urgent ? ALWAYS_ON_VISION_URGENT_THROTTLE_MS : ALWAYS_ON_VISION_THROTTLE_MS;
  if (since < throttleMs) {
    scheduleAlwaysOnVision({ force });
    return false;
  }

  const signature = computeCanvasSignature();
  if (!force && signature && aov.lastSignature === signature && aov.lastText) {
    aov.contentDirty = false;
    aov.dirtyReason = null;
    return false;
  }

  await ensureRun();
  const stamp = Date.now();
  const snapshotPath = `${state.runDir}/alwayson-${stamp}.png`;
  await waitForIntentImagesLoaded({ timeoutMs: 900 });
  // Ensure the on-screen canvas is up to date before we capture a snapshot.
  render();
  await writeIntentSnapshot(snapshotPath, { maxDimPx: 900 });
  await writeCanvasContextEnvelope(snapshotPath).catch((err) => {
    console.warn("Failed to write canvas context envelope:", err);
  });

  const ok = await ensureEngineSpawned({ reason: "always-on vision" });
  if (!ok) return false;

  aov.pending = true;
  aov.pendingPath = snapshotPath;
  aov.pendingAt = now;
  aov.lastRunAt = now;
  aov.lastSignature = signature;
  aov.contentDirty = false;
  aov.dirtyReason = null;
  updateAlwaysOnVisionReadout();

  clearTimeout(alwaysOnVisionTimeout);
  alwaysOnVisionTimeout = setTimeout(() => {
    if (!state.alwaysOnVision?.pending) return;
    state.alwaysOnVision.pending = false;
    state.alwaysOnVision.pendingPath = null;
    updateAlwaysOnVisionReadout();
    processActionQueue().catch(() => {});
  }, ALWAYS_ON_VISION_TIMEOUT_MS);

  if (aov.rtState === "off") aov.rtState = "connecting";

  // Ensure the canvas-context realtime backend is running before dispatching snapshot work.
  await invoke("write_pty", { data: `${PTY_COMMANDS.CANVAS_CONTEXT_RT_START}\n` }).catch((err) => {
    console.warn("Always-on vision canvas context start failed:", err);
  });

  try {
    await invoke("write_pty", { data: `${PTY_COMMANDS.CANVAS_CONTEXT_RT} ${quoteForPtyArg(snapshotPath)}\n` });
  } catch (err) {
    console.warn("Always-on vision dispatch failed:", err);
    aov.pending = false;
    aov.pendingPath = null;
    aov.contentDirty = true;
    updateAlwaysOnVisionReadout();
    processActionQueue().catch(() => {});
    return false;
  }
  bumpSessionApiCalls();
  return true;
}

function _ambientIntentViewportWorldBounds() {
  const wrap = els.canvasWrap;
  const canvasCssW = Math.max(1, Number(wrap?.clientWidth) || 1);
  const canvasCssH = Math.max(1, Number(wrap?.clientHeight) || 1);
  const dpr = Math.max(0.0001, getDpr());

  if (state.canvasMode === "multi") {
    const scale = Math.max(0.0001, Number(state.multiView?.scale) || 1);
    const offsetCssX = (Number(state.multiView?.offsetX) || 0) / dpr;
    const offsetCssY = (Number(state.multiView?.offsetY) || 0) / dpr;
    return {
      minX: (0 - offsetCssX) / scale,
      minY: (0 - offsetCssY) / scale,
      maxX: (canvasCssW - offsetCssX) / scale,
      maxY: (canvasCssH - offsetCssY) / scale,
    };
  }

  const scale = Math.max(0.0001, Number(state.view?.scale) || 1);
  const offsetCssX = (Number(state.view?.offsetX) || 0) / dpr;
  const offsetCssY = (Number(state.view?.offsetY) || 0) / dpr;
  return {
    minX: (0 - offsetCssX) / scale,
    minY: (0 - offsetCssY) / scale,
    maxX: (canvasCssW - offsetCssX) / scale,
    maxY: (canvasCssH - offsetCssY) / scale,
  };
}

function viewportWorldRect() {
  const vp = _ambientIntentViewportWorldBounds();
  if (!vp) return null;
  const minX = Number(vp.minX) || 0;
  const minY = Number(vp.minY) || 0;
  const maxX = Number(vp.maxX) || 0;
  const maxY = Number(vp.maxY) || 0;
  const w = Math.max(1, maxX - minX);
  const h = Math.max(1, maxY - minY);
  return { x: minX, y: minY, w, h };
}

function rectVisibleRatioInViewport(rect) {
  const r = rect && typeof rect === "object" ? rect : null;
  const vp = viewportWorldRect();
  if (!r || !vp) return 1;
  const rx = Number(r.x) || 0;
  const ry = Number(r.y) || 0;
  const rw = Math.max(1, Number(r.w) || 1);
  const rh = Math.max(1, Number(r.h) || 1);
  const ix = Math.max(rx, vp.x);
  const iy = Math.max(ry, vp.y);
  const ax = Math.min(rx + rw, vp.x + vp.w);
  const ay = Math.min(ry + rh, vp.y + vp.h);
  const iw = Math.max(0, ax - ix);
  const ih = Math.max(0, ay - iy);
  return (iw * ih) / Math.max(1, rw * rh);
}

function recenterRectToViewport(rect) {
  const r = rect && typeof rect === "object" ? rect : null;
  const vp = viewportWorldRect();
  if (!r || !vp) return r;
  const rw = Math.max(1, Number(r.w) || 1);
  const rh = Math.max(1, Number(r.h) || 1);
  return {
    x: vp.x + (vp.w - rw) * 0.5,
    y: vp.y + (vp.h - rh) * 0.5,
    w: rw,
    h: rh,
    autoAspect: true,
  };
}

function _ambientIntentImageRectsWorldMap() {
  const out = new Map();
  if (state.canvasMode === "multi") {
    const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder : [];
    for (const imageId of z) {
      const key = String(imageId || "").trim();
      if (!key) continue;
      const rect = state.freeformRects.get(key);
      if (!rect) continue;
      out.set(key, {
        x: Number(rect.x) || 0,
        y: Number(rect.y) || 0,
        w: Math.max(1, Number(rect.w) || 1),
        h: Math.max(1, Number(rect.h) || 1),
      });
    }
    return out;
  }

  const active = getActiveImage();
  if (!active?.id) return out;
  const iw = Number(active?.img?.naturalWidth || active?.width) || 0;
  const ih = Number(active?.img?.naturalHeight || active?.height) || 0;
  if (iw > 0 && ih > 0) {
    out.set(String(active.id), { x: 0, y: 0, w: iw, h: ih });
  }
  return out;
}

function _ambientUseCaseKeyForBranch(branch) {
  if (!branch || typeof branch !== "object") return null;
  const direct = _intentUseCaseKeyFromBranchId(branch.branch_id);
  if (direct) return direct;
  const icons = Array.isArray(branch.icons)
    ? branch.icons.map((v) => String(v || "").trim().toUpperCase()).filter(Boolean)
    : [];
  for (const iconId of icons) {
    if (iconId === "YES_TOKEN" || iconId === "NO_TOKEN" || iconId === "MAYBE_TOKEN") continue;
    const normalized = _normalizeIntentKey(iconId);
    if (normalized) return normalized;
  }
  return null;
}

function computeAmbientIntentSignature() {
  const parts = [];
  const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder : [];
  for (const imageIdRaw of z) {
    const imageId = String(imageIdRaw || "").trim();
    if (!imageId || !isVisibleCanvasImageId(imageId)) continue;
    const item = state.imagesById.get(imageId) || null;
    const rect = state.freeformRects.get(imageId) || null;
    if (item?.path) parts.push(String(item.path));
    if (item?.visionDesc) {
      const v = String(item.visionDesc).replace(/[\r\n\t|]+/g, " ").replace(/\s+/g, " ").trim();
      if (v) parts.push(`desc:${String(imageId)}:${clampText(v, 56)}`);
    }
    if (!rect) continue;
    parts.push(
      `rect:${String(imageId)}:${Math.round(Number(rect.x) || 0)},${Math.round(Number(rect.y) || 0)},${Math.round(
        Number(rect.w) || 0
      )},${Math.round(Number(rect.h) || 0)}`
    );
  }
  return parts.join("|");
}

function clearAmbientIntentPending() {
  const ambient = state.intentAmbient;
  if (!ambient) return;
  ambient.pending = false;
  ambient.pendingPath = null;
  ambient.pendingAt = 0;
  ambient.pendingFrameId = null;
}

function clearAmbientIntentTimers() {
  clearTimeout(intentAmbientInferenceTimer);
  intentAmbientInferenceTimer = null;
  clearTimeout(intentAmbientInferenceTimeout);
  intentAmbientInferenceTimeout = null;
}

function resetAmbientIntentState({ keepSuggestions = false } = {}) {
  const ambient = state.intentAmbient;
  if (!ambient) return;
  clearAmbientIntentPending();
  ambient.frameSeq = 0;
  ambient.rtState = "off";
  ambient.disabledReason = null;
  ambient.lastError = null;
  ambient.lastErrorAt = 0;
  ambient.lastSignature = null;
  ambient.lastRunAt = 0;
  ambient.iconState = null;
  ambient.iconStateAt = 0;
  ambient.touchedImageIds = [];
  ambient.uiHits = [];
  ambient.lastReason = null;
  if (!keepSuggestions) ambient.suggestions = [];
  clearAmbientIntentTimers();
}

function rebuildAmbientIntentSuggestions(iconState, { reason = null, nowMs = Date.now() } = {}) {
  const ambient = state.intentAmbient;
  if (!ambient) return [];

  const branchesRaw = Array.isArray(iconState?.branches) ? iconState.branches : [];
  const branches = [];
  for (const branch of branchesRaw) {
    if (!branch || typeof branch !== "object") continue;
    const branchId = String(branch.branch_id || "").trim();
    if (!branchId) continue;
    const assetKey = _ambientUseCaseKeyForBranch(branch);
    if (!assetKey) continue;
    const confidence = typeof branch.confidence === "number" && Number.isFinite(branch.confidence)
      ? clamp(Number(branch.confidence) || 0, 0, 1)
      : null;
    branches.push({
      branch_id: branchId,
      asset_type: "icon",
      asset_key: assetKey,
      asset_src: INTENT_UI_ICON_ASSETS.usecases?.[assetKey] || null,
      confidence,
      evidence_image_ids: Array.isArray(branch.evidence_image_ids)
        ? branch.evidence_image_ids.map((v) => String(v || "").trim()).filter(Boolean).slice(0, 3)
        : [],
      });
  }

  if (!branches.length) {
    const fallback = buildFallbackIntentIconState(iconState?.frame_id || `ambient-${nowMs}`, { reason: "no_branches" });
    const fb = Array.isArray(fallback?.branches) ? fallback.branches : [];
    for (const branch of fb) {
      const branchId = String(branch?.branch_id || "").trim();
      if (!branchId) continue;
      const assetKey = _ambientUseCaseKeyForBranch(branch);
      if (!assetKey) continue;
      branches.push({
        branch_id: branchId,
        asset_type: "icon",
        asset_key: assetKey,
        asset_src: INTENT_UI_ICON_ASSETS.usecases?.[assetKey] || null,
        confidence: null,
        evidence_image_ids: [],
      });
    }
  }

  const next = placeAmbientSuggestions({
    branches,
    imageRectsById: _ambientIntentImageRectsWorldMap(),
    touchedImageIds: Array.isArray(ambient.touchedImageIds) ? ambient.touchedImageIds : [],
    viewportWorldBounds: _ambientIntentViewportWorldBounds(),
    maxSuggestions: INTENT_AMBIENT_MAX_NUDGES,
    iconWorldSize: INTENT_AMBIENT_ICON_WORLD_SIZE,
  });

  ambient.suggestions = mergeAmbientSuggestions(ambient.suggestions, next, { nowMs });
  ambient.lastReason = reason ? String(reason) : ambient.lastReason;
  return ambient.suggestions;
}

function applyAmbientIntentFallback(reason, { message = null, hardDisable = false } = {}) {
  const ambient = state.intentAmbient;
  if (!ambient) return;
  const now = Date.now();
  clearAmbientIntentPending();
  ambient.rtState = "failed";
  ambient.disabledReason = hardDisable && message ? String(message) : null;
  ambient.lastError = message ? String(message) : null;
  ambient.lastErrorAt = message ? now : 0;

  const frameId = ambient.pendingFrameId || `ambient-fallback-${now}`;
  ambient.iconState = buildFallbackIntentIconState(frameId, { reason });
  ambient.iconStateAt = now;
  rebuildAmbientIntentSuggestions(ambient.iconState, { reason: `fallback:${String(reason || "fallback")}`, nowMs: now });
  requestRender();
}

function allowAmbientIntentRealtime() {
  if (!intentAmbientActive()) return false;
  if (!getVisibleCanvasImages().length) return false;
  if (!state.runDir) return false;
  if (state.motherIdle?.pendingIntent && String(state.motherIdle.pendingIntentRealtimePath || "").trim()) return false;
  if (!realtimeScopeReady("intent")) return false;
  return true;
}

function scheduleAmbientIntentInference({ immediate = false, reason = null, imageIds = [] } = {}) {
  const ambient = state.intentAmbient;
  if (!ambient || !intentAmbientActive()) return false;
  if (!getVisibleCanvasImages().length) return false;
  if (state.motherIdle?.pendingIntent && String(state.motherIdle.pendingIntentRealtimePath || "").trim()) return false;
  const why = String(reason || "")
    .trim()
    .toLowerCase();
  if (!shouldScheduleAmbientIntent(why)) return false;
  rememberAmbientTouchedImageIds(imageIds.length ? imageIds : [state.activeId]);

  clearTimeout(intentAmbientInferenceTimer);
  const delay = immediate ? 0 : INTENT_INFERENCE_DEBOUNCE_MS;
  intentAmbientInferenceTimer = setTimeout(() => {
    intentAmbientInferenceTimer = null;
    runAmbientIntentInferenceOnce({ reason: why || (immediate ? "immediate" : "debounce") }).catch((err) => {
      console.warn("Ambient intent inference failed:", err);
    });
  }, delay);
  return true;
}

async function runAmbientIntentInferenceOnce({ reason = null } = {}) {
  const ambient = state.intentAmbient;
  if (!ambient || !intentAmbientActive()) return false;
  if (!getVisibleCanvasImages().length) {
    ambient.suggestions = [];
    return false;
  }

  const reasonKey = normalizeIntentReason(reason);
  const now = Date.now();
  const signature = computeAmbientIntentSignature();
  const since = now - (ambient.lastRunAt || 0);
  if (signature && signature === ambient.lastSignature && ambient.iconState && since < 12_000 && ambient.rtState === "ready") {
    return false;
  }
  if (!isIntentFastTrackReason(reasonKey) && since < INTENT_INFERENCE_THROTTLE_MS) {
    clearTimeout(intentAmbientInferenceTimer);
    intentAmbientInferenceTimer = setTimeout(() => {
      intentAmbientInferenceTimer = null;
      runAmbientIntentInferenceOnce({ reason: "throttle" }).catch((err) => console.warn("Ambient intent inference failed:", err));
    }, Math.max(80, INTENT_INFERENCE_THROTTLE_MS - since));
    return false;
  }

  await ensureRun();
  if (!allowAmbientIntentRealtime()) {
    const msg = realtimeScopeUnavailableMessage("intent");
    applyAmbientIntentFallback("realtime_disabled", {
      message: msg,
      hardDisable: Boolean(!realtimeScopeReady("intent")),
    });
    appendIntentTrace({
      kind: "ambient_inference_blocked",
      reason: msg,
      signature,
      rt_state: ambient.rtState,
    }).catch(() => {});
    return false;
  }

  const ok = await ensureEngineSpawned({ reason: "ambient intent inference" });
  if (!ok) {
    const msg = "Intent engine unavailable.";
    applyAmbientIntentFallback("engine_unavailable", { message: msg });
    appendIntentTrace({
      kind: "ambient_engine_unavailable",
      reason: msg,
      signature,
      rt_state: ambient.rtState,
    }).catch(() => {});
    return false;
  }

  if (ambient.rtState === "off" || ambient.rtState === "failed") ambient.rtState = "connecting";
  await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_START}\n` }).catch(() => {});

  ambient.frameSeq = (Number(ambient.frameSeq) || 0) + 1;
  const stamp = Date.now();
  const frameId = `intent-ambient-${stamp}-${ambient.frameSeq}`;
  const snapshotPath = `${state.runDir}/intent-ambient-${stamp}.png`;

  await waitForIntentImagesLoaded({ timeoutMs: intentSnapshotLoadTimeoutForReason(reasonKey) });
  render();
  await writeIntentSnapshot(snapshotPath, { maxDimPx: INTENT_SNAPSHOT_MAX_DIM_PX });
  let ctxPath = null;
  await writeIntentContextEnvelope(snapshotPath, frameId)
    .then((path) => {
      ctxPath = path;
    })
    .catch((err) => {
      console.warn("Failed to write ambient intent envelope:", err);
    });

  appendIntentTrace({
    kind: "ambient_inference_dispatch",
    reason: reason ? String(reason) : null,
    frame_id: frameId,
    snapshot_path: snapshotPath,
    ctx_path: ctxPath,
    signature,
  }).catch(() => {});

  ambient.pending = true;
  ambient.pendingPath = snapshotPath;
  ambient.pendingAt = now;
  ambient.pendingFrameId = frameId;
  ambient.lastRunAt = now;
  ambient.lastSignature = signature;
  ambient.lastReason = reason ? String(reason) : null;
  requestRender();

  clearTimeout(intentAmbientInferenceTimeout);
  intentAmbientInferenceTimeout = setTimeout(() => {
    const cur = state.intentAmbient;
    if (!cur) return;
    if (!cur.pending || cur.pendingPath !== snapshotPath) return;
    const msg = "Intent realtime timed out.";
    applyAmbientIntentFallback("timeout", { message: msg });
    appendIntentTrace({
      kind: "ambient_inference_timeout",
      reason: msg,
      frame_id: frameId,
      snapshot_path: snapshotPath,
      rt_state: cur.rtState,
    }).catch(() => {});
  }, INTENT_INFERENCE_TIMEOUT_MS);

  try {
    await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT} ${quoteForPtyArg(snapshotPath)}\n` });
    bumpSessionApiCalls();
  } catch (err) {
    const msg = err?.message ? `Intent realtime failed: ${err.message}` : "Intent realtime failed.";
    applyAmbientIntentFallback("dispatch_failed", { message: msg });
    appendIntentTrace({
      kind: "ambient_inference_dispatch_failed",
      reason: msg,
      frame_id: frameId,
      snapshot_path: snapshotPath,
      rt_state: ambient.rtState,
    }).catch(() => {});
    return false;
  }

  if (reason) setStatus(`Engine: ambient intent scan (${reason})`);
  return true;
}

function allowIntentRealtime() {
  if (!intentModeActive()) return false;
  if (!getVisibleCanvasImages().length) return false;
  if (!state.runDir) return false;
  const intent = state.intent;
  if (!intent) return false;
  // Fail closed until key status resolves, then enforce provider-specific readiness.
  if (!realtimeScopeReady("intent")) return false;
  return true;
}

function computeIntentSignature() {
  const intent = state.intent || {};
  const parts = [];
  parts.push(`round=${Math.max(1, Number(intent.round) || 1)}`);
  parts.push(`force=${intent.forceChoice ? 1 : 0}`);
  if (intent.focusBranchId) parts.push(`focus=${String(intent.focusBranchId)}`);

  const sigSafe = (text, maxLen = 48) => {
    let s = String(text || "");
    s = s.replace(/[\r\n\t]+/g, " ").replace(/\s+/g, " ").trim();
    if (!s) return "";
    // Avoid clobbering the signature delimiter.
    s = s.replace(/[|]/g, "/");
    if (s.length > maxLen) s = s.slice(0, maxLen);
    return s;
  };

  const sels = Array.isArray(intent.selections) ? intent.selections.slice() : [];
  sels.sort((a, b) => (Number(a?.round) || 0) - (Number(b?.round) || 0));
  for (const sel of sels) {
    const r = Math.max(0, Number(sel?.round) || 0);
    const bid = sel?.branch_id ? String(sel.branch_id) : "";
    const tok = sel?.token ? String(sel.token) : "";
    parts.push(`sel:${r}:${bid}:${tok}`);
  }
  const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder : [];
  for (const imageIdRaw of z) {
    const imageId = String(imageIdRaw || "").trim();
    if (!imageId || !isVisibleCanvasImageId(imageId)) continue;
    const item = state.imagesById.get(imageId) || null;
    if (item?.path) parts.push(item.path);
    if (item?.visionDesc) {
      const v = sigSafe(item.visionDesc, 40);
      if (v) parts.push(`desc:${String(imageId)}:${v}`);
    }
    const rect = imageId ? state.freeformRects.get(imageId) : null;
    if (!rect) continue;
    parts.push(
      `rect:${imageId}:${Math.round(Number(rect.x) || 0)},${Math.round(Number(rect.y) || 0)},${Math.round(
        Number(rect.w) || 0
      )},${Math.round(Number(rect.h) || 0)}`
    );
  }
  return parts.join("|");
}

function scheduleIntentInference({ immediate = false, reason = null } = {}) {
  if (!intentModeActive()) return;
  const intent = state.intent;
  if (!intent || intent.forceChoice) return;
  if (!getVisibleCanvasImages().length) return;

  clearTimeout(intentInferenceTimer);
  const delay = immediate ? 0 : INTENT_INFERENCE_DEBOUNCE_MS;
  intentInferenceTimer = setTimeout(() => {
    intentInferenceTimer = null;
    runIntentInferenceOnce({ reason: reason || (immediate ? "immediate" : "debounce") }).catch((err) => {
      console.warn("Intent inference failed:", err);
    });
  }, delay);
}

async function runIntentInferenceOnce({ reason = null } = {}) {
  const intent = state.intent;
  if (!intentModeActive() || !intent) return false;
  if (intent.forceChoice) {
    intent.pending = false;
    intent.pendingPath = null;
    intent.pendingAt = 0;
    intent.pendingFrameId = null;
    return false;
  }
  if (!getVisibleCanvasImages().length) return false;

  const now = Date.now();
  if (!intent.startedAt) {
    intent.startedAt = now;
    if (INTENT_TIMER_ENABLED) {
      intent.deadlineAt = now + INTENT_DEADLINE_MS;
      ensureIntentTicker();
    } else {
      intent.deadlineAt = 0;
    }
    scheduleIntentStateWrite({ immediate: true });
  }

  updateIntentCountdown(now);
  if (intent.forceChoice) return false;

  const reasonKey = normalizeIntentReason(reason);
  const signature = computeIntentSignature();
  const since = now - (intent.lastRunAt || 0);
  if (signature && signature === intent.lastSignature && intent.iconState && since < 12_000 && intent.rtState === "ready") {
    return false;
  }
  if (!isIntentFastTrackReason(reasonKey) && since < INTENT_INFERENCE_THROTTLE_MS) {
    // Keep it responsive but avoid hammering the Realtime session while the user is dragging.
    scheduleIntentInference({ immediate: false, reason: "throttle" });
    return false;
  }

  await ensureRun();

  if (!allowIntentRealtime()) {
    intent.pending = false;
    intent.pendingPath = null;
    intent.pendingAt = 0;
    intent.pendingFrameId = null;
    intent.rtState = "failed";
    intent.disabledReason = realtimeScopeUnavailableMessage("intent");
    intent.lastError = intent.disabledReason;
    intent.lastErrorAt = now;
    intent.uiHideSuggestion = false;
    const icon = ensureIntentFallbackIconState("disabled");
    if (!intent.focusBranchId) intent.focusBranchId = pickSuggestedIntentBranchId(icon) || pickDefaultIntentFocusBranchId(icon);
    appendIntentTrace({
      kind: "inference_blocked",
      reason: intent.disabledReason,
      round: Math.max(1, Number(intent.round) || 1),
      signature,
      rt_state: intent.rtState,
    }).catch(() => {});
    scheduleIntentStateWrite();
    requestRender();
    return false;
  }

  const ok = await ensureEngineSpawned({ reason: "intent inference" });
  if (!ok) {
    intent.pending = false;
    intent.pendingPath = null;
    intent.pendingAt = 0;
    intent.pendingFrameId = null;
    intent.rtState = "failed";
    intent.disabledReason = "Intent engine unavailable.";
    intent.lastError = intent.disabledReason;
    intent.lastErrorAt = now;
    intent.uiHideSuggestion = false;
    const icon = ensureIntentFallbackIconState("engine_unavailable");
    if (!intent.focusBranchId) intent.focusBranchId = pickSuggestedIntentBranchId(icon) || pickDefaultIntentFocusBranchId(icon);
    appendIntentTrace({
      kind: "engine_unavailable",
      reason: intent.disabledReason,
      round: Math.max(1, Number(intent.round) || 1),
      signature,
      rt_state: intent.rtState,
    }).catch(() => {});
    scheduleIntentStateWrite();
    requestRender();
    return false;
  }

  // Start (or keep alive) the realtime session.
  if (intent.rtState === "off" || intent.rtState === "failed") intent.rtState = "connecting";
  await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_START}\n` }).catch(() => {});

  // Build a new frame id so we can ignore stale streaming updates.
  intent.frameSeq = (Number(intent.frameSeq) || 0) + 1;
  const stamp = Date.now();
  const frameId = `intent-r${Math.max(1, Number(intent.round) || 1)}-${stamp}-${intent.frameSeq}`;
  const snapshotPath = `${state.runDir}/intent-${stamp}-r${String(Math.max(1, Number(intent.round) || 1)).padStart(
    2,
    "0"
  )}.png`;

  await waitForIntentImagesLoaded({ timeoutMs: intentSnapshotLoadTimeoutForReason(reasonKey) });
  // Ensure the on-screen canvas is up to date before we capture a snapshot.
  render();

  await writeIntentSnapshot(snapshotPath, { maxDimPx: INTENT_SNAPSHOT_MAX_DIM_PX });
  let ctxPath = null;
  await writeIntentContextEnvelope(snapshotPath, frameId)
    .then((path) => {
      ctxPath = path;
    })
    .catch((err) => {
      console.warn("Failed to write intent envelope:", err);
    });
  appendIntentTrace({
    kind: "inference_dispatch",
    reason: reason ? String(reason) : null,
    round: Math.max(1, Number(intent.round) || 1),
    frame_id: frameId,
    snapshot_path: snapshotPath,
    ctx_path: ctxPath,
    signature,
  }).catch(() => {});

  intent.pending = true;
  intent.pendingPath = snapshotPath;
  intent.pendingAt = now;
  intent.pendingFrameId = frameId;
  intent.lastRunAt = now;
  intent.lastSignature = signature;
  scheduleIntentStateWrite();
  requestRender();

  clearTimeout(intentInferenceTimeout);
  intentInferenceTimeout = setTimeout(() => {
    const cur = state.intent;
    if (!cur || cur.locked) return;
    if (!cur.pending || cur.pendingPath !== snapshotPath) return;
    cur.pending = false;
    cur.pendingPath = null;
    cur.pendingAt = 0;
    cur.pendingFrameId = null;
    cur.rtState = "failed";
    cur.disabledReason = "Intent realtime timed out.";
    cur.lastError = cur.disabledReason;
    cur.lastErrorAt = Date.now();
    cur.uiHideSuggestion = false;
    // Fall back to a local branch set so the user can still lock an intent.
    cur.forceChoice = INTENT_FORCE_CHOICE_ENABLED ? true : false;
    ensureIntentFallbackIconState("timeout");
    cur.focusBranchId = cur.focusBranchId || pickSuggestedIntentBranchId(cur.iconState) || pickDefaultIntentFocusBranchId();
    appendIntentTrace({
      kind: "inference_timeout",
      reason: cur.disabledReason,
      snapshot_path: snapshotPath,
      frame_id: frameId,
      rt_state: cur.rtState,
    }).catch(() => {});
    scheduleIntentStateWrite({ immediate: true });
    requestRender();
  }, INTENT_INFERENCE_TIMEOUT_MS);

  try {
    await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT} ${quoteForPtyArg(snapshotPath)}\n` });
    bumpSessionApiCalls();
  } catch (err) {
    intent.pending = false;
    intent.pendingPath = null;
    intent.pendingAt = 0;
    intent.pendingFrameId = null;
    intent.rtState = "failed";
    intent.disabledReason = err?.message ? `Intent realtime failed: ${err.message}` : "Intent realtime failed.";
    intent.lastError = intent.disabledReason;
    intent.lastErrorAt = Date.now();
    intent.uiHideSuggestion = false;
    intent.forceChoice = INTENT_FORCE_CHOICE_ENABLED ? true : false;
    ensureIntentFallbackIconState("dispatch_failed");
    if (!intent.focusBranchId) {
      intent.focusBranchId = pickSuggestedIntentBranchId(intent.iconState) || pickDefaultIntentFocusBranchId(intent.iconState);
    }
    appendIntentTrace({
      kind: "inference_dispatch_failed",
      reason: intent.disabledReason,
      snapshot_path: snapshotPath,
      frame_id: frameId,
      rt_state: intent.rtState,
    }).catch(() => {});
    scheduleIntentStateWrite({ immediate: true });
    requestRender();
    return false;
  }

  // Keep a light status breadcrumb in the debug header.
  if (reason) setStatus(`Engine: intent scan (${reason})`);
  return true;
}

async function waitForIntentImagesLoaded({ timeoutMs = 900, maxImages = 6 } = {}) {
  const loadLimit = Math.max(1, Math.round(Number(maxImages) || 6));
  const items = getVisibleCanvasImages().filter((it) => it?.path).slice(0, loadLimit);
  for (const item of items) ensureCanvasImageLoaded(item);
  const deadline = Date.now() + Math.max(60, Number(timeoutMs) || 900);
  while (Date.now() < deadline) {
    if (items.every((it) => Boolean(it?.img))) return true;
    await new Promise((r) => setTimeout(r, 50));
  }
  return items.some((it) => Boolean(it?.img));
}

async function writeIntentSnapshot(outPath, { maxDimPx = INTENT_SNAPSHOT_MAX_DIM_PX } = {}) {
  const baseWork = els.workCanvas;
  if (!baseWork) return null;

  const baseW = Number(baseWork.width) || 0;
  const baseH = Number(baseWork.height) || 0;
  if (!baseW || !baseH) return null;

  const maxDim = Math.max(420, Math.round(Number(maxDimPx) || INTENT_SNAPSHOT_MAX_DIM_PX));
  const scale = Math.min(1, maxDim / Math.max(1, Math.max(baseW, baseH)));
  const w = Math.max(1, Math.round(baseW * scale));
  const h = Math.max(1, Math.round(baseH * scale));

  const canvas = document.createElement("canvas");
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  // Background (matches the in-app canvas atmosphere).
  const bg = ctx.createLinearGradient(0, 0, 0, h);
  bg.addColorStop(0, "rgba(18, 26, 37, 0.92)");
  bg.addColorStop(1, "rgba(6, 8, 12, 0.96)");
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, w, h);

  // Snapshot only the user content canvas (no UI overlays) for cleaner vision input.
  ctx.drawImage(baseWork, 0, 0, w, h);

  await writeCanvasPngToPath(canvas, outPath);
  return outPath;
}

function buildMotherRealtimeContextEnvelope({ motherContextPayload = null, imageOriginById = null } = {}) {
  const idle = state.motherIdle || null;
  const payload = motherContextPayload && typeof motherContextPayload === "object"
    ? motherContextPayload
    : motherV2IntentPayload();
  const selectedIds = motherV2NormalizeImageIdList(payload?.selected_ids || []).slice(0, 3);
  const activeIdRaw = String(payload?.active_id || "").trim();
  const activeId = activeIdRaw && isVisibleCanvasImageId(activeIdRaw) ? activeIdRaw : null;
  const imageSetSig = motherV2IntentImageSetSignature(idle?.intent || null);
  const contextSig = motherV2IntentContextSignature(idle?.intent || null);
  const rejectedModes = [];
  for (const sig of [contextSig, imageSetSig]) {
    for (const mode of motherV2RejectedModesForContext(sig)) {
      if (!mode || rejectedModes.includes(mode)) continue;
      rejectedModes.push(mode);
    }
  }
  const ambient = payload?.ambient_intent && typeof payload.ambient_intent === "object" ? payload.ambient_intent : null;
  const ambientBranches = Array.isArray(ambient?.branches)
    ? ambient.branches
        .map((entry) => {
          if (!entry || typeof entry !== "object") return null;
          const branchId = String(entry.branch_id || "").trim();
          if (!branchId) return null;
          return {
            branch_id: branchId,
            confidence:
              typeof entry.confidence === "number" && Number.isFinite(entry.confidence)
                ? clamp(Number(entry.confidence) || 0, 0, 1)
                : null,
            evidence_image_ids: Array.isArray(entry.evidence_image_ids)
              ? entry.evidence_image_ids.map((v) => String(v || "").trim()).filter(Boolean).slice(0, 3)
              : [],
          };
        })
        .filter(Boolean)
        .slice(0, 3)
    : [];
  const ambientModes = Array.isArray(ambient?.transformation_mode_candidates)
    ? ambient.transformation_mode_candidates
        .map((entry, idx) => motherV2NormalizeModeCandidate(entry, { idx }))
        .filter(Boolean)
        .sort(motherV2CompareModeCandidates)
        .map((entry) => {
          const preset = motherV2ShotTypeHintForMode(entry.mode);
          return {
            mode: entry.mode,
            awe_joy_score: typeof entry.awe_joy_score === "number" ? entry.awe_joy_score : null,
            confidence: typeof entry.confidence === "number" ? entry.confidence : null,
            shot_type: String(preset?.primary || "").trim() || null,
            lighting_profile: String(preset?.lighting_profile || "").trim() || null,
            lens_guidance: String(preset?.lens_guidance || "").trim() || null,
          };
        })
        .slice(0, MOTHER_V2_MAX_RANKED_PROPOSALS)
    : [];
  const proposalContext = payload?.proposal_context && typeof payload.proposal_context === "object"
    ? payload.proposal_context
    : null;
  const preferredModeForHints =
    motherV2MaybeTransformationMode(payload?.preferred_transformation_mode) ||
    motherV2MaybeTransformationMode(ambient?.preferred_transformation_mode) ||
    ambientModes[0]?.mode ||
    MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
  const fallbackShotTypeHints = motherV2ShotTypeHints({
    preferredMode: preferredModeForHints,
    candidateModes: ambientModes,
  });
  const rawShotTypeHints = proposalContext?.shot_type_hints && typeof proposalContext.shot_type_hints === "object"
    ? proposalContext.shot_type_hints
    : fallbackShotTypeHints;
  const shotTypeHints = {
    primary_shot_type:
      clampText(String(rawShotTypeHints?.primary_shot_type || fallbackShotTypeHints.primary_shot_type || "").trim(), 96) || null,
    alternate_shot_type:
      clampText(String(rawShotTypeHints?.alternate_shot_type || fallbackShotTypeHints.alternate_shot_type || "").trim(), 96) || null,
    primary_lighting_profile:
      clampText(String(rawShotTypeHints?.primary_lighting_profile || fallbackShotTypeHints.primary_lighting_profile || "").trim(), 140) || null,
    alternate_lighting_profile:
      clampText(String(rawShotTypeHints?.alternate_lighting_profile || fallbackShotTypeHints.alternate_lighting_profile || "").trim(), 140) || null,
    primary_lens_guidance:
      clampText(String(rawShotTypeHints?.primary_lens_guidance || fallbackShotTypeHints.primary_lens_guidance || "").trim(), 140) || null,
    alternate_lens_guidance:
      clampText(String(rawShotTypeHints?.alternate_lens_guidance || fallbackShotTypeHints.alternate_lens_guidance || "").trim(), 140) || null,
  };
  const compactImages = (Array.isArray(payload?.images) ? payload.images : [])
    .map((image) => {
      if (!image || typeof image !== "object") return null;
      const imageId = String(image.id || "").trim();
      if (!imageId) return null;
      const item = state.imagesById.get(imageId) || null;
      const pathText = String(image.path || item?.path || "").trim();
      const inferredOrigin = item && isMotherGeneratedImageItem(item) ? "mother_generated" : "uploaded";
      const originFromMap = imageOriginById?.get?.(imageId) || null;
      const origin = originFromMap || inferredOrigin;
      const rectNorm = image.rect_norm && typeof image.rect_norm === "object"
        ? {
            x: Number(image.rect_norm.x) || 0,
            y: Number(image.rect_norm.y) || 0,
            w: Math.max(0, Number(image.rect_norm.w) || 0),
            h: Math.max(0, Number(image.rect_norm.h) || 0),
          }
        : null;
      return {
        id: imageId,
        file: image.file ? String(image.file) : pathText ? basename(pathText) : null,
        vision_desc: normalizeVisionHintForIntent(image.vision_desc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS }),
        origin,
        rect_norm: rectNorm,
      };
    })
    .filter(Boolean)
    .slice(0, 10);
  return {
    schema: "brood.mother.realtime_context.v1",
    optimization_target: motherCurrentOptimizationTarget(),
    optimization_hint: `Optimize proposals for ${motherCurrentOptimizationTarget()} with bold, surprising recombinations.`,
    action_version: Number(payload?.action_version) || Number(idle?.actionVersion) || 0,
    creative_directive: String(payload?.creative_directive || motherCurrentCreativeDirective() || "").trim(),
    preferred_transformation_mode: motherV2MaybeTransformationMode(payload?.preferred_transformation_mode) || null,
    intensity: clamp(Number(payload?.intensity) || Number(idle?.intensity) || 62, 0, 100),
    preferred_shot_type:
      clampText(String(proposalContext?.preferred_shot_type || shotTypeHints.primary_shot_type || "").trim(), 96) || null,
    alternate_shot_type:
      clampText(String(proposalContext?.alternate_shot_type || shotTypeHints.alternate_shot_type || "").trim(), 96) || null,
    preferred_lighting_profile:
      clampText(String(proposalContext?.preferred_lighting_profile || shotTypeHints.primary_lighting_profile || "").trim(), 140) || null,
    alternate_lighting_profile:
      clampText(String(proposalContext?.alternate_lighting_profile || shotTypeHints.alternate_lighting_profile || "").trim(), 140) || null,
    preferred_lens_guidance:
      clampText(String(proposalContext?.preferred_lens_guidance || shotTypeHints.primary_lens_guidance || "").trim(), 140) || null,
    alternate_lens_guidance:
      clampText(String(proposalContext?.alternate_lens_guidance || shotTypeHints.alternate_lens_guidance || "").trim(), 140) || null,
    shot_type_hints: shotTypeHints,
    active_id: activeId,
    selected_ids: selectedIds,
    canvas_context_summary: payload?.canvas_context_summary ? clampText(String(payload.canvas_context_summary || ""), 240) : null,
    recent_rejected_modes_for_context: rejectedModes,
    last_accepted_mode: motherV2MaybeTransformationMode(idle?.lastProposalMode || idle?.intent?.transformation_mode),
    ambient_intent: ambientBranches.length || ambientModes.length
      ? {
          preferred_transformation_mode: motherV2MaybeTransformationMode(ambient?.preferred_transformation_mode) || null,
          branches: ambientBranches,
          transformation_mode_candidates: ambientModes,
        }
      : null,
    images: compactImages,
  };
}

function buildIntentContextEnvelope(frameId, { motherContextPayload = null } = {}) {
  const wrap = els.canvasWrap;
  const intent = state.intent || {};
  const dpr = getDpr();
  const canvasCssW = wrap?.clientWidth || 0;
  const canvasCssH = wrap?.clientHeight || 0;
  const isMotherFrame = String(frameId || "").trim().toLowerCase().startsWith("mother-intent-");

  const images = [];
  const imageOriginById = new Map();
  const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder : [];
  for (let idx = 0; idx < z.length; idx += 1) {
    const imageId = String(z[idx] || "").trim();
    if (!imageId || !isVisibleCanvasImageId(imageId)) continue;
    const item = imageId ? state.imagesById.get(imageId) : null;
    const rect = imageId ? state.freeformRects.get(imageId) : null;
    if (!item?.path || !rect) continue;
    const visionDesc = normalizeVisionHintForIntent(item?.visionDesc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS });
    const vmeta = item?.visionDescMeta || null;
    const x = Number(rect.x) || 0;
    const y = Number(rect.y) || 0;
    const w = Math.max(1, Number(rect.w) || 1);
    const h = Math.max(1, Number(rect.h) || 1);
    const cx = x + w / 2;
    const cy = y + h / 2;
    const origin = isMotherGeneratedImageItem(item) ? "mother_generated" : "uploaded";
    imageOriginById.set(String(imageId), origin);
    images.push({
      id: String(imageId),
      path: String(item.path),
      file: basename(item.path),
      origin,
      import_index: (state.images || []).findIndex((im) => im?.id === imageId),
      z: idx,
      // Short vision-derived label for this image (best-effort). This is an internal
      // signal to improve intent suggestions while keeping user input "images-only".
      vision_desc: visionDesc,
      vision_desc_meta: visionDesc
        ? {
            source: vmeta?.source ? String(vmeta.source) : null,
            model: vmeta?.model ? String(vmeta.model) : null,
            at_ms: Number(vmeta?.at) || null,
          }
        : null,
      rect_css: { x, y, w, h, cx, cy },
      rect_norm: {
        x: canvasCssW ? x / canvasCssW : 0,
        y: canvasCssH ? y / canvasCssH : 0,
        w: canvasCssW ? w / canvasCssW : 0,
        h: canvasCssH ? h / canvasCssH : 0,
        cx: canvasCssW ? cx / canvasCssW : 0,
        cy: canvasCssH ? cy / canvasCssH : 0,
      },
    });
  }

  const now = Date.now();
  const remaining_ms = INTENT_TIMER_ENABLED
    ? intent.startedAt
      ? intentRemainingMs(now)
      : INTENT_DEADLINE_MS
    : 0;

  const envelope = {
    schema: "brood.intent_envelope",
    schema_version: INTENT_ENVELOPE_VERSION,
    generated_at: new Date().toISOString(),
    frame_id: String(frameId || ""),
    canvas: {
      width_css: canvasCssW,
      height_css: canvasCssH,
      width_px: Math.max(0, Math.round(canvasCssW * dpr)),
      height_px: Math.max(0, Math.round(canvasCssH * dpr)),
      dpr,
    },
    intent: {
      round: Math.max(1, Number(intent.round) || 1),
      total_rounds: INTENT_ROUNDS_ENABLED ? Math.max(1, Number(intent.totalRounds) || 3) : 0,
      started_at_ms: Number(intent.startedAt) || 0,
      deadline_at_ms: INTENT_TIMER_ENABLED ? Number(intent.deadlineAt) || 0 : 0,
      remaining_ms,
      timer_enabled: Boolean(INTENT_TIMER_ENABLED),
      rounds_enabled: Boolean(INTENT_ROUNDS_ENABLED),
      force_choice_enabled: Boolean(INTENT_FORCE_CHOICE_ENABLED),
      force_choice: INTENT_FORCE_CHOICE_ENABLED ? Boolean(intent.forceChoice) : false,
      focus_branch_id: intent.focusBranchId ? String(intent.focusBranchId) : null,
      selections: Array.isArray(intent.selections) ? intent.selections : [],
    },
    images,
  };
  if (isMotherFrame) {
    envelope.mother_context = buildMotherRealtimeContextEnvelope({
      motherContextPayload,
      imageOriginById,
    });
  }
  return envelope;
}

async function writeIntentContextEnvelope(snapshotPath, frameId, { motherContextPayload = null } = {}) {
  if (!state.runDir) return null;
  const ctxPath = _canvasContextSidecarPath(snapshotPath);
  if (!ctxPath) return null;
  const envelope = buildIntentContextEnvelope(frameId, { motherContextPayload });
  await writeTextFile(ctxPath, JSON.stringify(envelope));
  return ctxPath;
}

function motherV2RequiredIntentReferenceCount(payload = null) {
  const images = Array.isArray(payload?.images) ? payload.images : [];
  const uniquePaths = Array.from(
    new Set(
      images
        .map((image) => String(image?.path || "").trim())
        .filter(Boolean)
    )
  );
  if (!uniquePaths.length) return 0;
  if (uniquePaths.length === 1) return 1;
  return Math.min(MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL, uniquePaths.length);
}

async function motherV2CountValidIntentContextReferences(snapshotPath = "") {
  const ctxPath = _canvasContextSidecarPath(snapshotPath);
  if (!ctxPath) return { count: 0, ctxPath: null };
  const raw = await readTextFile(ctxPath).catch(() => "");
  if (!raw) return { count: 0, ctxPath };
  let parsed = null;
  try {
    parsed = JSON.parse(raw);
  } catch {
    return { count: 0, ctxPath };
  }
  const rows = Array.isArray(parsed?.images) ? parsed.images : [];
  const snapshotPathNorm = String(snapshotPath || "").trim();
  const seen = new Set();
  let count = 0;
  for (const row of rows) {
    const pathText = String(row?.path || "").trim();
    if (!pathText || pathText === snapshotPathNorm || seen.has(pathText)) continue;
    seen.add(pathText);
    const ok = await exists(pathText).catch(() => false);
    if (!ok) continue;
    count += 1;
  }
  return { count, ctxPath };
}

async function motherV2WriteIntentContextEnvelopeWithRefRetry(
  snapshotPath,
  frameId,
  payload,
  { requestId = null, actionVersion = 0 } = {}
) {
  const requiredRefs = motherV2RequiredIntentReferenceCount(payload);
  let ctxPath = null;
  let availableRefs = 0;
  for (let attempt = 0; attempt <= MOTHER_V2_INTENT_CONTEXT_REF_RETRY_MAX; attempt += 1) {
    ctxPath = await writeIntentContextEnvelope(snapshotPath, frameId, { motherContextPayload: payload }).catch(() => null);
    const inspected = await motherV2CountValidIntentContextReferences(snapshotPath).catch(() => ({ count: 0, ctxPath: null }));
    availableRefs = Math.max(0, Number(inspected?.count) || 0);
    if (ctxPath && availableRefs >= requiredRefs) {
      return {
        ok: true,
        ctxPath,
        requiredRefs,
        availableRefs,
        attempts: attempt + 1,
      };
    }
    if (attempt < MOTHER_V2_INTENT_CONTEXT_REF_RETRY_MAX) {
      await new Promise((resolve) => setTimeout(resolve, MOTHER_V2_INTENT_CONTEXT_REF_RETRY_DELAY_MS));
    }
  }
  appendMotherTraceLog({
    kind: "intent_context_refs_unavailable",
    actionVersion: Number(actionVersion) || 0,
    request_id: requestId ? String(requestId) : null,
    snapshot_path: snapshotPath ? String(snapshotPath) : null,
    required_refs: requiredRefs,
    available_refs: availableRefs,
    retry_max: MOTHER_V2_INTENT_CONTEXT_REF_RETRY_MAX,
  }).catch(() => {});
  return {
    ok: false,
    ctxPath: null,
    requiredRefs,
    availableRefs,
    attempts: MOTHER_V2_INTENT_CONTEXT_REF_RETRY_MAX + 1,
  };
}

function buildFallbackIntentIconState(frameId, { reason = null } = {}) {
  const gen = { icon_id: "IMAGE_GENERATION", confidence: 0.52, position_hint: "primary" };
  const iterate = { icon_id: "ITERATION", confidence: 0.44, position_hint: "primary" };
  const outputs = { icon_id: "OUTPUTS", confidence: 0.34, position_hint: "secondary" };
  const pipeline = { icon_id: "PIPELINE", confidence: 0.30, position_hint: "emerging" };
  const fallbackModes = ["hybridize", "amplify", "transcend", "destabilize", "purify"]
    .slice(0, MOTHER_V2_MAX_RANKED_PROPOSALS);
  const branches = fallbackModes.map((mode, idx) => ({
    branch_id: mode,
    icons: [String(mode).toUpperCase(), "IMAGE_GENERATION", "ITERATION"],
    lane_position: idx % 2 === 0 ? "left" : "right",
  }));
  const transformation_mode_candidates = fallbackModes.map((mode, idx) => ({
    mode,
    confidence: clamp(0.74 - idx * 0.08, 0.3, 0.74),
  }));
  return {
    frame_id: String(frameId || `fallback-${Date.now()}`),
    schema: "brood.intent_icons",
    schema_version: 1,
    intent_icons: [gen, iterate, outputs, pipeline],
    relations: [
      { from_icon: "ITERATION", to_icon: "IMAGE_GENERATION", relation_type: "DEPENDENCY" },
      { from_icon: "IMAGE_GENERATION", to_icon: "OUTPUTS", relation_type: "FLOW" },
    ],
    branches,
    transformation_mode: fallbackModes[0],
    transformation_mode_candidates,
    checkpoint: { icons: ["YES_TOKEN", "NO_TOKEN", "MAYBE_TOKEN"], applies_to: fallbackModes[0] || "branches" },
  };
}

function ensureIntentFallbackIconState(reason = "fallback") {
  const intent = state.intent;
  if (!intent) return null;
  const now = Date.now();
  if (!intent.iconState || typeof intent.iconState !== "object") {
    const frameId = intent.pendingFrameId || `fallback-${now}`;
    intent.iconState = buildFallbackIntentIconState(frameId, { reason });
    intent.iconStateAt = now;
    return intent.iconState;
  }
  // If the model returned no branches, keep the user's ability to choose by adding a fallback set.
  const branches = Array.isArray(intent.iconState?.branches) ? intent.iconState.branches : [];
  if (branches.length === 0) {
    const frameId = intent.iconState?.frame_id || intent.pendingFrameId || `fallback-${now}`;
    const fallback = buildFallbackIntentIconState(frameId, { reason });
    intent.iconState.branches = fallback.branches;
    if (!intent.iconState.checkpoint) intent.iconState.checkpoint = fallback.checkpoint;
    intent.iconStateAt = now;
  }
  return intent.iconState;
}

function intentIconsPayloadChecksum(raw) {
  return intentIconsPayloadChecksumUtil(raw);
}

function intentIconsPayloadSafeSnippet(raw, options = {}) {
  return intentIconsPayloadSafeSnippetUtil(raw, options);
}

function parseIntentIconsJsonDetailed(raw) {
  return parseIntentIconsJsonDetailedUtil(raw, {
    normalizeTransformationMode: motherV2MaybeTransformationMode,
  });
}

function parseIntentIconsJson(raw) {
  return parseIntentIconsJsonUtil(raw, {
    normalizeTransformationMode: motherV2MaybeTransformationMode,
  });
}

function classifyIntentIconsRouting(options = {}) {
  return classifyIntentIconsRoutingUtil(options);
}

const VISION_LABEL_GENERIC_TOKENS = new Set([
  "image",
  "photo",
  "snapshot",
  "picture",
  "subject",
  "subjects",
  "thing",
  "item",
  "object",
  "stuff",
  "scene",
  "view",
  "shot",
  "person",
  "people",
  "human",
  "man",
  "woman",
  "athlete",
  "player",
  "model",
  "selfie",
  "face",
  "figure",
  "character",
  "portrait",
]);

const VISION_LABEL_HEAD_TOKENS = new Set([
  "portrait",
  "person",
  "people",
  "human",
  "man",
  "woman",
  "face",
  "figure",
  "character",
  "athlete",
  "player",
  "model",
  "subject",
  "object",
  "item",
  "scene",
  "product",
]);

const VISION_LABEL_DETAIL_TOKENS = new Set([
  "red",
  "blue",
  "green",
  "yellow",
  "orange",
  "purple",
  "pink",
  "white",
  "black",
  "gold",
  "silver",
  "brown",
  "beige",
  "metal",
  "wood",
  "wooden",
  "glass",
  "plastic",
  "ceramic",
  "fabric",
  "textile",
  "leather",
  "paper",
  "stone",
  "concrete",
  "shirt",
  "dress",
  "jacket",
  "hoodie",
  "coat",
  "jersey",
  "shoe",
  "sneaker",
  "hat",
  "glasses",
  "holding",
  "walking",
  "standing",
  "sitting",
  "looking",
  "reading",
  "writing",
  "cooking",
  "jumping",
  "running",
  "smiling",
  "city",
  "street",
  "forest",
  "mountain",
  "beach",
  "interior",
  "exterior",
  "product",
  "logo",
  "icon",
  "ui",
  "screen",
  "poster",
  "illustration",
  "painting",
  "sketch",
  "render",
  "closeup",
  "close",
  "macro",
  "wide",
  "overhead",
  "topdown",
  "profile",
  "headshot",
  "front",
  "rear",
  "left",
  "right",
  "center",
  "side",
  "pair",
  "duo",
  "group",
  "single",
  "two",
  "three",
]);

const VISION_LABEL_ARTICLE_TOKENS = new Set(["a", "an", "the"]);
const VISION_LABEL_AUX_TOKENS = new Set(["is", "are", "was", "were"]);
const REALTIME_VISION_LABEL_MAX_CHARS = 40;

function _visionTokenCore(raw) {
  return String(raw || "")
    .replace(/^[^A-Za-z0-9]+/g, "")
    .replace(/[^A-Za-z0-9]+$/g, "");
}

function _visionTokenStartsUpper(raw) {
  const core = _visionTokenCore(raw);
  if (!core) return false;
  const first = core.charAt(0);
  return first >= "A" && first <= "Z";
}

function _compactVisionCaptionFragment(raw) {
  let text = String(raw || "")
    .replace(/[\r\n\t]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  if (!text) return "";

  text = text
    .replace(/^["']+|["']+$/g, "")
    .replace(/[.,;:!?]+$/g, "")
    .replace(/[,:;]+/g, " ")
    .trim();
  if (!text) return "";

  text = text.replace(/^(?:an?\s+)?(?:photo|image|picture)\s+of\s+/i, "").trim();
  if (!text) return "";

  let tokens = text
    .split(/\s+/g)
    .map((token) => token.trim())
    .filter(Boolean);
  if (!tokens.length) return "";

  while (
    tokens.length > 1 &&
    VISION_LABEL_ARTICLE_TOKENS.has(_visionTokenCore(tokens[0]).toLowerCase())
  ) {
    tokens.shift();
  }

  if (tokens.length >= 3) {
    const second = _visionTokenCore(tokens[1]).toLowerCase();
    if (VISION_LABEL_AUX_TOKENS.has(second)) {
      tokens.splice(1, 1);
    } else if (tokens.length >= 4) {
      const third = _visionTokenCore(tokens[2]).toLowerCase();
      if (
        VISION_LABEL_AUX_TOKENS.has(third) &&
        _visionTokenStartsUpper(tokens[0]) &&
        _visionTokenStartsUpper(tokens[1])
      ) {
        tokens.splice(2, 1);
      }
    }
  }

  if (tokens.length >= 3) {
    for (let i = 1; i < tokens.length - 1; i += 1) {
      const current = _visionTokenCore(tokens[i]).toLowerCase();
      if (!VISION_LABEL_AUX_TOKENS.has(current)) continue;
      const next = _visionTokenCore(tokens[i + 1]).toLowerCase();
      if (next.endsWith("ing")) {
        tokens.splice(i, 1);
        break;
      }
    }
  }

  if (tokens.length > 2) {
    const lastIdx = tokens.length - 1;
    tokens = tokens.filter((token, idx) => {
      if (idx <= 0 || idx >= lastIdx) return true;
      return !VISION_LABEL_AUX_TOKENS.has(_visionTokenCore(token).toLowerCase());
    });
  }

  if (tokens.length > 2) {
    tokens = tokens.filter((token, idx) => {
      if (idx === 0) return true;
      return !VISION_LABEL_ARTICLE_TOKENS.has(_visionTokenCore(token).toLowerCase());
    });
  }

  return tokens
    .map((token) => _visionTokenCore(token))
    .filter(Boolean)
    .join(" ")
    .replace(/\s+/g, " ")
    .trim();
}

function _normalizeVisionLabel(raw, { maxChars = 32 } = {}) {
  const s = _compactVisionCaptionFragment(raw);
  if (!s) return "";
  // Keep it short and HUD-friendly. (Even though it may not be shown in intent mode,
  // we reuse the same field for later HUD rendering.)
  const clipped = maxChars > 0 ? clampText(s, maxChars) : s;
  // Avoid our intent-signature delimiter.
  return clipped.replace(/[|]/g, "/").trim();
}

function normalizeVisionHintForIntent(raw, { maxChars = REALTIME_VISION_LABEL_MAX_CHARS } = {}) {
  const label = _normalizeVisionLabel(raw, { maxChars });
  if (!label) return null;
  if (shouldBackfillVisionLabel(label)) return null;
  return label;
}

function _visionLabelTokens(raw) {
  const s = String(raw || "").toLowerCase();
  return s.match(/[a-z0-9]+/g) || [];
}

function _visionLabelNameTokenCount(raw) {
  const text = String(raw || "").trim();
  if (!text) return 0;
  const tokens = text.split(/\s+/g);
  let count = 0;
  for (const tokenRaw of tokens) {
    const token = String(tokenRaw || "").replace(/[^A-Za-z0-9'-]/g, "");
    if (!token || token.length < 3) continue;
    if (!/^[A-Z]/.test(token)) continue;
    const lower = token.toLowerCase();
    if (VISION_LABEL_GENERIC_TOKENS.has(lower)) continue;
    if (VISION_LABEL_DETAIL_TOKENS.has(lower)) continue;
    count += 1;
  }
  if (/\b[A-Z][a-z]+[A-Z][a-z]+\b/.test(text)) count += 1;
  return count;
}

function _isGenericVisionLabel(raw) {
  const tokens = _visionLabelTokens(raw);
  if (!tokens.length) return true;
  const genericCount = tokens.filter((token) => VISION_LABEL_GENERIC_TOKENS.has(token)).length;
  const detailCount = tokens.filter((token) => VISION_LABEL_DETAIL_TOKENS.has(token)).length;
  const headCount = tokens.filter((token) => VISION_LABEL_HEAD_TOKENS.has(token)).length;
  if (detailCount === 0 && tokens.length <= 4 && headCount >= 1) return true;
  return detailCount === 0 && genericCount >= Math.max(1, tokens.length - 1);
}

function _visionLabelSpecificityScore(raw) {
  const tokens = _visionLabelTokens(raw);
  if (!tokens.length) return 0;
  const uniqueCount = new Set(tokens).size;
  const detailCount = tokens.filter((token) => VISION_LABEL_DETAIL_TOKENS.has(token)).length;
  let score = 0;
  for (const token of tokens) {
    if (!VISION_LABEL_GENERIC_TOKENS.has(token)) score += 1;
    if (VISION_LABEL_DETAIL_TOKENS.has(token)) score += 1;
  }
  if (tokens.length >= 3 && tokens.length <= 6) score += 1;
  if (uniqueCount >= 3) score += 1;
  if (detailCount >= 2) score += 1;
  if (_isGenericVisionLabel(raw)) score -= 2;
  return Math.max(0, score);
}

function shouldPreferIncomingVisionLabel(existingRaw, incomingRaw) {
  const existing = _normalizeVisionLabel(existingRaw, { maxChars: 32 });
  const incoming = _normalizeVisionLabel(incomingRaw, { maxChars: 32 });
  if (!incoming) return false;
  if (!existing) return true;
  if (incoming === existing) return false;

  const existingGeneric = _isGenericVisionLabel(existing);
  const incomingGeneric = _isGenericVisionLabel(incoming);
  if (existingGeneric && !incomingGeneric) return true;
  if (!existingGeneric && incomingGeneric) return false;

  const existingNameTokens = _visionLabelNameTokenCount(existingRaw);
  const incomingNameTokens = _visionLabelNameTokenCount(incomingRaw);
  if (incomingNameTokens >= 2 && existingNameTokens < 2) return true;
  if (existingNameTokens >= 2 && incomingNameTokens < 2) return false;

  const existingScore = _visionLabelSpecificityScore(existing);
  const incomingScore = _visionLabelSpecificityScore(incoming);
  if (incomingNameTokens > existingNameTokens && incomingScore >= existingScore) return true;
  if (incomingScore > existingScore) return true;
  if (incomingScore < existingScore) return false;
  // Same score: prefer a slightly longer label only if it adds more lexical signal.
  return incoming.length >= existing.length + 6 && _visionLabelTokens(incoming).length >= _visionLabelTokens(existing).length + 1;
}

function shouldBackfillVisionLabel(raw) {
  const label = _normalizeVisionLabel(raw, { maxChars: 32 });
  // Keep fallback non-heuristic: only backfill when realtime provided no label.
  return !label;
}

function maybeScheduleVisionDescribeFallback(item, label) {
  if (!item?.path) return;
  if (!shouldBackfillVisionLabel(label)) return;
  const now = Date.now();
  const lastRequestedAt = Number(item.visionFallbackRequestedAt) || 0;
  if (now - lastRequestedAt < VISION_FALLBACK_REFRESH_MIN_MS) return;
  item.visionFallbackRequestedAt = now;
  scheduleVisionDescribe(item.path, { priority: true, fallback: true, refresh: true });
}

function maybeScheduleVisionDescribeFallbackForAmbientRealtime(ambient, imageDescs = []) {
  const seenIds = new Set();
  for (const rec of Array.isArray(imageDescs) ? imageDescs : []) {
    const id = rec?.image_id ? String(rec.image_id) : "";
    if (id) seenIds.add(id);
  }

  const candidates = [];
  const seenPaths = new Set();
  const addCandidate = (item) => {
    if (!item?.path) return;
    if (seenPaths.has(item.path)) return;
    if (seenIds.has(String(item.id || ""))) return;
    seenPaths.add(item.path);
    candidates.push(item);
  };

  if (ambient && Array.isArray(ambient.touchedImageIds)) {
    for (const rawId of ambient.touchedImageIds) {
      const id = String(rawId || "").trim();
      if (!id) continue;
      addCandidate(state.imagesById.get(id) || null);
    }
  }
  if (!candidates.length) {
    for (const item of getVisibleCanvasImages()) addCandidate(item);
  }

  for (const item of candidates) {
    if (!shouldBackfillVisionLabel(item?.visionDesc)) continue;
    maybeScheduleVisionDescribeFallback(item, item?.visionDesc || "");
  }
}

function extractIntentImageDescriptions(parsed) {
  if (!parsed || typeof parsed !== "object") return [];
  const raw = Array.isArray(parsed.image_descriptions) ? parsed.image_descriptions : [];
  const out = [];
  for (const item of raw) {
    if (!item || typeof item !== "object") continue;
    const imageId = item.image_id ? String(item.image_id) : item.id ? String(item.id) : "";
    const labelRaw = item.label ?? item.description ?? item.text ?? "";
    const label = _normalizeVisionLabel(labelRaw, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS });
    const confidence = typeof item.confidence === "number" ? item.confidence : null;
    if (!imageId || !label) continue;
    out.push({ image_id: imageId, label, confidence });
  }
  return out;
}

function primaryBranchIdFromIconState(iconState) {
  const branches = Array.isArray(iconState?.branches) ? iconState.branches : [];
  if (!branches.length) return null;
  const primaryIcons = new Set(
    (Array.isArray(iconState?.intent_icons) ? iconState.intent_icons : [])
      .filter((it) => String(it?.position_hint || "").toLowerCase() === "primary")
      .map((it) => String(it?.icon_id || "").trim())
      .filter(Boolean)
  );
  if (!primaryIcons.size) return String(branches[0]?.branch_id || "") || null;

  let best = null;
  let bestScore = -1;
  for (const b of branches) {
    const icons = Array.isArray(b?.icons) ? b.icons : [];
    let score = 0;
    for (const icon of icons) {
      if (primaryIcons.has(String(icon || "").trim())) score += 1;
    }
    if (score > bestScore) {
      bestScore = score;
      best = b;
    }
  }
  return best && best.branch_id ? String(best.branch_id) : String(branches[0]?.branch_id || "") || null;
}

function pickDefaultIntentFocusBranchId(iconState = null) {
  const intent = state.intent;
  const icon = iconState || intent?.iconState || null;
  const branches = Array.isArray(icon?.branches) ? icon.branches : [];
  const hasPrimaryCluster = Array.isArray(icon?.intent_icons) && icon.intent_icons.length > 0;

  const existing = intent?.focusBranchId ? String(intent.focusBranchId) : "";
  if (existing) {
    if (existing === "__primary__") {
      if (hasPrimaryCluster) return existing;
    }
    if (branches.some((b) => String(b?.branch_id || "") === existing)) return existing;
  }

  const primary = primaryBranchIdFromIconState(icon);
  if (primary) return primary;
  return "__primary__";
}

function latestIntentSelectionForBranch(branchId) {
  const bid = String(branchId || "");
  if (!bid) return null;
  const sels = Array.isArray(state.intent?.selections) ? state.intent.selections : [];
  let best = null;
  for (const sel of sels) {
    if (String(sel?.branch_id || "") !== bid) continue;
    const r = Number(sel?.round) || 0;
    if (!best || r > (Number(best.round) || 0)) best = sel;
  }
  return best;
}

function upsertIntentSelection({ round, branchId, tokenId }) {
  const intent = state.intent;
  if (!intent) return;
  const r = Math.max(1, Number(round) || 1);
  const bid = String(branchId || "");
  const tok = String(tokenId || "");
  if (!bid || !tok) return;
  const next = (Array.isArray(intent.selections) ? intent.selections : []).filter((sel) => Number(sel?.round) !== r);
  next.push({ round: r, branch_id: bid, token: tok });
  intent.selections = next;
}

const INTENT_BRANCH_TOKEN_STOPWORDS = new Set([
  "the",
  "and",
  "for",
  "with",
  "from",
  "that",
  "this",
  "mode",
  "branch",
  "image",
  "images",
  "icon",
  "icons",
  "intent",
  "token",
  "primary",
  "secondary",
  "left",
  "right",
  "lane",
  "position",
]);

function _intentBranchTokenScore(haystack, branch = null) {
  if (!haystack || !branch || typeof branch !== "object") return 0;
  const tokenSet = new Set();
  const branchKey = _normalizeIntentKey(branch.branch_id);
  if (branchKey) {
    for (const token of branchKey.split("_")) {
      const t = String(token || "").trim();
      if (!t || t.length < 3 || INTENT_BRANCH_TOKEN_STOPWORDS.has(t)) continue;
      tokenSet.add(t);
    }
  }
  const icons = Array.isArray(branch.icons) ? branch.icons : [];
  for (const iconId of icons) {
    const normalized = _normalizeIntentKey(iconId);
    if (!normalized) continue;
    for (const token of normalized.split("_")) {
      const t = String(token || "").trim();
      if (!t || t.length < 3 || INTENT_BRANCH_TOKEN_STOPWORDS.has(t)) continue;
      tokenSet.add(t);
    }
  }
  if (!tokenSet.size) return 0;
  let score = 0;
  for (const token of tokenSet) {
    if (!haystack.includes(token)) continue;
    score += token.length >= 6 ? 2 : 1;
  }
  return score;
}

function inferIntentBranchFromVisionDescriptions() {
  const items = Array.isArray(state.images) ? state.images : [];
  const texts = [];
  for (const item of items) {
    if (item?.visionDesc) texts.push(String(item.visionDesc));
  }
  const haystack = texts.join(" ").toLowerCase().trim();
  if (!haystack) return null;
  const branches = Array.isArray(state.intent?.iconState?.branches) ? state.intent.iconState.branches : [];
  if (!branches.length) return null;
  let bestBranchId = null;
  let bestScore = 0;
  for (const branch of branches) {
    const branchId = String(branch?.branch_id || "").trim();
    if (!branchId) continue;
    let s = _intentBranchTokenScore(haystack, branch);
    if (typeof branch?.confidence === "number" && Number.isFinite(branch.confidence)) {
      s += clamp(Number(branch.confidence), 0, 1) * 0.75;
    }
    if (s > bestScore) {
      bestScore = s;
      bestBranchId = branchId;
    }
  }
  // Require a little evidence before overriding icon-state suggestion.
  if (!bestBranchId || bestScore < 1.5) return null;
  return bestBranchId;
}

function _primaryBranchSuggestion(iconState) {
  const branches = Array.isArray(iconState?.branches) ? iconState.branches : [];
  if (!branches.length) return { branch_id: null, score: 0, ties: 0 };

  const primaryIcons = new Set(
    (Array.isArray(iconState?.intent_icons) ? iconState.intent_icons : [])
      .filter((it) => String(it?.position_hint || "").toLowerCase() === "primary")
      .map((it) => String(it?.icon_id || "").trim())
      .filter(Boolean)
  );
  if (!primaryIcons.size) return { branch_id: null, score: 0, ties: 0 };

  let bestId = null;
  let bestScore = 0;
  let ties = 0;
  for (const b of branches) {
    const bid = b?.branch_id ? String(b.branch_id) : "";
    if (!bid) continue;
    const icons = Array.isArray(b?.icons) ? b.icons : [];
    let score = 0;
    for (const icon of icons) {
      if (primaryIcons.has(String(icon || "").trim())) score += 1;
    }
    if (score > bestScore) {
      bestScore = score;
      bestId = bid;
      ties = score > 0 ? 1 : 0;
    } else if (score > 0 && score === bestScore) {
      ties += 1;
    }
  }
  if (!bestId || bestScore <= 0) return { branch_id: null, score: 0, ties: 0 };
  return { branch_id: bestId, score: bestScore, ties };
}

function _rankIntentBranches(iconState) {
  const branches = Array.isArray(iconState?.branches) ? iconState.branches : [];
  if (!branches.length) return [];
  const anyConf = branches.some((b) => typeof b?.confidence === "number" && Number.isFinite(b.confidence));
  if (!anyConf) return branches.slice();
  // Defensive: even though parseIntentIconsJson sorts, keep this stable if callers mutate iconState.
  const list = branches.map((b, idx) => ({ b, idx }));
  list.sort((a, b) => {
    const ac = typeof a?.b?.confidence === "number" && Number.isFinite(a.b.confidence) ? a.b.confidence : -1;
    const bc = typeof b?.b?.confidence === "number" && Number.isFinite(b.b.confidence) ? b.b.confidence : -1;
    if (bc !== ac) return bc - ac;
    return (Number(a.idx) || 0) - (Number(b.idx) || 0);
  });
  return list.map((it) => it.b);
}

function pickSuggestedIntentBranch(iconState = null) {
  const intent = state.intent;
  const icon = iconState || intent?.iconState || null;
  const branches = Array.isArray(icon?.branches) ? icon.branches : [];
  if (!branches.length) return { branch_id: null, reason: "none", ranked_branch_ids: [] };

  const isRejected = (bid) => {
    const sel = latestIntentSelectionForBranch(bid);
    const tok = sel?.token ? String(sel.token).trim().toUpperCase() : "";
    return tok === "NO_TOKEN";
  };

  const hasBranch = (bid) => branches.some((b) => String(b?.branch_id || "") === bid);
  const findBranchInsensitive = (raw) => {
    const wanted = String(raw || "").trim();
    if (!wanted) return "";
    const exact = branches.find((b) => String(b?.branch_id || "") === wanted);
    if (exact?.branch_id) return String(exact.branch_id);
    const lower = wanted.toLowerCase();
    const match = branches.find((b) => String(b?.branch_id || "").toLowerCase() === lower);
    return match?.branch_id ? String(match.branch_id) : "";
  };

  const rankedBranches = _rankIntentBranches(icon);
  const rankedIds = rankedBranches
    .map((b) => (b?.branch_id ? String(b.branch_id) : ""))
    .filter(Boolean);

  // If the model provided an explicit checkpoint target, treat it as the active suggestion.
  const checkpoint = icon?.checkpoint?.applies_to;
  const checkpointBid = findBranchInsensitive(checkpoint);
  if (checkpointBid && !isRejected(checkpointBid)) {
    return {
      branch_id: checkpointBid,
      reason: "checkpoint",
      ranked_branch_ids: rankedIds,
      checkpoint_branch_id: checkpointBid,
    };
  }

  const anyConf = rankedBranches.some((b) => typeof b?.confidence === "number" && Number.isFinite(b.confidence));
  if (anyConf) {
    for (const b of rankedBranches) {
      const bid = b?.branch_id ? String(b.branch_id) : "";
      if (!bid) continue;
      if (isRejected(bid)) continue;
      return { branch_id: bid, reason: "confidence", ranked_branch_ids: rankedIds, checkpoint_branch_id: checkpointBid || null };
    }
  }

  const primaryInfo = _primaryBranchSuggestion(icon);
  const p = primaryInfo?.branch_id ? String(primaryInfo.branch_id) : "";

  // Use per-image vision descriptions (derived from images) as a tie-breaker or fallback hint.
  const hint = inferIntentBranchFromVisionDescriptions();
  if (hint && hasBranch(hint) && !isRejected(hint)) {
    const primaryRejected = p ? isRejected(p) : true;
    const primaryWeak = (Number(primaryInfo?.score) || 0) <= 1;
    const primaryTied = (Number(primaryInfo?.ties) || 0) > 1;
    if (primaryRejected || primaryWeak || primaryTied) {
      return { branch_id: hint, reason: "vision_hint", ranked_branch_ids: rankedIds, checkpoint_branch_id: checkpointBid || null };
    }
  }

  if (p && hasBranch(p) && !isRejected(p)) {
    return { branch_id: p, reason: "primary_cluster", ranked_branch_ids: rankedIds, checkpoint_branch_id: checkpointBid || null };
  }

  for (const b of rankedBranches) {
    const bid = b?.branch_id ? String(b.branch_id) : "";
    if (!bid) continue;
    if (isRejected(bid)) continue;
    return { branch_id: bid, reason: "first_unrejected", ranked_branch_ids: rankedIds, checkpoint_branch_id: checkpointBid || null };
  }

  // If every branch has been rejected, fall back to the primary (if present) so START remains usable.
  if (p && hasBranch(p)) return { branch_id: p, reason: "all_rejected_primary", ranked_branch_ids: rankedIds, checkpoint_branch_id: checkpointBid || null };
  const first = rankedBranches[0]?.branch_id ? String(rankedBranches[0].branch_id) : "";
  return { branch_id: first || null, reason: "all_rejected_first", ranked_branch_ids: rankedIds, checkpoint_branch_id: checkpointBid || null };
}

function pickSuggestedIntentBranchId(iconState = null) {
  const picked = pickSuggestedIntentBranch(iconState);
  const bid = picked?.branch_id ? String(picked.branch_id) : "";
  return bid || null;
}

function lockIntentFromUi({ source = "ui" } = {}) {
  const intent = state.intent;
  if (!intent || intent.locked) return;

  const iconState = ensureIntentFallbackIconState("lock");
  if (!iconState) return;

  let bid = String(pickSuggestedIntentBranchId(iconState) || "").trim();
  if (bid === "__primary__") bid = "";
  if (!bid) bid = String(primaryBranchIdFromIconState(iconState) || "").trim();
  if (!bid) bid = String(pickDefaultIntentFocusBranchId(iconState) || "").trim();
  if (!bid) return;

  appendIntentTrace({
    kind: "ui_accept",
    source: source ? String(source) : "ui",
    round: Math.max(1, Number(intent.round) || 1),
    branch_id: bid,
    icon_frame_id: iconState?.frame_id ? String(iconState.frame_id) : null,
  }).catch(() => {});

  // Persist the user's final choice as a YES on the current round for debugging/replay.
  const round = Math.max(1, Number(intent.round) || 1);
  upsertIntentSelection({ round, branchId: bid, tokenId: "YES_TOKEN" });
  intent.focusBranchId = bid;
  intent.uiHideSuggestion = false;
  scheduleIntentStateWrite({ immediate: true });
  lockIntentToBranch(bid).catch((err) => console.error(err));
}

function applyIntentSelection(branchId, tokenId) {
  const intent = state.intent;
  if (!intent || intent.locked) return;
  const bid = String(branchId || intent.focusBranchId || pickSuggestedIntentBranchId(intent.iconState) || "").trim();
  if (!bid) return;
  const tok = String(tokenId || "")
    .trim()
    .toUpperCase();
  if (!tok) return;

  // Prevent users from spamming feedback while a new model frame is in flight.
  if (intent.pending || intentInferenceTimer) {
    showToast("Intent updatingâ€¦", "tip", 1600);
    return;
  }

  const round = Math.max(1, Number(intent.round) || 1);
  if (tok === "YES_TOKEN") {
    lockIntentFromUi({ source: "yes_token" });
    return;
  }

  if (tok !== "NO_TOKEN") return;

  // NO: hide the current suggestion and load another candidate.
  upsertIntentSelection({ round, branchId: bid, tokenId: "NO_TOKEN" });
  intent.focusBranchId = null;
  intent.uiHideSuggestion = true;
  intent.pending = true;
  intent.pendingAt = Date.now();
  intent.round = round + 1;
  appendIntentTrace({
    kind: "ui_reject",
    source: "no_token",
    round,
    branch_id: bid,
    icon_frame_id: intent.iconState?.frame_id ? String(intent.iconState.frame_id) : null,
  }).catch(() => {});
  scheduleIntentStateWrite({ immediate: true });
  scheduleIntentInference({ immediate: true, reason: "reject" });
  requestRender();
}

async function lockIntentToBranch(branchId) {
  const intent = state.intent;
  if (!intent || intent.locked) return false;
  await ensureRun();

  intent.locked = true;
  intent.lockedAt = Date.now();
  intent.lockedBranchId = String(branchId || intent.focusBranchId || "") || null;
  intent.forceChoice = false;
  intent.pending = false;
  intent.pendingPath = null;
  intent.pendingAt = 0;
  intent.pendingFrameId = null;

  appendIntentTrace({
    kind: "intent_locked",
    branch_id: intent.lockedBranchId ? String(intent.lockedBranchId) : null,
    round: Math.max(1, Number(intent.round) || 1),
    selection_count: Array.isArray(intent.selections) ? intent.selections.length : 0,
    icon_frame_id: intent.iconState?.frame_id ? String(intent.iconState.frame_id) : null,
  }).catch(() => {});

  // Stop realtime session (best-effort).
  clearTimeout(intentInferenceTimer);
  intentInferenceTimer = null;
  clearTimeout(intentInferenceTimeout);
  intentInferenceTimeout = null;
  stopIntentTicker();
  intent.rtState = "off";
  intent.disabledReason = null;
  if (state.ptySpawned) {
    invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_STOP}\n` }).catch(() => {});
  }

  // Persist locked intent as a run artifact for downstream prompting/recommendations.
  const lockedPayload = {
    schema: "brood.intent_locked",
    schema_version: 1,
    locked_at_ms: Number(intent.lockedAt) || 0,
    locked_branch_id: intent.lockedBranchId,
    started_at_ms: Number(intent.startedAt) || 0,
    deadline_at_ms: INTENT_TIMER_ENABLED ? Number(intent.deadlineAt) || 0 : 0,
    round: Math.max(1, Number(intent.round) || 1),
    total_rounds: INTENT_ROUNDS_ENABLED ? Math.max(1, Number(intent.totalRounds) || 3) : 0,
    focus_branch_id: intent.focusBranchId ? String(intent.focusBranchId) : null,
    selections: Array.isArray(intent.selections) ? intent.selections : [],
    icon_state: intent.iconState || null,
    icon_state_at_ms: Number(intent.iconStateAt) || 0,
  };
  const outPath = `${state.runDir}/${INTENT_LOCKED_FILENAME}`;
  await writeTextFile(outPath, JSON.stringify(lockedPayload, null, 2)).catch(() => {});
  scheduleIntentStateWrite({ immediate: true });

  // Reveal the normal UI.
  syncIntentModeClass();
  updateEmptyCanvasHint();
  renderQuickActions();
  renderHudReadout();
  requestRender();
  showToast("Intent locked.", "tip", 1800);
  return true;
}

let thumbObserver = null;
function ensureThumbObserver() {
  if (thumbObserver) return;
  if (!("IntersectionObserver" in window)) return;
  thumbObserver = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;
        const imgEl = entry.target;
        const path = imgEl?.dataset?.path;
        if (!path) continue;
        thumbObserver.unobserve(imgEl);
        ensureImageUrl(path)
          .then((url) => {
            if (url) imgEl.src = url;
          })
          .catch(() => {});
      }
    },
    { root: els.filmstrip || null, rootMargin: "220px" }
  );
}

function getOrCreateImageCacheRecord(path, cache = state.imageCache) {
  const existing = cache.get(path);
  if (existing) return existing;
  const rec = { url: null, urlPromise: null, imgPromise: null };
  cache.set(path, rec);
  return rec;
}

async function ensureImageUrl(path, cache = state.imageCache) {
  if (!path) return null;
  const rec = getOrCreateImageCacheRecord(path, cache);
  if (rec.url) return rec.url;
  if (rec.urlPromise) return await rec.urlPromise;
  rec.urlPromise = (async () => {
    const data = await readBinaryFile(path);
    const blob = new Blob([data], { type: mimeFromPath(path) });
    const url = URL.createObjectURL(blob);
    rec.url = url;
    return url;
  })();
  try {
    return await rec.urlPromise;
  } catch (err) {
    rec.urlPromise = null;
    throw err;
  }
}

function isBrowserImagePath(path) {
  const ext = extname(path).toLowerCase();
  return FILE_BROWSER_IMAGE_EXTS.has(ext);
}

function fileBrowserIsSuppressedArtifactName(name) {
  const lowered = String(name || "").trim().toLowerCase();
  if (!lowered) return false;
  if (lowered === "_raw_provider_outputs") return true;
  if (lowered === "manifest.json") return true;
  if (/^contact_sheet(?:_.*)?\.(png|jpg|jpeg|webp)$/i.test(lowered)) return true;
  return false;
}

function parentDirPath(path) {
  const raw = String(path || "").trim();
  if (!raw) return null;
  const trimmed = raw.replace(/[\\/]+$/, "");
  if (!trimmed) return null;
  if (trimmed === "/" || trimmed === "\\") return null;
  const slashIdx = Math.max(trimmed.lastIndexOf("/"), trimmed.lastIndexOf("\\"));
  if (slashIdx < 0) return null;
  if (slashIdx === 0) return trimmed.slice(0, 1);
  if (slashIdx === 2 && /^[A-Za-z]:/.test(trimmed)) return `${trimmed.slice(0, 2)}\\`;
  return trimmed.slice(0, slashIdx);
}

function fileBrowserDisplayPathLabel({ cwd = "", rootDir = "" } = {}) {
  const current = String(cwd || "").trim();
  const root = String(rootDir || "").trim();
  const fallback = current || root;
  if (!fallback) return "No folder selected";
  const normalizedCurrent = current.replace(/[\\/]+$/, "");
  const normalizedRoot = root.replace(/[\\/]+$/, "");
  const leaf = basename(normalizedCurrent || normalizedRoot) || fallback;
  if (!normalizedCurrent || !normalizedRoot || normalizedCurrent === normalizedRoot) {
    return leaf;
  }
  const rootLeaf = basename(normalizedRoot) || normalizedRoot;
  if (normalizedCurrent.startsWith(normalizedRoot)) {
    const relative = normalizedCurrent.slice(normalizedRoot.length).replace(/^[\\/]+/, "");
    const parts = relative.split(/[\\/]+/).filter(Boolean);
    if (parts.length === 1) return `${rootLeaf}/${parts[0]}`;
    if (parts.length > 1) return `${rootLeaf}/.../${parts[parts.length - 1]}`;
  }
  return `${rootLeaf}/.../${leaf}`;
}

function normalizeLocalFsPath(rawPath) {
  let path = String(rawPath || "").trim();
  if (!path) return "";
  if (path.startsWith("file://")) {
    try {
      const u = new URL(path);
      path = decodeURIComponent(u.pathname || "");
      if (/^\/[A-Za-z]:\//.test(path)) {
        path = path.slice(1);
      }
    } catch {
      path = path.replace(/^file:\/\//i, "");
      try {
        path = decodeURIComponent(path);
      } catch {
        // ignore
      }
    }
  }
  return path;
}

function isAbsoluteLocalFsPath(path) {
  const target = String(path || "").trim();
  if (!target) return false;
  if (target.startsWith("/") || target.startsWith("\\")) return true;
  return /^[A-Za-z]:[\\/]/.test(target);
}

async function resolveLocalFsPathMaybeRelative(baseDir, rawPath) {
  const target = normalizeLocalFsPath(rawPath);
  if (!target) return "";
  if (isAbsoluteLocalFsPath(target)) return target;
  const base = String(baseDir || "").trim();
  if (!base) return "";
  try {
    return normalizeLocalFsPath(await join(base, target));
  } catch {
    return "";
  }
}

async function fileBrowserLoadImportPathMap(dir) {
  const targetDir = String(dir || "").trim();
  const out = new Map();
  if (!targetDir) return out;
  const manifestCandidates = [];
  try {
    manifestCandidates.push(await join(targetDir, "manifest.json"));
  } catch {
    manifestCandidates.push(`${targetDir}/manifest.json`);
  }
  const parent = parentDirPath(targetDir);
  if (parent) {
    try {
      manifestCandidates.push(await join(parent, "manifest.json"));
    } catch {
      manifestCandidates.push(`${parent}/manifest.json`);
    }
  }
  let payload = null;
  for (const candidate of manifestCandidates) {
    if (!candidate) continue;
    try {
      payload = JSON.parse(await readTextFile(candidate));
      if (payload && typeof payload === "object") break;
    } catch {
      payload = null;
    }
  }
  if (!payload || typeof payload !== "object") {
    return out;
  }
  const items = Array.isArray(payload?.items) ? payload.items : [];
  for (const item of items) {
    if (!item || typeof item !== "object") continue;
    const rawOutput =
      item.output ??
      item.preview ??
      item.rendered ??
      item.styled ??
      item.preview_path ??
      item.path ??
      "";
    const rawInput =
      item.input ??
      item.source ??
      item.original ??
      item.source_path ??
      item.input_path ??
      item.original_path ??
      "";
    const outputPath = await resolveLocalFsPathMaybeRelative(targetDir, rawOutput);
    const inputPath = await resolveLocalFsPathMaybeRelative(targetDir, rawInput);
    if (!outputPath || !inputPath) continue;
    if (!isBrowserImagePath(outputPath) || !isBrowserImagePath(inputPath)) continue;
    out.set(outputPath, inputPath);
    const outputKey = fileBrowserPathMapKey(outputPath);
    if (outputKey) out.set(outputKey, inputPath);
    const outBase = basename(outputPath);
    if (outBase) out.set(`name:${outBase}`, inputPath);
    if (outBase) out.set(`name:${outBase.toLowerCase()}`, inputPath);
    const outStem = outBase.replace(/\.[^.]+$/, "");
    if (outStem) out.set(`stem:${outStem}`, inputPath);
    if (outStem) out.set(`stem:${outStem.toLowerCase()}`, inputPath);
    const relaxedStem = outStem.replace(/_wire_subject(?:-\d+)?$/i, "");
    if (relaxedStem && relaxedStem !== outStem) out.set(`stem:${relaxedStem}`, inputPath);
    if (relaxedStem && relaxedStem !== outStem) out.set(`stem:${relaxedStem.toLowerCase()}`, inputPath);
  }
  return out;
}

function canvasWorldPointFromClient(clientX, clientY) {
  const cx = Number(clientX);
  const cy = Number(clientY);
  if (!Number.isFinite(cx) || !Number.isFinite(cy)) return null;
  const wrapRect = els.canvasWrap?.getBoundingClientRect?.();
  if (!wrapRect) return null;
  if (cx < wrapRect.left || cx > wrapRect.right || cy < wrapRect.top || cy > wrapRect.bottom) return null;
  const overlayRect = els.overlayCanvas?.getBoundingClientRect?.() || wrapRect;
  return canvasScreenCssToWorldCss({ x: cx - overlayRect.left, y: cy - overlayRect.top });
}

function fileBrowserCreateDragGhost(path) {
  const targetPath = String(path || "").trim();
  if (!targetPath) return null;
  const ghost = document.createElement("div");
  ghost.className = "file-browser-drag-ghost";
  ghost.setAttribute("aria-hidden", "true");
  ghost.dataset.path = targetPath;
  const thumb = document.createElement("img");
  thumb.className = "file-browser-drag-ghost-thumb";
  thumb.alt = "";
  thumb.src = THUMB_PLACEHOLDER_SRC;
  ghost.appendChild(thumb);
  const label = document.createElement("div");
  label.className = "file-browser-drag-ghost-label";
  const base = basename(targetPath) || "image";
  label.textContent = base.length > 20 ? `${base.slice(0, 19)}â€¦` : base;
  ghost.appendChild(label);
  document.body.appendChild(ghost);
  const cache = state.fileBrowser?.thumbCache || state.imageCache;
  ensureImageUrl(targetPath, cache)
    .then((url) => {
      if (!url || !ghost.isConnected) return;
      thumb.src = url;
    })
    .catch(() => {});
  return ghost;
}

function fileBrowserUpdateDragGhost(el, clientX, clientY) {
  if (!el) return;
  const cx = Number(clientX);
  const cy = Number(clientY);
  if (!Number.isFinite(cx) || !Number.isFinite(cy)) return;
  el.classList.remove("is-drop");
  el.style.transition = "none";
  el.style.opacity = "0.98";
  el.style.filter = "";
  el.style.left = `${Math.round(cx)}px`;
  el.style.top = `${Math.round(cy)}px`;
  el.style.transform = "translate3d(-34%, -76%, 0) scale(0.84)";
}

function fileBrowserDestroyDragGhost(el) {
  if (!el) return;
  try {
    el.remove();
  } catch {
    // ignore
  }
}

function fileBrowserAnimateDropPulse(clientX, clientY) {
  if (!els.canvasWrap) return;
  const cx = Number(clientX);
  const cy = Number(clientY);
  if (!Number.isFinite(cx) || !Number.isFinite(cy)) return;
  const wrapRect = els.canvasWrap.getBoundingClientRect();
  if (!wrapRect) return;
  if (cx < wrapRect.left || cx > wrapRect.right || cy < wrapRect.top || cy > wrapRect.bottom) return;
  const pulse = document.createElement("div");
  pulse.className = "file-browser-drop-pulse";
  pulse.style.left = `${Math.round(cx - wrapRect.left)}px`;
  pulse.style.top = `${Math.round(cy - wrapRect.top)}px`;
  els.canvasWrap.appendChild(pulse);
  requestAnimationFrame(() => {
    pulse.classList.add("is-live");
  });
  setTimeout(() => {
    try {
      pulse.remove();
    } catch {
      // ignore
    }
  }, 420);
}

function fileBrowserAnimateDropGhost(ghostEl, { clientX, clientY, path = "" } = {}) {
  const cx = Number(clientX);
  const cy = Number(clientY);
  if (!Number.isFinite(cx) || !Number.isFinite(cy)) {
    if (ghostEl) fileBrowserDestroyDragGhost(ghostEl);
    return;
  }
  const ghost = ghostEl || fileBrowserCreateDragGhost(path);
  fileBrowserAnimateDropPulse(cx, cy);
  if (!ghost) return;
  ghost.classList.add("is-drop");
  ghost.style.left = `${Math.round(cx)}px`;
  ghost.style.top = `${Math.round(cy)}px`;
  ghost.style.opacity = "1";
  ghost.style.filter = "";
  ghost.style.transition =
    "transform 220ms cubic-bezier(0.22, 1, 0.36, 1), opacity 220ms ease-out, filter 220ms ease-out";
  requestAnimationFrame(() => {
    if (!ghost.isConnected) return;
    ghost.style.transform = "translate3d(-50%, -50%, 0) scale(2.08)";
    ghost.style.opacity = "0";
    ghost.style.filter = "saturate(1.2) brightness(1.12)";
  });
  const cleanup = () => fileBrowserDestroyDragGhost(ghost);
  ghost.addEventListener("transitionend", cleanup, { once: true });
  setTimeout(cleanup, 320);
}

function clearFileBrowserThumbCache({ keepPaths = null } = {}) {
  const fb = state.fileBrowser;
  if (!fb?.thumbCache) return;
  const keep = keepPaths instanceof Set ? keepPaths : null;
  for (const [path, rec] of fb.thumbCache.entries()) {
    if (keep && keep.has(path)) continue;
    const url = rec?.url;
    if (url) {
      try {
        URL.revokeObjectURL(url);
      } catch {
        // ignore
      }
    }
    fb.thumbCache.delete(path);
  }
}

function fileBrowserRenderMessage(message, { isError = false } = {}) {
  if (!els.fileBrowserList) return;
  const div = document.createElement("div");
  div.className = `file-browser-message${isError ? " is-error" : ""}`;
  div.textContent = String(message || "");
  els.fileBrowserList.innerHTML = "";
  els.fileBrowserList.appendChild(div);
}

function ensureFileBrowserObserver() {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return null;
  if (!els.fileBrowserList) return null;
  if (fb.observer) return fb.observer;
  if (!("IntersectionObserver" in window)) return null;
  fb.observer = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;
        const imgEl = entry.target;
        const path = imgEl?.dataset?.path ? String(imgEl.dataset.path) : "";
        if (!path) continue;
        fb.observer.unobserve(imgEl);
        ensureImageUrl(path, fb.thumbCache)
          .then((url) => {
            if (url && imgEl && imgEl.dataset.path === path) imgEl.src = url;
          })
          .catch(() => {});
      }
    },
    { root: els.fileBrowserList, rootMargin: "140px" }
  );
  return fb.observer;
}

function fileBrowserSetSelectedPath(path) {
  const fb = state.fileBrowser;
  if (!fb) return;
  fb.selectedPath = path ? String(path) : null;
  if (!els.fileBrowserList) return;
  const rows = els.fileBrowserList.querySelectorAll(".file-browser-item");
  rows.forEach((row) => {
    const rowPath = String(row?.dataset?.path || "");
    const selected = Boolean(fb.selectedPath && rowPath && rowPath === fb.selectedPath);
    row.classList.toggle("is-selected", selected);
    row.setAttribute("aria-selected", selected ? "true" : "false");
  });
}

function fileBrowserEntriesForUi() {
  const fb = state.fileBrowser;
  if (!fb) return [];
  const list = Array.isArray(fb.entries) ? fb.entries : [];
  return list.slice(0, 550);
}

function renderFileBrowserDock() {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return;
  if (!els.fileBrowserDock || !els.fileBrowserList) return;

  if (els.fileBrowserPath) {
    const fullPath = String(fb.cwd || fb.rootDir || "").trim();
    els.fileBrowserPath.textContent = fileBrowserDisplayPathLabel({ cwd: fb.cwd, rootDir: fb.rootDir });
    els.fileBrowserPath.title = fullPath || "No folder selected";
  }
  if (els.fileBrowserUp) {
    els.fileBrowserUp.disabled = Boolean(!fb.cwd || !parentDirPath(fb.cwd));
  }
  if (els.fileBrowserRefresh) {
    els.fileBrowserRefresh.disabled = Boolean(!fb.cwd || fb.loading);
  }
  if (els.fileBrowserChoose) {
    els.fileBrowserChoose.disabled = Boolean(fb.loading);
  }

  if (!fb.cwd) {
    fileBrowserRenderMessage("Choose Folder to browse local images.");
    return;
  }
  if (fb.loading) {
    fileBrowserRenderMessage("Loading folderâ€¦");
    return;
  }
  if (fb.error) {
    fileBrowserRenderMessage(String(fb.error || "Unable to read folder."), { isError: true });
    return;
  }

  const entries = fileBrowserEntriesForUi();
  if (!entries.length) {
    fileBrowserRenderMessage("No image files found in this folder.");
    return;
  }

  const observer = ensureFileBrowserObserver();
  const frag = document.createDocumentFragment();
  for (const entry of entries) {
    const row = document.createElement("div");
    row.className = "file-browser-item";
    row.dataset.path = entry.path;
    row.dataset.kind = entry.kind;
    if (entry.kind === "file") {
      row.dataset.importPath = String(entry.importPath || entry.path || "");
    }
    row.setAttribute("role", "option");
    row.setAttribute("aria-selected", "false");

    const thumb = document.createElement(entry.kind === "file" ? "img" : "div");
    thumb.className = "file-browser-thumb";
    if (entry.kind === "file") {
      thumb.alt = "";
      thumb.src = THUMB_PLACEHOLDER_SRC;
      thumb.dataset.path = entry.path;
      if (observer) observer.observe(thumb);
      else {
        ensureImageUrl(entry.path, fb.thumbCache)
          .then((url) => {
            if (url) thumb.src = url;
          })
          .catch(() => {});
      }
    }

    const name = document.createElement("div");
    name.className = "file-browser-name";
    name.textContent = entry.name;
    if (entry.kind === "file" && entry.importPath && entry.importPath !== entry.path) {
      name.title = `${entry.path}\nimports: ${entry.importPath}`;
    } else {
      name.title = entry.path;
    }

    row.appendChild(thumb);
    row.appendChild(name);
    frag.appendChild(row);
  }
  els.fileBrowserList.innerHTML = "";
  els.fileBrowserList.appendChild(frag);
  fileBrowserSetSelectedPath(fb.selectedPath);
}

async function fileBrowserResolveEntryKind(entry, path) {
  const target = String(path || "").trim();
  if (!target) return "other";
  if (/[\\/]$/.test(target)) return "dir";
  if (entry && typeof entry === "object" && Object.prototype.hasOwnProperty.call(entry, "children")) {
    if (Array.isArray(entry.children)) return "dir";
    if (entry.children === null) return "file";
  }
  try {
    await readDir(target, { recursive: false });
    return "dir";
  } catch {
    return "file";
  }
}

async function normalizeFileBrowserEntries(rawEntries, { importPathMap = null } = {}) {
  const dirs = [];
  const files = [];
  const entries = await Promise.all(
    (Array.isArray(rawEntries) ? rawEntries : []).map(async (entry) => {
      const path = entry?.path ? String(entry.path).trim() : "";
      if (!path) return null;
      const name = String(entry?.name || basename(path) || path).trim();
      if (!name || name.startsWith(".")) return null;
      if (fileBrowserIsSuppressedArtifactName(name)) return null;
      const resolvedKind = await fileBrowserResolveEntryKind(entry, path);
      if (resolvedKind === "dir") return { name, path, kind: "dir" };
      const ext = extname(path).toLowerCase();
      if (!FILE_BROWSER_IMAGE_EXTS.has(ext)) return null;
      let mappedImportPath = "";
      if (importPathMap instanceof Map) {
        mappedImportPath = normalizeLocalFsPath(importPathMap.get(path) || "");
        if (!mappedImportPath) {
          mappedImportPath = normalizeLocalFsPath(importPathMap.get(`name:${basename(path)}`) || "");
        }
        if (!mappedImportPath) {
          const stem = basename(path).replace(/\.[^.]+$/, "");
          mappedImportPath = normalizeLocalFsPath(importPathMap.get(`stem:${stem}`) || "");
        }
        if (!mappedImportPath) {
          const relaxed = basename(path).replace(/\.[^.]+$/, "").replace(/_wire_subject(?:-\d+)?$/i, "");
          if (relaxed) mappedImportPath = normalizeLocalFsPath(importPathMap.get(`stem:${relaxed}`) || "");
        }
      }
      const importPath = mappedImportPath && isBrowserImagePath(mappedImportPath) ? mappedImportPath : path;
      return { name, path, importPath, kind: "file", ext };
    })
  );
  for (const entry of entries) {
    if (!entry) continue;
    if (entry.kind === "dir") dirs.push(entry);
    else if (entry.kind === "file") files.push(entry);
  }
  dirs.sort((a, b) => a.name.localeCompare(b.name));
  files.sort((a, b) => a.name.localeCompare(b.name));
  return [...dirs, ...files];
}

async function fileBrowserLoadDir(dir, { pushHistory = true } = {}) {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return;
  const target = String(dir || "").trim();
  if (!target) return;
  const seq = (Number(fb.loadSeq) || 0) + 1;
  fb.loadSeq = seq;
  fb.loading = true;
  fb.error = null;
  if (pushHistory && fb.cwd && fb.cwd !== target) {
    fb.history.push(fb.cwd);
    if (fb.history.length > 80) fb.history.shift();
  }
  fb.cwd = target;
  renderFileBrowserDock();
  let entries = [];
  try {
    entries = await readDir(target, { recursive: false });
  } catch (err) {
    if (fb.loadSeq !== seq) return;
    fb.loading = false;
    fb.error = err?.message ? `File browser: ${err.message}` : "File browser: cannot read folder";
    fb.entries = [];
    fb.importPathMap = new Map();
    renderFileBrowserDock();
    return;
  }
  if (fb.loadSeq !== seq) return;
  let importPathMap = null;
  try {
    importPathMap = await fileBrowserLoadImportPathMap(target);
  } catch {
    importPathMap = null;
  }
  const normalized = await normalizeFileBrowserEntries(entries, { importPathMap });
  if (fb.loadSeq !== seq) return;
  fb.importPathMap = importPathMap instanceof Map ? importPathMap : new Map();
  const keepThumbs = new Set(normalized.filter((it) => it.kind === "file").map((it) => it.path));
  clearFileBrowserThumbCache({ keepPaths: keepThumbs });
  fb.entries = normalized;
  fb.loading = false;
  fb.error = null;
  if (fb.selectedPath && !fb.entries.some((it) => it.path === fb.selectedPath)) {
    fb.selectedPath = null;
  }
  renderFileBrowserDock();
}

async function fileBrowserPickFolder() {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return;
  bumpInteraction();
  const picked = await open({ directory: true, multiple: false });
  const dir = Array.isArray(picked) ? picked[0] : picked;
  if (!dir) return;
  const root = String(dir).trim();
  fb.rootDir = root || null;
  localStorage.setItem(FILE_BROWSER_ROOT_DIR_LS_KEY, root);
  await fileBrowserLoadDir(root, { pushHistory: false });
}

async function fileBrowserRefresh() {
  const fb = state.fileBrowser;
  if (!fb?.enabled || !fb.cwd) return;
  await fileBrowserLoadDir(fb.cwd, { pushHistory: false });
}

async function fileBrowserNavigateTo(path) {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return;
  const target = String(path || "").trim();
  if (!target) return;
  await fileBrowserLoadDir(target);
}

async function fileBrowserNavigateUp() {
  const fb = state.fileBrowser;
  if (!fb?.enabled || !fb.cwd) return;
  const parent = parentDirPath(fb.cwd);
  if (!parent) return;
  await fileBrowserNavigateTo(parent);
}

async function fileBrowserImportPath(path, { focus = false } = {}) {
  const src = String(path || "").trim();
  if (!src || !isBrowserImagePath(src)) return;
  const center = canvasScreenCssToWorldCss(_defaultImportPointCss());
  await importLocalPathsAtCanvasPoint([src], center, {
    source: "browser",
    focusImported: focus,
    idPrefix: "dock",
  });
}

function fileBrowserCancelPendingClickImport() {
  const fb = state.fileBrowser;
  if (!fb) return;
  clearTimeout(fb.clickImportTimer);
  fb.clickImportTimer = null;
}

function fileBrowserScheduleClickImport(path) {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return;
  fileBrowserCancelPendingClickImport();
  const target = String(path || "").trim();
  if (!target) return;
  fb.clickImportTimer = setTimeout(() => {
    fb.clickImportTimer = null;
    fileBrowserImportPath(target, { focus: false }).catch((err) => console.error(err));
  }, 210);
}

function fileBrowserSetDragPath(path) {
  const fb = state.fileBrowser;
  if (!fb) return;
  clearTimeout(fb.dragClearTimer);
  fb.dragClearTimer = null;
  fb.draggingPath = path ? String(path) : null;
}

function fileBrowserImportPathForEntry(entry) {
  const mapped = normalizeLocalFsPath(String(entry?.importPath || ""));
  if (mapped && isBrowserImagePath(mapped)) return mapped;
  const plain = normalizeLocalFsPath(String(entry?.path || ""));
  if (plain && isBrowserImagePath(plain)) return plain;
  return "";
}

function fileBrowserImportPathForRow(row) {
  if (!row) return "";
  return fileBrowserImportPathForEntry({
    path: String(row.dataset?.path || ""),
    importPath: String(row.dataset?.importPath || ""),
  });
}

function fileBrowserPathMapKey(path) {
  const target = normalizeLocalFsPath(path);
  if (!target) return "";
  return target.replace(/\\/g, "/").normalize("NFC");
}

function fileBrowserResolveMappedPath(path, map = null) {
  const target = normalizeLocalFsPath(path);
  if (!target || !isBrowserImagePath(target)) return "";
  const candidateMap =
    map instanceof Map
      ? map
      : state.fileBrowser?.importPathMap instanceof Map
        ? state.fileBrowser.importPathMap
        : null;
  if (!(candidateMap instanceof Map) || candidateMap.size <= 0) return target;
  const targetKey = fileBrowserPathMapKey(target);
  const name = basename(target);
  const stem = name.replace(/\.[^.]+$/, "");
  const relaxed = stem.replace(/_wire_subject(?:-\d+)?$/i, "");
  const candidates = [target, targetKey, `name:${name}`, `name:${name.toLowerCase()}`, `stem:${stem}`, `stem:${stem.toLowerCase()}`];
  if (relaxed && relaxed !== stem) candidates.push(`stem:${relaxed}`);
  if (relaxed && relaxed !== stem) candidates.push(`stem:${relaxed.toLowerCase()}`);
  for (const key of candidates) {
    const mapped = normalizeLocalFsPath(candidateMap.get(key) || "");
    if (mapped && isBrowserImagePath(mapped)) return mapped;
  }
  return target;
}

async function fileBrowserDeriveOriginalForWirePath(path) {
  const target = normalizeLocalFsPath(path);
  if (!target || !/_wire_subject(?:-\d+)?\.[^.]+$/i.test(target)) return "";
  const outDir = parentDirPath(target);
  const rootDir = outDir ? parentDirPath(outDir) : null;
  if (!rootDir) return "";
  const stem = basename(target).replace(/\.[^.]+$/, "").replace(/_wire_subject(?:-\d+)?$/i, "");
  if (!stem) return "";
  const imageExts = [".png", ".jpg", ".jpeg", ".webp", ".heic", ".bmp", ".tif", ".tiff"];
  const imagesDir = await join(rootDir, "images").catch(() => "");
  if (!imagesDir) return "";
  for (const ext of imageExts) {
    const candidate = await join(imagesDir, `${stem}${ext}`).catch(() => "");
    if (!candidate) continue;
    const ok = await exists(candidate).catch(() => false);
    if (ok) return normalizeLocalFsPath(candidate);
  }
  return "";
}

async function fileBrowserResolveImportPaths(paths) {
  const list = (Array.isArray(paths) ? paths : [paths]).map((p) => normalizeLocalFsPath(p)).filter(Boolean);
  if (!list.length) return [];
  const fb = state.fileBrowser;
  let activeMap = fb?.importPathMap instanceof Map ? fb.importPathMap : null;
  const out = [];
  let triedLazyLoad = false;
  for (const raw of list) {
    let resolved = fileBrowserResolveMappedPath(raw, activeMap);
    if (resolved === raw && /_wire_subject(?:-\d+)?\.[^.]+$/i.test(raw) && !triedLazyLoad) {
      triedLazyLoad = true;
      try {
        const cwd = String(fb?.cwd || "").trim();
        if (cwd) {
          activeMap = await fileBrowserLoadImportPathMap(cwd);
          if (fb) fb.importPathMap = activeMap instanceof Map ? activeMap : new Map();
        }
      } catch {
        // ignore
      }
      resolved = fileBrowserResolveMappedPath(raw, activeMap);
    }
    if (resolved === raw && /_wire_subject(?:-\d+)?\.[^.]+$/i.test(raw)) {
      try {
        const derived = await fileBrowserDeriveOriginalForWirePath(raw);
        if (derived && isBrowserImagePath(derived)) resolved = derived;
      } catch {
        // ignore
      }
    }
    out.push(resolved || raw);
  }
  return out;
}

function fileBrowserClearDragPathDeferred(delayMs = 320) {
  const fb = state.fileBrowser;
  if (!fb) return;
  clearTimeout(fb.dragClearTimer);
  const delay = Math.max(0, Number(delayMs) || 0);
  fb.dragClearTimer = setTimeout(() => {
    fb.dragClearTimer = null;
    fb.draggingPath = null;
  }, delay);
}

function fileBrowserReadInternalDragPath(dataTransfer) {
  const fallback = normalizeLocalFsPath(state.fileBrowser?.draggingPath || "");
  if (!dataTransfer) return fallback;
  if (typeof dataTransfer.getData === "function") {
    const custom = normalizeLocalFsPath(dataTransfer.getData(FILE_BROWSER_DRAG_MIME) || "");
    if (custom) return custom;
    const plain = normalizeLocalFsPath(dataTransfer.getData("text/plain") || "");
    if (plain && isBrowserImagePath(plain)) return plain;
  }
  if (fallback) return fallback;
  return "";
}

async function initializeFileBrowserDock() {
  const fb = state.fileBrowser;
  if (!fb?.enabled) return;
  if (!els.fileBrowserDock) return;
  if (els.fileBrowserChoose) {
    els.fileBrowserChoose.addEventListener("click", () => {
      fileBrowserPickFolder().catch((err) => console.error(err));
    });
  }
  if (els.fileBrowserUp) {
    els.fileBrowserUp.addEventListener("click", () => {
      fileBrowserNavigateUp().catch((err) => console.error(err));
    });
  }
  if (els.fileBrowserRefresh) {
    els.fileBrowserRefresh.addEventListener("click", () => {
      fileBrowserRefresh().catch((err) => console.error(err));
    });
  }
  if (els.fileBrowserList) {
    els.fileBrowserList.tabIndex = 0;

    const endManualPointerDrag = ({ clearPath = true, keepGhost = false } = {}) => {
      const drag = fb.manualDrag;
      if (!drag) return null;
      const ghostEl = drag.ghostEl || null;
      if (ghostEl && !keepGhost) {
        fileBrowserDestroyDragGhost(drag.ghostEl);
      }
      drag.ghostEl = null;
      drag.active = false;
      drag.pointerId = null;
      drag.path = null;
      drag.previewPath = null;
      drag.moved = false;
      els.canvasWrap?.classList?.remove("is-browser-drag-over");
      if (clearPath) fileBrowserClearDragPathDeferred(80);
      return keepGhost ? ghostEl : null;
    };

    const onManualPointerMove = (event) => {
      const drag = fb.manualDrag;
      if (!drag?.active) return;
      if (drag.pointerId !== null && Number(event?.pointerId) !== Number(drag.pointerId)) return;
      const cx = Number(event?.clientX) || 0;
      const cy = Number(event?.clientY) || 0;
      const dx = cx - (Number(drag.startX) || 0);
      const dy = cy - (Number(drag.startY) || 0);
      const ghostPath = String(drag.previewPath || drag.path || "").trim();
      if (!drag.moved && Math.hypot(dx, dy) > 2) {
        drag.moved = true;
        if (!drag.ghostEl && ghostPath) {
          drag.ghostEl = fileBrowserCreateDragGhost(ghostPath);
        }
      }
      if (!drag.moved) return;
      if (!drag.ghostEl && ghostPath) {
        drag.ghostEl = fileBrowserCreateDragGhost(ghostPath);
      }
      fileBrowserUpdateDragGhost(drag.ghostEl, cx, cy);
      const overCanvas = Boolean(canvasWorldPointFromClient(cx, cy));
      els.canvasWrap?.classList?.toggle("is-browser-drag-over", overCanvas);
      event?.preventDefault?.();
    };

    const onManualPointerUp = (event) => {
      const drag = fb.manualDrag;
      if (!drag?.active) return;
      if (drag.pointerId !== null && Number(event?.pointerId) !== Number(drag.pointerId)) return;
      const cx = Number(event?.clientX) || 0;
      const cy = Number(event?.clientY) || 0;
      const path = normalizeLocalFsPath(drag.path || "");
      const previewPath = normalizeLocalFsPath(drag.previewPath || path);
      const didMove = Boolean(drag.moved);
      const keepGhost = Boolean(didMove && path && isBrowserImagePath(path));
      const ghostEl = endManualPointerDrag({ clearPath: false, keepGhost });
      if (!didMove || !path || !isBrowserImagePath(path)) {
        if (ghostEl) fileBrowserDestroyDragGhost(ghostEl);
        fileBrowserClearDragPathDeferred(80);
        return;
      }
      fb.suppressClickUntil = Date.now() + 380;
      const world = canvasWorldPointFromClient(cx, cy);
      if (!world) {
        if (ghostEl) fileBrowserDestroyDragGhost(ghostEl);
        fileBrowserClearDragPathDeferred(80);
        return;
      }
      fileBrowserAnimateDropGhost(ghostEl, { clientX: cx, clientY: cy, path: previewPath || path });
      importLocalPathsAtCanvasPoint([path], world, {
        source: "browser_pointer_drag",
        idPrefix: "dockdrag",
        enforceIntentLimit: true,
        focusImported: true,
      })
        .then((result) => {
          if (!result?.ok) showToast("Could not import dropped image.", "error", 2600);
        })
        .catch((err) => {
          console.error(err);
          showToast("Could not import dropped image.", "error", 2600);
        })
        .finally(() => {
          fileBrowserClearDragPathDeferred(80);
        });
    };

    const onManualPointerCancel = (event) => {
      const drag = fb.manualDrag;
      if (!drag?.active) return;
      if (drag.pointerId !== null && Number(event?.pointerId) !== Number(drag.pointerId)) return;
      endManualPointerDrag({ clearPath: true });
    };

    window.addEventListener("pointermove", onManualPointerMove, { passive: false });
    window.addEventListener("pointerup", onManualPointerUp, { passive: false });
    window.addEventListener("pointercancel", onManualPointerCancel, { passive: true });

    els.fileBrowserList.addEventListener("pointerdown", (event) => {
      const row = event?.target?.closest ? event.target.closest(".file-browser-item") : null;
      if (!row || !els.fileBrowserList.contains(row)) return;
      const displayPath = normalizeLocalFsPath(String(row.dataset?.path || ""));
      const importPath = fileBrowserImportPathForRow(row);
      const kind = String(row.dataset?.kind || "").trim();
      if (kind !== "file" || !displayPath || !importPath) return;
      event.preventDefault();
      fileBrowserSetDragPath(importPath);
      fileBrowserSetSelectedPath(displayPath);
      fb.manualDrag.active = true;
      fb.manualDrag.pointerId = Number(event?.pointerId);
      fb.manualDrag.path = importPath;
      fb.manualDrag.previewPath = displayPath;
      fb.manualDrag.startX = Number(event?.clientX) || 0;
      fb.manualDrag.startY = Number(event?.clientY) || 0;
      fb.manualDrag.moved = false;
      if (fb.manualDrag.ghostEl) {
        fileBrowserDestroyDragGhost(fb.manualDrag.ghostEl);
        fb.manualDrag.ghostEl = null;
      }
    });
    els.fileBrowserList.addEventListener("click", (event) => {
      if (Date.now() < (Number(fb.suppressClickUntil) || 0)) return;
      const row = event?.target?.closest ? event.target.closest(".file-browser-item") : null;
      if (!row || !els.fileBrowserList.contains(row)) return;
      const path = normalizeLocalFsPath(String(row.dataset?.path || ""));
      const importPath = fileBrowserImportPathForRow(row);
      const kind = String(row.dataset?.kind || "").trim();
      if (!path) return;
      fileBrowserSetSelectedPath(path);
      if (kind === "dir") {
        fileBrowserCancelPendingClickImport();
        fileBrowserNavigateTo(path).catch((err) => console.error(err));
        return;
      }
      if (!importPath) return;
      fileBrowserScheduleClickImport(importPath);
    });
    els.fileBrowserList.addEventListener("dblclick", (event) => {
      if (Date.now() < (Number(fb.suppressClickUntil) || 0)) return;
      const row = event?.target?.closest ? event.target.closest(".file-browser-item") : null;
      if (!row || !els.fileBrowserList.contains(row)) return;
      const path = normalizeLocalFsPath(String(row.dataset?.path || ""));
      const importPath = fileBrowserImportPathForRow(row);
      const kind = String(row.dataset?.kind || "").trim();
      if (!path) return;
      fileBrowserCancelPendingClickImport();
      fileBrowserSetSelectedPath(path);
      if (kind === "dir") {
        fileBrowserNavigateTo(path).catch((err) => console.error(err));
        return;
      }
      if (!importPath) return;
      fileBrowserImportPath(importPath, { focus: true }).catch((err) => console.error(err));
    });
    els.fileBrowserList.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      const entries = fileBrowserEntriesForUi();
      if (!entries.length) return;
      const current = state.fileBrowser?.selectedPath || "";
      let idx = entries.findIndex((item) => item.path === current);
      if (key === "ArrowDown") {
        event.preventDefault();
        idx = clamp(idx + 1, 0, entries.length - 1);
        fileBrowserSetSelectedPath(entries[idx]?.path || null);
      } else if (key === "ArrowUp") {
        event.preventDefault();
        idx = clamp(idx < 0 ? 0 : idx - 1, 0, entries.length - 1);
        fileBrowserSetSelectedPath(entries[idx]?.path || null);
      } else if (key === "Enter") {
        event.preventDefault();
        if (idx < 0) idx = 0;
        const entry = entries[idx] || null;
        if (!entry?.path) return;
        fileBrowserCancelPendingClickImport();
        if (entry.kind === "dir") fileBrowserNavigateTo(entry.path).catch((err) => console.error(err));
        else {
          const importPath = fileBrowserImportPathForEntry(entry);
          if (!importPath) return;
          fileBrowserImportPath(importPath, { focus: true }).catch((err) => console.error(err));
        }
      }
    });
  }

  if (fb.rootDir) {
    await fileBrowserLoadDir(fb.rootDir, { pushHistory: false });
  } else {
    renderFileBrowserDock();
  }
}

function parseJsonSafe(raw) {
  try {
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function loadOpenRouterOnboardingProfile() {
  const raw = localStorage.getItem(OPENROUTER_ONBOARDING_PROFILE_KEY);
  const parsed = parseJsonSafe(raw);
  if (!parsed || typeof parsed !== "object") return null;
  return parsed;
}

function saveOpenRouterOnboardingProfile(profile) {
  try {
    localStorage.setItem(OPENROUTER_ONBOARDING_PROFILE_KEY, JSON.stringify(profile));
  } catch {
    // ignore
  }
}

function markOpenRouterOnboardingCompleted(done = true) {
  localStorage.setItem(OPENROUTER_ONBOARDING_COMPLETED_KEY, done ? "1" : "0");
}

function clearOpenRouterOnboardingProfile() {
  localStorage.removeItem(OPENROUTER_ONBOARDING_PROFILE_KEY);
  localStorage.removeItem(OPENROUTER_ONBOARDING_COMPLETED_KEY);
}

function formatOpenRouterOnboardingTimestamp(value) {
  const at = new Date(value || 0);
  if (!Number.isFinite(at.getTime())) return "unknown time";
  return at.toLocaleString();
}

function renderOpenRouterOnboardingStatus() {
  if (!els.openrouterOnboardingStatus) return;
  const profile = loadOpenRouterOnboardingProfile();
  const detected = Boolean(state?.keyStatus?.openrouter);
  if (!profile) {
    els.openrouterOnboardingStatus.textContent = detected
      ? "OpenRouter key detected from environment."
      : "Not started";
    return;
  }
  const when = formatOpenRouterOnboardingTimestamp(profile.successAt || profile.completedAt || Date.now());
  if (profile.success || detected) {
    const masked = profile.keyMasked ? String(profile.keyMasked) : "saved";
    const detection = detected ? "detected" : "not detected yet";
    els.openrouterOnboardingStatus.textContent = `Connected (${masked})\nConfirmed ${when}\nKey status: ${detection}`;
    return;
  }
  if (profile.skipped) {
    els.openrouterOnboardingStatus.textContent = `Skipped ${when}\nRun setup anytime.`;
    return;
  }
  els.openrouterOnboardingStatus.textContent = `Viewed ${when}\nRun setup to finish.`;
}

function renderOpenRouterOnboardingProgress(stepIndex) {
  if (!els.openrouterOnboardingProgress) return;
  const dotCount = 3;
  els.openrouterOnboardingProgress.innerHTML = Array.from({ length: dotCount }, (_, idx) => {
      const active = idx === stepIndex ? " is-active" : "";
      const complete = idx < stepIndex ? " is-complete" : "";
      return `
        <div class="openrouter-onboarding-progress-dot${active}${complete}">
          <span class="openrouter-onboarding-progress-dot-point" aria-hidden="true"></span>
        </div>
      `;
    }).join("");
}

function buildOpenRouterOnboardingIntroHtml() {
  return `
    <section class="openrouter-onboarding-step openrouter-onboarding-step-intro">
      <h3 class="openrouter-onboarding-intro-title">Brood works best with OpenRouter</h3>
      <p class="openrouter-onboarding-intro-copy">
        On the next screen, we will ask for your OPENROUTER_API_KEY, then confirm the key is connected.
      </p>
      <p class="openrouter-onboarding-intro-copy">
        Next: paste your key and click Save key. Brood stores it in ~/.brood/.env.
      </p>
    </section>
  `;
}

function buildOpenRouterOnboardingKeyHtml() {
  const current = escapeHtml(openrouterOnboardingState.draft.apiKey || "");
  const statusText = String(openrouterOnboardingState.statusMessage || "").trim();
  const statusClass = openrouterOnboardingState.statusError
    ? "openrouter-onboarding-form-status is-error"
    : "openrouter-onboarding-form-status";
  return `
    <section class="openrouter-onboarding-step openrouter-onboarding-step-key">
      <h3 class="openrouter-onboarding-intro-title">Connect your OpenRouter key</h3>
      <p class="openrouter-onboarding-intro-copy">
        Paste your OPENROUTER_API_KEY below. Click Continue to save and verify.
      </p>
      <label class="openrouter-onboarding-inline-label" for="openrouter-onboarding-key-input">OPENROUTER_API_KEY</label>
      <input
        id="openrouter-onboarding-key-input"
        class="openrouter-onboarding-key-input"
        type="password"
        autocomplete="off"
        spellcheck="false"
        placeholder="sk-or-v1-..."
        value="${current}"
      />
      <p class="openrouter-onboarding-intro-copy openrouter-onboarding-key-note">Saved to <code>~/.brood/.env</code> and applied for this app session.</p>
      ${
        statusText
          ? `<div class="${statusClass}">${escapeHtml(statusText)}</div>`
          : ""
      }
    </section>
  `;
}

function buildOpenRouterOnboardingSuccessHtml() {
  const profile = loadOpenRouterOnboardingProfile();
  const when = formatOpenRouterOnboardingTimestamp(profile?.successAt || Date.now());
  const masked = profile?.keyMasked ? String(profile.keyMasked) : "saved";
  return `
    <section class="openrouter-onboarding-step openrouter-onboarding-step-confirm">
      <h3 class="openrouter-onboarding-intro-title">OpenRouter key confirmed</h3>
      <p class="openrouter-onboarding-intro-copy">
        Brood detected your OpenRouter key and setup is complete.
      </p>
      <p class="openrouter-onboarding-intro-copy openrouter-onboarding-key-note">Key: <code>${escapeHtml(masked)}</code></p>
      <p class="openrouter-onboarding-intro-copy openrouter-onboarding-key-note">Confirmed: ${escapeHtml(when)}</p>
      <p class="openrouter-onboarding-intro-copy openrouter-onboarding-key-note">
        You can reopen this flow anytime from <strong>Settings â†’ OpenRouter Onboarding</strong>.
      </p>
    </section>
  `;
}

function renderOpenRouterOnboardingStep({ animate = false } = {}) {
  if (!els.openrouterOnboardingModal || !els.openrouterOnboardingBody) return;
  const stepIndex = Math.max(0, Math.min(2, Number(openrouterOnboardingState.stepIndex) || 0));
  const centeredBodyLayout = stepIndex <= 2;
  const bodyEl = els.openrouterOnboardingBody;

  const renderBody = () => {
    if (stepIndex === 0) {
      bodyEl.innerHTML = buildOpenRouterOnboardingIntroHtml();
    } else if (stepIndex === 1) {
      bodyEl.innerHTML = buildOpenRouterOnboardingKeyHtml();
    } else {
      bodyEl.innerHTML = buildOpenRouterOnboardingSuccessHtml();
    }
  };

  if (animate) {
    if (openrouterOnboardingState.transitionTimer) {
      clearTimeout(openrouterOnboardingState.transitionTimer);
      openrouterOnboardingState.transitionTimer = null;
    }
    bodyEl.classList.remove("is-fading-out");
    renderBody();
    bodyEl.classList.remove("is-fading-in");
    void bodyEl.offsetWidth;
    bodyEl.classList.add("is-fading-in");
    openrouterOnboardingState.transitionTimer = setTimeout(() => {
      bodyEl.classList.remove("is-fading-in");
      openrouterOnboardingState.transitionTimer = null;
    }, 1260);
  } else {
    bodyEl.classList.remove("is-fading-out");
    bodyEl.classList.remove("is-fading-in");
    renderBody();
  }
  bodyEl.classList.toggle("is-intro-layout", centeredBodyLayout);

  renderOpenRouterOnboardingProgress(stepIndex);

  if (els.openrouterOnboardingBack) {
    const hidden = stepIndex <= 0 || stepIndex >= 2;
    const disabled = openrouterOnboardingState.submitting || hidden;
    els.openrouterOnboardingBack.classList.toggle("openrouter-onboarding-footer-item-hidden", hidden);
    els.openrouterOnboardingBack.disabled = disabled;
    if (hidden) {
      els.openrouterOnboardingBack.setAttribute("aria-hidden", "true");
      els.openrouterOnboardingBack.setAttribute("tabindex", "-1");
    } else {
      els.openrouterOnboardingBack.removeAttribute("aria-hidden");
      els.openrouterOnboardingBack.removeAttribute("tabindex");
    }
  }
  if (els.openrouterOnboardingSkip) {
    const hidden = stepIndex >= 2;
    const disabled = openrouterOnboardingState.submitting;
    const unavailable = hidden || disabled;
    els.openrouterOnboardingSkip.classList.toggle("openrouter-onboarding-footer-item-hidden", hidden);
    els.openrouterOnboardingSkip.classList.toggle("is-disabled", unavailable);
    if (unavailable) {
      els.openrouterOnboardingSkip.setAttribute("aria-hidden", hidden ? "true" : "false");
      els.openrouterOnboardingSkip.setAttribute("aria-disabled", "true");
      els.openrouterOnboardingSkip.setAttribute("tabindex", "-1");
    } else {
      els.openrouterOnboardingSkip.removeAttribute("aria-hidden");
      els.openrouterOnboardingSkip.removeAttribute("aria-disabled");
      els.openrouterOnboardingSkip.removeAttribute("tabindex");
    }
  }
  if (els.openrouterOnboardingClose) {
    els.openrouterOnboardingClose.textContent = stepIndex >= 2 ? "Close" : "Later";
    els.openrouterOnboardingClose.disabled = openrouterOnboardingState.submitting;
  }
  const nextText = stepIndex === 0 ? "Continue" : stepIndex === 1 ? "Save key" : "Done";
  const nextDisabled = openrouterOnboardingState.submitting;
  if (els.openrouterOnboardingNext) {
    els.openrouterOnboardingNext.textContent = nextText;
    els.openrouterOnboardingNext.disabled = nextDisabled;
  }
}

function closeOpenRouterOnboardingModal() {
  if (openrouterOnboardingState.transitionTimer) {
    clearTimeout(openrouterOnboardingState.transitionTimer);
    openrouterOnboardingState.transitionTimer = null;
  }
  if (els.openrouterOnboardingMediaVideo) {
    els.openrouterOnboardingMediaVideo.pause();
  }
  openrouterOnboardingState.open = false;
  openrouterOnboardingState.submitting = false;
  if (els.openrouterOnboardingModal) {
    els.openrouterOnboardingModal.classList.add("hidden");
  }
}

function playOpenRouterOnboardingMediaVideo({ restart = false } = {}) {
  const videoEl = els.openrouterOnboardingMediaVideo;
  if (!videoEl) return;
  if (!videoEl.src) {
    videoEl.src = OPENROUTER_ONBOARDING_SORA_VIDEO_SRC;
  }
  if (restart) {
    try {
      videoEl.currentTime = 0;
    } catch {
      // Ignore until metadata is available.
    }
  }
  const playResult = videoEl.play();
  if (playResult && typeof playResult.catch === "function") {
    playResult.catch(() => {});
  }
}

function saveOpenRouterOnboardingCompletion({
  success = false,
  skipped = false,
  keyMasked = null,
  envPath = null,
} = {}) {
  const prev = loadOpenRouterOnboardingProfile() || {};
  const nowIso = new Date().toISOString();
  const successFinal = Boolean(success || prev.success);
  const profile = {
    version: 1,
    source: openrouterOnboardingState.source,
    completedAt: nowIso,
    success: successFinal,
    skipped: Boolean(skipped) && !successFinal,
    successAt: success ? nowIso : prev.successAt || null,
    keyMasked: success ? keyMasked || prev.keyMasked || null : prev.keyMasked || null,
    envPath: success ? envPath || prev.envPath || null : prev.envPath || null,
  };
  saveOpenRouterOnboardingProfile(profile);
  markOpenRouterOnboardingCompleted(true);
  renderOpenRouterOnboardingStatus();
}

function openOpenRouterOnboardingModal({ force = false, source = "first_run" } = {}) {
  if (!els.openrouterOnboardingModal) return false;
  const completed = localStorage.getItem(OPENROUTER_ONBOARDING_COMPLETED_KEY) === "1";
  if (!force && completed) return false;
  openrouterOnboardingState.open = true;
  openrouterOnboardingState.stepIndex = 0;
  openrouterOnboardingState.source = source;
  openrouterOnboardingState.draft = defaultOpenRouterOnboardingDraft();
  openrouterOnboardingState.submitting = false;
  openrouterOnboardingState.statusMessage = "";
  openrouterOnboardingState.statusError = false;
  openrouterOnboardingState.keyMasked = null;
  openrouterOnboardingState.envPath = null;
  els.openrouterOnboardingModal.classList.remove("hidden");
  playOpenRouterOnboardingMediaVideo({ restart: true });
  renderOpenRouterOnboardingStep({ animate: false });
  return true;
}

function skipOpenRouterOnboarding() {
  saveOpenRouterOnboardingCompletion({ skipped: true });
  closeOpenRouterOnboardingModal();
}

function handleOpenRouterOnboardingNextAction() {
  if (!openrouterOnboardingState.open || openrouterOnboardingState.submitting) return;
  if (openrouterOnboardingState.stepIndex === 0) {
    openrouterOnboardingState.stepIndex = 1;
    renderOpenRouterOnboardingStep({ animate: true });
    return;
  }
  if (openrouterOnboardingState.stepIndex === 1) {
    submitOpenRouterOnboardingKey().catch((err) => {
      console.error(err);
    });
    return;
  }
  closeOpenRouterOnboardingModal();
}

async function restartEngineAfterOpenRouterKeySave() {
  if (!state.runDir || !state.eventsPath) return true;
  const waitDeadline = Date.now() + 12_000;
  while (state.ptySpawning && Date.now() < waitDeadline) {
    await new Promise((resolve) => setTimeout(resolve, 60));
  }
  if (state.ptySpawning) {
    throw new Error("Engine restart still in progress. Please wait and retry.");
  }
  await spawnEngine();
  if (!state.ptySpawned) {
    throw new Error("OPENROUTER_API_KEY saved, but engine restart failed. Start a new run or relaunch.");
  }
  const readyDeadline = Date.now() + 12_000;
  while (Date.now() < readyDeadline) {
    let status = null;
    try {
      status = await invoke("get_pty_status");
    } catch (_) {
      status = null;
    }
    const running = Boolean(status && typeof status === "object" && status.running);
    if (running) {
      const statusRunDir = status?.run_dir ? String(status.run_dir) : "";
      const statusEventsPath = status?.events_path ? String(status.events_path) : "";
      const runMatch = !statusRunDir || statusRunDir === state.runDir;
      const eventsMatch = !statusEventsPath || statusEventsPath === state.eventsPath;
      if (runMatch && eventsMatch) {
        return true;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, 120));
  }
  throw new Error("OPENROUTER_API_KEY saved, but engine did not report ready after restart. Start a new run or relaunch.");
}

async function submitOpenRouterOnboardingKey() {
  if (openrouterOnboardingState.submitting) return false;
  const inputEl = document.getElementById("openrouter-onboarding-key-input");
  const raw = inputEl ? String(inputEl.value || "") : String(openrouterOnboardingState.draft.apiKey || "");
  const apiKey = raw.trim();
  openrouterOnboardingState.draft.apiKey = apiKey;
  if (!apiKey) {
    openrouterOnboardingState.statusMessage = "Please paste your OPENROUTER_API_KEY.";
    openrouterOnboardingState.statusError = true;
    renderOpenRouterOnboardingStep({ animate: false });
    return false;
  }

  openrouterOnboardingState.submitting = true;
  openrouterOnboardingState.statusError = false;
  openrouterOnboardingState.statusMessage = "Saving key and verifying detectionâ€¦";
  renderOpenRouterOnboardingStep({ animate: false });

  try {
    const result = await invoke("save_openrouter_api_key", { apiKey });
    await refreshKeyStatus().catch(() => {});
    if (!state?.keyStatus?.openrouter) {
      throw new Error("OPENROUTER_API_KEY was saved but key detection did not confirm yet.");
    }
    openrouterOnboardingState.statusMessage = "Restarting engine to apply keyâ€¦";
    renderOpenRouterOnboardingStep({ animate: false });
    await restartEngineAfterOpenRouterKeySave();
    await refreshKeyStatus().catch(() => {});
    if (!state?.keyStatus?.openrouter) {
      throw new Error("OPENROUTER_API_KEY saved, but post-restart key detection is still unavailable.");
    }
    openrouterOnboardingState.keyMasked = result?.key_masked ? String(result.key_masked) : null;
    openrouterOnboardingState.envPath = result?.env_path ? String(result.env_path) : null;
    saveOpenRouterOnboardingCompletion({
      success: true,
      keyMasked: openrouterOnboardingState.keyMasked,
      envPath: openrouterOnboardingState.envPath,
    });
    // Ensure the confirm step renders with interactive controls enabled.
    openrouterOnboardingState.submitting = false;
    openrouterOnboardingState.stepIndex = 2;
    openrouterOnboardingState.statusMessage = "";
    openrouterOnboardingState.statusError = false;
    showToast("OpenRouter key connected.", "tip", 2200);
    renderOpenRouterOnboardingStep({ animate: true });
    return true;
  } catch (err) {
    const message = normalizeErrorMessage(err, "Could not save OPENROUTER_API_KEY.");
    openrouterOnboardingState.statusMessage = message;
    openrouterOnboardingState.statusError = true;
    renderOpenRouterOnboardingStep({ animate: false });
    return false;
  } finally {
    openrouterOnboardingState.submitting = false;
    if (openrouterOnboardingState.stepIndex === 1 && openrouterOnboardingState.open) {
      renderOpenRouterOnboardingStep({ animate: false });
    }
  }
}

function maybeAutoOpenOpenRouterOnboarding() {
  const completed = localStorage.getItem(OPENROUTER_ONBOARDING_COMPLETED_KEY) === "1";
  if (completed) return false;
  return openOpenRouterOnboardingModal({ force: false, source: "first_run" });
}

function loadAestheticOnboardingProfile() {
  const raw = localStorage.getItem(AESTHETIC_ONBOARDING_PROFILE_KEY);
  const parsed = parseJsonSafe(raw);
  if (!parsed || typeof parsed !== "object") return null;
  return parsed;
}

function saveAestheticOnboardingProfile(profile) {
  try {
    localStorage.setItem(AESTHETIC_ONBOARDING_PROFILE_KEY, JSON.stringify(profile));
  } catch {
    // ignore
  }
}

function markAestheticOnboardingCompleted(done = true) {
  localStorage.setItem(AESTHETIC_ONBOARDING_COMPLETED_KEY, done ? "1" : "0");
}

function clearAestheticOnboardingProfile() {
  localStorage.removeItem(AESTHETIC_ONBOARDING_PROFILE_KEY);
  localStorage.removeItem(AESTHETIC_ONBOARDING_COMPLETED_KEY);
}

function getAestheticModelChoice(choiceId) {
  const id = String(choiceId || "").trim();
  if (!id) return null;
  return AESTHETIC_ONBOARDING_MODEL_CHOICES.find((choice) => choice.id === id) || null;
}

function formatAestheticTimestamp(value) {
  const at = new Date(value || 0);
  if (!Number.isFinite(at.getTime())) return "unknown time";
  return at.toLocaleString();
}

function describeAestheticChoice(choiceId) {
  const choice = getAestheticModelChoice(choiceId);
  if (!choice) return "Unknown";
  if (choice.modelValue && choice.modelValue !== choice.id) return `${choice.label} -> ${choice.modelValue}`;
  return choice.label;
}

function scoreAestheticOnboardingAnswers(answers) {
  const scoreByModel = Object.fromEntries(AESTHETIC_ONBOARDING_MODEL_CHOICES.map((choice) => [choice.id, 0]));
  const pickedModelId = String(answers?.imageChoiceId || "").trim();
  if (pickedModelId && scoreByModel[pickedModelId] != null) scoreByModel[pickedModelId] += 3;

  switch (String(answers?.featurePriority || "").trim()) {
    case "reproducible_receipts":
      scoreByModel["gpt-image-1.5"] += 2;
      scoreByModel["gemini-3-pro-image-preview"] += 1;
      break;
    case "image_mutations":
      scoreByModel["flux-2-flex"] += 2;
      scoreByModel["flux-2-max"] += 1;
      break;
    case "multi_model_workflows":
      scoreByModel["gemini-3-pro-image-preview"] += 2;
      scoreByModel["gpt-image-1.5"] += 1;
      break;
    default:
      for (const choice of AESTHETIC_ONBOARDING_MODEL_CHOICES) scoreByModel[choice.id] += 1;
      break;
  }

  switch (String(answers?.directionality || "").trim()) {
    case "fidelity":
      scoreByModel["gemini-3-pro-image-preview"] += 2;
      scoreByModel["gpt-image-1.5"] += 1;
      scoreByModel["flux-2-max"] += 1;
      break;
    case "speed":
      scoreByModel["flux-2-flex"] += 2;
      scoreByModel["flux-2-max"] += 1;
      break;
    default:
      for (const choice of AESTHETIC_ONBOARDING_MODEL_CHOICES) scoreByModel[choice.id] += 1;
      break;
  }

  let winnerId = AESTHETIC_ONBOARDING_MODEL_CHOICES[0]?.id || "gemini-3-pro-image-preview";
  let winnerScore = Number.NEGATIVE_INFINITY;
  for (const choice of AESTHETIC_ONBOARDING_MODEL_CHOICES) {
    const current = Number(scoreByModel[choice.id] || 0);
    if (current > winnerScore) {
      winnerId = choice.id;
      winnerScore = current;
      continue;
    }
    if (current === winnerScore && pickedModelId && choice.id === pickedModelId) {
      winnerId = choice.id;
      winnerScore = current;
    }
  }
  return { winnerId, scoreByModel };
}

function renderAestheticOnboardingStatus() {
  if (!els.aestheticOnboardingStatus) return;
  const profile = loadAestheticOnboardingProfile();
  if (!profile) {
    els.aestheticOnboardingStatus.textContent = "Not set yet";
    return;
  }
  const picked = describeAestheticChoice(profile.preferredModelId);
  const when = formatAestheticTimestamp(profile.completedAt || profile.updatedAt || Date.now());
  if (profile.skipped) {
    els.aestheticOnboardingStatus.textContent = `Skipped on ${when}. Current default: ${settings.imageModel}`;
    return;
  }
  els.aestheticOnboardingStatus.textContent = `Preferred: ${picked}\nSaved ${when}\nDefault model: ${settings.imageModel}`;
}

function renderAestheticOnboardingProgress(stepIndex) {
  if (!els.aestheticOnboardingProgress) return;
  const labels = ["Q1", "Q2", "Q3", "Result"];
  els.aestheticOnboardingProgress.innerHTML = labels
    .map((label, idx) => {
      const active = idx === stepIndex ? " is-active" : "";
      const complete = idx < stepIndex ? " is-complete" : "";
      return `<div class="aesthetic-onboarding-progress-dot${active}${complete}">${label}</div>`;
    })
    .join("");
}

function buildAestheticQuestionStepHtml() {
  const selected = String(aestheticOnboardingState.answers.imageChoiceId || "").trim();
  const cards = AESTHETIC_ONBOARDING_MODEL_CHOICES.map((choice) => {
    const chosen = selected === choice.id ? " is-selected" : "";
    return `
      <button
        class="aesthetic-choice-card${chosen}"
        type="button"
        data-aesthetic-select="imageChoiceId"
        data-aesthetic-value="${choice.id}"
      >
        <img class="aesthetic-choice-image" src="${choice.imageUrl}" alt="${choice.label}" />
        <div class="aesthetic-choice-meta">
          <div class="aesthetic-choice-title">${choice.label}</div>
          <div class="aesthetic-choice-note">${choice.note}</div>
        </div>
      </button>
    `;
  }).join("");
  return `
    <section class="aesthetic-question">
      <div class="aesthetic-question-head">
        <h3>Which image do you like best?</h3>
        <p>All options use the same prompt and differ only by model.</p>
      </div>
      <div class="aesthetic-choice-grid">${cards}</div>
      <div class="aesthetic-prompt-card">
        <div class="aesthetic-prompt-label">Prompt</div>
        <div class="aesthetic-prompt-text">${AESTHETIC_ONBOARDING_PROMPT}</div>
      </div>
    </section>
  `;
}

function buildAestheticOptionStepHtml(question) {
  const selected = String(aestheticOnboardingState.answers[question.answerKey] || "").trim();
  const cards = question.options
    .map((option) => {
      const chosen = selected === option.id ? " is-selected" : "";
      return `
        <button
          class="aesthetic-option-card${chosen}"
          type="button"
          data-aesthetic-select="${question.answerKey}"
          data-aesthetic-value="${option.id}"
        >
          <div class="aesthetic-option-title">${option.title}</div>
          <div class="aesthetic-option-description">${option.description}</div>
        </button>
      `;
    })
    .join("");
  return `
    <section class="aesthetic-question">
      <div class="aesthetic-question-head">
        <h3>${question.title}</h3>
        <p>${question.subtitle}</p>
      </div>
      <div class="aesthetic-option-grid">${cards}</div>
    </section>
  `;
}

function buildAestheticSummaryStepHtml() {
  const scored = scoreAestheticOnboardingAnswers(aestheticOnboardingState.answers);
  const winner = getAestheticModelChoice(scored.winnerId) || AESTHETIC_ONBOARDING_MODEL_CHOICES[0];
  const topReasons = [];
  if (aestheticOnboardingState.answers.imageChoiceId) {
    const picked = getAestheticModelChoice(aestheticOnboardingState.answers.imageChoiceId);
    if (picked) topReasons.push(`You initially preferred ${picked.label}.`);
  }
  if (aestheticOnboardingState.answers.featurePriority === "multi_model_workflows") {
    topReasons.push("You expect multi-model editing workflows.");
  } else if (aestheticOnboardingState.answers.featurePriority === "image_mutations") {
    topReasons.push("You prioritized mutation-heavy exploration.");
  } else if (aestheticOnboardingState.answers.featurePriority === "reproducible_receipts") {
    topReasons.push("You prioritized reproducibility and receipts.");
  }
  if (aestheticOnboardingState.answers.directionality === "fidelity") {
    topReasons.push("You favored polished fidelity.");
  } else if (aestheticOnboardingState.answers.directionality === "speed") {
    topReasons.push("You favored speed and iteration loops.");
  } else {
    topReasons.push("You preferred a balanced speed/quality default.");
  }
  const mappedNote =
    winner.modelValue && winner.modelValue !== winner.id
      ? `This preference maps to ${winner.modelValue} inside Brood right now.`
      : `This will become your default Image Model in Settings and Effects.`;
  return `
    <section class="aesthetic-question">
      <div class="aesthetic-question-head">
        <h3>Your default model recommendation</h3>
        <p>Confirm to apply it as your Brood image default.</p>
      </div>
      <div class="aesthetic-summary-card">
        <div class="aesthetic-summary-label">Recommended model</div>
        <div class="aesthetic-summary-model">${winner.label}</div>
        <div class="aesthetic-summary-note">${mappedNote}</div>
        <ul class="aesthetic-summary-reasons">
          ${topReasons.map((reason) => `<li>${reason}</li>`).join("")}
        </ul>
      </div>
    </section>
  `;
}

function canAdvanceAestheticStep(stepIndex = aestheticOnboardingState.stepIndex) {
  if (stepIndex === 0) return Boolean(aestheticOnboardingState.answers.imageChoiceId);
  if (stepIndex === 1) return Boolean(aestheticOnboardingState.answers.featurePriority);
  if (stepIndex === 2) return Boolean(aestheticOnboardingState.answers.directionality);
  return true;
}

function renderAestheticOnboardingStep({ animate = false } = {}) {
  if (!els.aestheticOnboardingModal || !els.aestheticOnboardingBody) return;
  const stepIndex = Math.max(0, Math.min(3, Number(aestheticOnboardingState.stepIndex) || 0));
  const renderBody = () => {
    if (stepIndex === 0) {
      els.aestheticOnboardingBody.innerHTML = buildAestheticQuestionStepHtml();
    } else if (stepIndex === 1) {
      els.aestheticOnboardingBody.innerHTML = buildAestheticOptionStepHtml({
        answerKey: "featurePriority",
        title: "What Brood feature do you expect to use the most?",
        subtitle: "This helps us bias toward a better default model for your workflow.",
        options: AESTHETIC_FEATURE_OPTIONS,
      });
    } else if (stepIndex === 2) {
      els.aestheticOnboardingBody.innerHTML = buildAestheticOptionStepHtml({
        answerKey: "directionality",
        title: "How should Brood bias your default?",
        subtitle: "Choose whether speed or final polish matters more by default.",
        options: AESTHETIC_DIRECTION_OPTIONS,
      });
    } else {
      els.aestheticOnboardingBody.innerHTML = buildAestheticSummaryStepHtml();
    }
  };

  if (animate) {
    if (aestheticOnboardingState.transitionTimer) {
      clearTimeout(aestheticOnboardingState.transitionTimer);
      aestheticOnboardingState.transitionTimer = null;
    }
    els.aestheticOnboardingBody.classList.add("is-fading-out");
    aestheticOnboardingState.transitionTimer = setTimeout(() => {
      renderBody();
      els.aestheticOnboardingBody.classList.remove("is-fading-out");
      els.aestheticOnboardingBody.classList.add("is-fading-in");
      requestAnimationFrame(() => els.aestheticOnboardingBody?.classList.remove("is-fading-in"));
    }, 130);
  } else {
    els.aestheticOnboardingBody.classList.remove("is-fading-out");
    renderBody();
  }

  const currentStep = stepIndex + 1;
  if (els.aestheticOnboardingTitle) {
    els.aestheticOnboardingTitle.textContent = currentStep <= 3 ? "Find your visual baseline" : "Aesthetic profile ready";
  }
  if (els.aestheticOnboardingSubtitle) {
    els.aestheticOnboardingSubtitle.textContent =
      currentStep <= 3
        ? `Question ${currentStep} of 3`
        : "Apply this recommendation as your default image model.";
  }
  renderAestheticOnboardingProgress(stepIndex);
  if (els.aestheticOnboardingBack) {
    els.aestheticOnboardingBack.classList.toggle("hidden", stepIndex <= 0);
    els.aestheticOnboardingBack.disabled = aestheticOnboardingState.applying;
  }
  if (els.aestheticOnboardingSkip) {
    els.aestheticOnboardingSkip.classList.toggle("hidden", stepIndex >= 3);
    els.aestheticOnboardingSkip.disabled = aestheticOnboardingState.applying;
  }
  if (els.aestheticOnboardingClose) {
    els.aestheticOnboardingClose.textContent = stepIndex >= 3 ? "Keep current" : "Skip";
    els.aestheticOnboardingClose.disabled = aestheticOnboardingState.applying;
  }
  if (els.aestheticOnboardingNext) {
    if (stepIndex < 2) els.aestheticOnboardingNext.textContent = "Next";
    else if (stepIndex === 2) els.aestheticOnboardingNext.textContent = "See result";
    else {
      const scored = scoreAestheticOnboardingAnswers(aestheticOnboardingState.answers);
      const winner = getAestheticModelChoice(scored.winnerId);
      els.aestheticOnboardingNext.textContent = winner ? `Set ${winner.modelValue}` : "Set default model";
    }
    const cannotAdvance = stepIndex < 3 && !canAdvanceAestheticStep(stepIndex);
    els.aestheticOnboardingNext.disabled = cannotAdvance || aestheticOnboardingState.applying;
  }
}

function closeAestheticOnboardingModal() {
  if (aestheticOnboardingState.transitionTimer) {
    clearTimeout(aestheticOnboardingState.transitionTimer);
    aestheticOnboardingState.transitionTimer = null;
  }
  aestheticOnboardingState.open = false;
  aestheticOnboardingState.applying = false;
  if (els.aestheticOnboardingModal) {
    els.aestheticOnboardingModal.classList.add("hidden");
  }
}

function openAestheticOnboardingModal({ force = false, source = "first_run" } = {}) {
  if (!els.aestheticOnboardingModal) return false;
  const completed = localStorage.getItem(AESTHETIC_ONBOARDING_COMPLETED_KEY) === "1";
  if (!force && completed) return false;
  aestheticOnboardingState.open = true;
  aestheticOnboardingState.stepIndex = 0;
  aestheticOnboardingState.answers = defaultAestheticAnswers();
  aestheticOnboardingState.source = source;
  aestheticOnboardingState.applying = false;
  els.aestheticOnboardingModal.classList.remove("hidden");
  renderAestheticOnboardingStep({ animate: false });
  return true;
}

function saveAestheticOnboardingCompletion({
  skipped = false,
  preferredModelId = null,
  scoreByModel = null,
  appliedModel = null,
} = {}) {
  const profile = {
    version: 1,
    source: aestheticOnboardingState.source,
    skipped: Boolean(skipped),
    completedAt: new Date().toISOString(),
    preferredModelId: preferredModelId || null,
    preferredModelValue: preferredModelId ? getAestheticModelChoice(preferredModelId)?.modelValue || null : null,
    appliedModel: appliedModel || null,
    answers: { ...aestheticOnboardingState.answers },
    scoreByModel: scoreByModel && typeof scoreByModel === "object" ? scoreByModel : null,
  };
  saveAestheticOnboardingProfile(profile);
  markAestheticOnboardingCompleted(true);
  renderAestheticOnboardingStatus();
}

async function applyImageModelSetting(nextValue, { announce = false } = {}) {
  const requested = String(nextValue || "").trim();
  if (!requested) return false;
  let resolved = requested;
  if (els.imageModel) {
    const optionValues = Array.from(els.imageModel.options || [])
      .map((opt) => String(opt?.value || "").trim())
      .filter(Boolean);
    if (optionValues.length && !optionValues.includes(resolved)) {
      resolved = optionValues.includes(DEFAULT_IMAGE_MODEL) ? DEFAULT_IMAGE_MODEL : optionValues[0];
    }
  }
  const changed = resolved !== settings.imageModel;
  settings.imageModel = resolved;
  localStorage.setItem("brood.imageModel", settings.imageModel);
  if (els.imageModel) {
    els.imageModel.value = settings.imageModel;
  }
  updatePortraitIdle({ fromSettings: true });
  if (state.ptySpawned) {
    await invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${settings.imageModel}\n` }).catch(() => {});
  }
  if (announce && changed) {
    showToast(`Default image model set to ${settings.imageModel}.`, "tip", 2600);
  }
  renderAestheticOnboardingStatus();
  return changed;
}

async function finalizeAestheticOnboarding({ applyRecommendation = true } = {}) {
  const scored = scoreAestheticOnboardingAnswers(aestheticOnboardingState.answers);
  const winner = getAestheticModelChoice(scored.winnerId) || AESTHETIC_ONBOARDING_MODEL_CHOICES[0] || null;
  let appliedModel = null;
  if (applyRecommendation && winner?.modelValue) {
    aestheticOnboardingState.applying = true;
    renderAestheticOnboardingStep({ animate: false });
    await applyImageModelSetting(winner.modelValue, { announce: true }).catch(() => {});
    appliedModel = winner.modelValue;
  }
  saveAestheticOnboardingCompletion({
    skipped: !applyRecommendation,
    preferredModelId: winner?.id || null,
    scoreByModel: scored.scoreByModel,
    appliedModel,
  });
  closeAestheticOnboardingModal();
}

function skipAestheticOnboarding() {
  saveAestheticOnboardingCompletion({
    skipped: true,
    preferredModelId: null,
    scoreByModel: null,
    appliedModel: null,
  });
  closeAestheticOnboardingModal();
}

function providerFromModel(model) {
  const name = String(model || "").toLowerCase();
  if (!name) return null;
  if (name.startsWith("gemini")) return "gemini";
  if (name.startsWith("imagen") || name.includes("imagen")) return "imagen";
  if (name.startsWith("gpt-image") || name.startsWith("gptimage") || name.startsWith("openai")) return "openai";
  if (name.startsWith("flux")) return "flux";
  if (name.startsWith("sdxl")) return "sdxl";
  if (name.startsWith("dryrun")) return "dryrun";
  if (name.includes("claude")) return "anthropic";
  if (name.includes("gpt-") || name.includes("o1")) return "openai";
  return "unknown";
}

function googleBrandRectColorForKey(key = "", alpha = 0.44) {
  const palette = GOOGLE_BRAND_RECT_PALETTE_RGB;
  if (!Array.isArray(palette) || !palette.length) return `rgba(66, 133, 244, ${alpha})`;
  const idx = Math.abs(Number(hash32(String(key || ""))) || 0) % palette.length;
  return googleBrandRectColorForIndex(idx, alpha);
}

function googleBrandRectColorForIndex(index = 0, alpha = 0.44) {
  const palette = GOOGLE_BRAND_RECT_PALETTE_RGB;
  if (!Array.isArray(palette) || !palette.length) return `rgba(66, 133, 244, ${alpha})`;
  const len = Math.max(1, palette.length);
  const rawIndex = Math.floor(Number(index) || 0);
  const idx = ((rawIndex % len) + len) % len;
  const rgb = Array.isArray(palette[idx]) ? palette[idx] : palette[0];
  const a = Math.max(0, Math.min(1, Number(alpha) || 0));
  return `rgba(${Number(rgb[0]) || 66}, ${Number(rgb[1]) || 133}, ${Number(rgb[2]) || 244}, ${a})`;
}

function pickGeminiImageModel() {
  // Prefer the stronger multi-image model, but fall back to any Gemini option in the UI.
  const preferred = ["gemini-3-pro-image-preview", "gemini-2.5-flash-image"];
  for (const candidate of preferred) {
    if (providerFromModel(candidate) !== "gemini") continue;
    if (!els.imageModel) return candidate;
    if (Array.from(els.imageModel.options || []).some((opt) => opt?.value === candidate)) return candidate;
  }
  if (els.imageModel) {
    const opt = Array.from(els.imageModel.options || []).find(
      (o) => providerFromModel(o?.value) === "gemini"
    );
    if (opt?.value) return opt.value;
  }
  return "gemini-3-pro-image-preview";
}

function pickGeminiFastImageModel() {
  const desired = "gemini-2.5-flash-image";
  if (!els.imageModel) return desired;
  const hasDesired = Array.from(els.imageModel.options || []).some((opt) => opt?.value === desired);
  return hasDesired ? desired : pickGeminiImageModel();
}

// Action-specific model routing (quick actions / tools that drive the engine).
const ACTION_IMAGE_MODEL = {
  bg_replace: "gemini-2.5-flash-image",
  // Niche action: route to FLUX by default for testing; the global Image Model setting remains unchanged.
  surprise: "flux-2-pro",
  combine: "gemini-3-pro-image-preview",
  swap_dna: "gemini-3-pro-image-preview",
  bridge: "gemini-3-pro-image-preview",
  create_layers: "gemini-3-pro-image-preview",
  extract_dna_apply: "gemini-2.5-flash-image",
  soul_leech_apply: "gemini-2.5-flash-image",
  recast: "gemini-3-pro-image-preview",
  remove_people: "gemini-3-pro-image-preview",
};

async function ensureGeminiProImagePreviewForAction(actionLabel = "This action") {
  const desired = "gemini-3-pro-image-preview";
  const provider = providerFromModel(settings.imageModel);
  if (provider === "gemini" && settings.imageModel === desired) return true;

  let nextModel = desired;
  if (els.imageModel) {
    const hasDesired = Array.from(els.imageModel.options || []).some((opt) => opt?.value === desired);
    if (!hasDesired) nextModel = pickGeminiImageModel();
  }

  const changed = settings.imageModel !== nextModel;
  settings.imageModel = nextModel;
  localStorage.setItem("brood.imageModel", settings.imageModel);
  if (els.imageModel) els.imageModel.value = settings.imageModel;
  updatePortraitIdle({ fromSettings: true });
  if (state.ptySpawned) {
    await invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${settings.imageModel}\n` }).catch(() => {});
  }

  if (changed) {
    if (nextModel === desired) {
      showToast(`${actionLabel} uses Gemini Pro. Switched image model to ${settings.imageModel}.`, "tip", 3200);
    } else {
      showToast(`${actionLabel} prefers ${desired}. Using ${settings.imageModel}.`, "tip", 3400);
    }
  }

  return providerFromModel(settings.imageModel) === "gemini";
}

function providerDisplay(provider) {
  if (!provider) return "Unknown";
  if (provider === "openai") return "OpenAI";
  if (provider === "gemini") return "Gemini";
  if (provider === "imagen") return "Imagen";
  if (provider === "flux") return "Flux";
  if (provider === "anthropic") return "Anthropic";
  if (provider === "sdxl") return "SDXL";
  if (provider === "dryrun") return "Dryrun";
  return String(provider);
}

function formatPortraitModelLabel(model) {
  const raw = String(model || "").trim();
  if (!raw) return "";
  const lower = raw.toLowerCase();
  const byExact = {
    "gemini-3-pro-image-preview": "Gem3Pro",
    "gemini-2.5-flash-image": "Gem2.5F",
    "imagen-4.0-ultra": "Img4Ult",
    "imagen-4": "Imagen4",
    "flux-2-max": "Flux2Mx",
    "flux-2-flex": "Flux2Fx",
    "flux-2-pro": "Flux2Pr",
    "flux-2": "Flux2",
    "gpt-image-1.5": "GImg1.5",
    "gpt-image-1-mini": "GImg1Mn",
    "gpt-image-1": "GImg1",
    "gpt-5.2": "GPT5.2",
    "gpt-5.1-codex-max": "GPT5.1C",
    "claude-opus-4-5-20251101": "ClOp4.5",
    "dryrun-text-1": "DryText",
    "dryrun-image-1": "DryImg",
  };
  const MAX = 8;
  function clampLabel(label) {
    return String(label || "").slice(0, MAX);
  }
  if (byExact[lower]) return clampLabel(byExact[lower]);
  if (lower.startsWith("gemini")) return "Gemini".slice(0, MAX);
  if (lower.startsWith("gpt")) return "GPT".slice(0, MAX);
  if (lower.startsWith("imagen")) return "Imagen".slice(0, MAX);
  if (lower.startsWith("flux")) return "Flux".slice(0, MAX);
  if (lower.startsWith("claude")) return "Claude".slice(0, MAX);
  if (lower.startsWith("dryrun")) return "Dryrun".slice(0, MAX);
  return clampLabel(raw);
}

function portraitTitleForSlot(slot, provider) {
  const imageModel = String(settings.imageModel || "").trim();
  const textModel = String(settings.textModel || "").trim();
  const providerKey = String(provider || "").toLowerCase();
  if (slot === "primary") {
    if (imageModel) return formatPortraitModelLabel(imageModel);
  } else {
    if (textModel) return formatPortraitModelLabel(textModel);
  }
  if (imageModel && providerFromModel(imageModel) === providerKey) return formatPortraitModelLabel(imageModel);
  if (textModel && providerFromModel(textModel) === providerKey) return formatPortraitModelLabel(textModel);
  return providerDisplay(provider);
}

const PORTRAITS_DIR_LS_KEY = "brood.portraitsDir";
const PORTRAITS_DIR_DISK_FILE = "portraits_dir.json";

async function getPortraitsDirDiskPath() {
  try {
    const home = await homeDir();
    if (!home) return null;
    return await join(home, ".brood", PORTRAITS_DIR_DISK_FILE);
  } catch (_) {
    return null;
  }
}

async function loadPortraitsDirFromDisk() {
  if (state.portraitMedia.diskDirChecked) return state.portraitMedia.diskDir;
  if (state.portraitMedia.diskDirPromise) return await state.portraitMedia.diskDirPromise;
  state.portraitMedia.diskDirPromise = (async () => {
    const path = await getPortraitsDirDiskPath();
    if (!path) return null;
    if (!(await exists(path).catch(() => false))) return null;
    try {
      const payload = JSON.parse(await readTextFile(path));
      const dir = typeof payload?.dir === "string" ? payload.dir.trim() : "";
      return dir ? dir : null;
    } catch (_) {
      return null;
    }
  })();
  try {
    state.portraitMedia.diskDir = await state.portraitMedia.diskDirPromise;
    state.portraitMedia.diskDirChecked = true;
    return state.portraitMedia.diskDir;
  } finally {
    state.portraitMedia.diskDirPromise = null;
  }
}

async function persistPortraitsDirToDisk(dir) {
  try {
    const home = await homeDir();
    if (!home) return;
    const broodDir = await join(home, ".brood");
    await createDir(broodDir, { recursive: true }).catch(() => {});
    const path = await join(broodDir, PORTRAITS_DIR_DISK_FILE);
    const payload = { dir: String(dir || "").trim() || null, updated_at: new Date().toISOString() };
    await writeTextFile(path, JSON.stringify(payload, null, 2));
    state.portraitMedia.diskDir = payload.dir;
    state.portraitMedia.diskDirChecked = true;
  } catch (_) {
    // ignore
  }
}

async function clearPortraitsDirOnDisk() {
  try {
    const path = await getPortraitsDirDiskPath();
    if (path) await removeFile(path).catch(() => {});
  } catch (_) {}
  state.portraitMedia.diskDir = null;
  state.portraitMedia.diskDirChecked = true;
}

function renderPortraitsDirReadout() {
  if (!els.portraitsDir) return;
  const custom = localStorage.getItem(PORTRAITS_DIR_LS_KEY);
  const disk = state.portraitMedia.diskDirChecked ? state.portraitMedia.diskDir : null;
  const resolved = state.portraitMedia.dir;
  const lines = [];
  if (custom) lines.push(`Custom (this build): ${custom}`);
  else if (disk) lines.push(`Custom (all builds): ${disk}`);
  if (resolved) {
    lines.push(`Using: ${resolved}`);
  } else if (state.portraitMedia.dirChecked) {
    lines.push("Using: (not found)");
    if (state.portraitMedia.lastResolveError) {
      lines.push(`Why: ${clampText(state.portraitMedia.lastResolveError, 180)}`);
    }
  } else {
    lines.push("Using: (searching...)");
  }
  els.portraitsDir.textContent = lines.join("\n");
}

async function refreshPortraitsDirReadout() {
  renderPortraitsDirReadout();
  try {
    await resolvePortraitsDir();
  } catch (_) {}
  renderPortraitsDirReadout();
}

function invalidatePortraitMediaCache() {
  state.portraitMedia.dir = null;
  state.portraitMedia.dirChecked = false;
  state.portraitMedia.dirPromise = null;
  state.portraitMedia.lastResolveError = null;
  state.portraitMedia.index = null;
  state.portraitMedia.indexChecked = false;
  state.portraitMedia.indexPromise = null;
  state.portraitMedia.activeKey1 = null;
  state.portraitMedia.activeKey2 = null;
  state.portraitMedia.missingToastShown = false;
  state.portraitMedia.loadErrorToastShown = false;
  if (state.portraitMedia.urlCache) {
    for (const rec of state.portraitMedia.urlCache.values()) {
      const url = rec?.url;
      if (!url) continue;
      try {
        URL.revokeObjectURL(url);
      } catch {
        // ignore
      }
    }
    state.portraitMedia.urlCache.clear();
  } else {
    state.portraitMedia.urlCache = new Map();
  }
}

async function pickPortraitsDir() {
  bumpInteraction();
  const picked = await open({ directory: true, multiple: false });
  const dir = Array.isArray(picked) ? picked[0] : picked;
  if (!dir) return;
  localStorage.setItem(PORTRAITS_DIR_LS_KEY, String(dir));
  persistPortraitsDirToDisk(String(dir)).catch(() => {});
  invalidatePortraitMediaCache();
  renderPortraitsDirReadout();
  ensurePortraitIndex().catch(() => {});
  updatePortraitIdle({ fromSettings: true });
}

function portraitAgentFromProvider(provider) {
  const p = String(provider || "").toLowerCase();
  // Primary mapping is provider-native so labels and visuals stay intuitive.
  if (p === "openai") return "openai";
  if (p === "sdxl" || p === "stability") return "stability";
  if (p === "gemini") return "gemini";
  if (p === "imagen") return "imagen";
  if (p === "flux") return "flux";
  return null;
}

function portraitFallbackAgentFromProvider(provider) {
  const p = String(provider || "").toLowerCase();
  // Secondary fallback keeps compatibility with the older swapped portrait packs.
  if (p === "openai") return "stability";
  if (p === "sdxl" || p === "stability") return "openai";
  if (p === "gemini") return "flux";
  if (p === "flux") return "gemini";
  return null;
}

function portraitClipPathForAgent(index, agent, clipState) {
  if (!index || !agent) return null;
  let clipPath = index?.[agent]?.[clipState] || null;
  if (!clipPath && clipState === "working") clipPath = index?.[agent]?.idle || null;
  return clipPath || null;
}

function portraitProviderForActiveKey(activeKeyField) {
  if (activeKeyField === "activeKey1") return state?.portrait?.provider || null;
  if (activeKeyField === "activeKey2") return state?.portrait2?.provider || null;
  return null;
}

function looksLikePortraitClipName(name) {
  const lower = String(name || "").toLowerCase();
  // Stable: `gemini_idle.mp4`
  if (lower.match(/^(dryrun|openai|gemini|imagen|flux|stability)_(idle|working)\.(mp4|mov|webm)$/)) {
    return true;
  }
  // Variant/timestamped: `gemini_idle_20240201_010203....mp4`
  return Boolean(lower.match(/^(dryrun|openai|gemini|imagen|flux|stability)_(idle|working)_.+\.(mp4|mov|webm)$/));
}

async function scanPortraitDir(dir) {
  const result = { entries: 0, videos: 0, matches: 0, sampleVideos: [] };
  if (!dir) return result;
  const candidateDirs = [dir];
  try {
    candidateDirs.push(await join(dir, "etc"));
  } catch (_) {}
  for (const candidateDir of candidateDirs) {
    let entries = [];
    try {
      entries = await readDir(candidateDir, { recursive: false });
    } catch (_) {
      continue;
    }
    for (const entry of entries || []) {
      const path = entry?.path;
      if (!path) continue;
      result.entries += 1;
      const ext = extname(path);
      if (ext !== ".mp4" && ext !== ".mov" && ext !== ".webm") continue;
      result.videos += 1;
      const name = basename(path);
      if (result.sampleVideos.length < 4 && name) result.sampleVideos.push(name);
      if (looksLikePortraitClipName(name)) result.matches += 1;
    }
  }
  return result;
}

async function deriveMainRepoRootFromWorktree(repoRoot) {
  if (!repoRoot) return null;
  try {
    const gitPath = await join(repoRoot, ".git");
    const content = await readTextFile(gitPath);
    const firstLine = String(content || "").split(/\r?\n/)[0] || "";
    const match = firstLine.match(/^gitdir:\s*(.+)\s*$/i);
    if (!match) return null;
    const gitdir = String(match[1] || "").trim();
    if (!gitdir) return null;

    const needlePosix = "/.git/worktrees/";
    const needleWin = "\\\\.git\\\\worktrees\\\\";
    let idx = gitdir.indexOf(needlePosix);
    if (idx !== -1) return gitdir.slice(0, idx) || null;
    idx = gitdir.indexOf(needleWin);
    if (idx !== -1) return gitdir.slice(0, idx) || null;
  } catch (_) {
    // ignore
  }
  return null;
}

async function resolvePortraitsDir() {
  if (state.portraitMedia.dirChecked) return state.portraitMedia.dir;
  if (state.portraitMedia.dirPromise) return await state.portraitMedia.dirPromise;
  state.portraitMedia.dirPromise = (async () => {
    state.portraitMedia.lastResolveError = null;
    const candidates = [];
    const fromLsRaw = localStorage.getItem(PORTRAITS_DIR_LS_KEY);
    const fromLs = fromLsRaw ? String(fromLsRaw).trim() : "";
    if (fromLs) candidates.push(fromLs);
    const fromDisk = await loadPortraitsDirFromDisk();
    if (fromDisk && (!fromLs || String(fromDisk) !== String(fromLs).trim())) candidates.push(String(fromDisk).trim());

    // Dev convenience: use repo-local tracked portrait videos first, then generated outputs.
    try {
      const repoRoot = await invoke("get_repo_root");
      if (repoRoot) {
        // Tracked baseline portrait pack for fresh clones.
        candidates.push(await join(repoRoot, "desktop", "src", "assets", "portraits", "videos"));
        // Back-compat with older checkouts that stored videos directly under portraits/.
        candidates.push(await join(repoRoot, "desktop", "src", "assets", "portraits"));
        candidates.push(await join(repoRoot, "outputs", "sora_portraits"));

        // If we're running inside a git worktree checkout, `.git` is a file that points
        // at the main repo's `.git/worktrees/...`. The portrait MP4s are often generated
        // in the main repo's `outputs/` (and are usually untracked), so prefer that if present.
        const mainRoot = await deriveMainRepoRootFromWorktree(repoRoot);
        if (mainRoot && mainRoot !== repoRoot) {
          candidates.push(await join(mainRoot, "desktop", "src", "assets", "portraits", "videos"));
          candidates.push(await join(mainRoot, "desktop", "src", "assets", "portraits"));
          candidates.push(await join(mainRoot, "outputs", "sora_portraits"));
        }
      }
    } catch (_) {}

    // Default persisted location (recommended for packaged builds).
    try {
      const home = await homeDir();
      if (home) {
        candidates.push(await join(home, ".brood", "portraits"));
        candidates.push(await join(home, "brood_runs", "portraits"));
      }
    } catch (_) {}

    const primaryCandidate = candidates.length > 0 ? String(candidates[0]) : "";
    let primaryError = null;
    let lastError = null;

    for (const dir of candidates) {
      let dirError = null;
      let ok = false;
      try {
        ok = await exists(dir);
      } catch (err) {
        dirError = `Cannot access folder: ${err?.message || err}`;
        if (dir === primaryCandidate) primaryError = primaryError || dirError;
        lastError = dirError;
        continue;
      }
      if (!ok) {
        dirError = `Folder not found: ${dir}`;
        if (dir === primaryCandidate) primaryError = primaryError || dirError;
        lastError = dirError;
        continue;
      }
      try {
        const scan = await scanPortraitDir(dir);
        if (scan.matches > 0) return dir;
        if (scan.videos === 0) {
          dirError = `No portrait clips found in: ${dir} (${scan.entries} entries, 0 videos)`;
        } else {
          const sample = scan.sampleVideos.length ? ` Sample: ${scan.sampleVideos.join(", ")}` : "";
          dirError = `No portrait clips matched naming in: ${dir} (${scan.videos} videos, 0 matches).${sample}`;
        }
      } catch (err) {
        dirError = `Cannot read folder: ${err?.message || err}`;
      }
      if (dirError) {
        if (dir === primaryCandidate) primaryError = primaryError || dirError;
        lastError = dirError;
      }
    }

    state.portraitMedia.lastResolveError = primaryError || lastError || null;
    return null;
  })();
  try {
    state.portraitMedia.dir = await state.portraitMedia.dirPromise;
    state.portraitMedia.dirChecked = true;
    renderPortraitsDirReadout();
    return state.portraitMedia.dir;
  } finally {
    state.portraitMedia.dirPromise = null;
  }
}

function extractPortraitStamp(name) {
  const matches = String(name || "").match(/\d{8}_\d{6}/g);
  if (!matches || matches.length === 0) return "";
  return matches[matches.length - 1] || "";
}

function isStablePortraitName(name, agent, clipState) {
  const lower = String(name || "").toLowerCase();
  const targets = [
    `${agent}_${clipState}.mp4`,
    `${agent}_${clipState}.mov`,
    `${agent}_${clipState}.webm`,
  ];
  return targets.includes(lower);
}

async function buildPortraitIndex(dir) {
  // Prefer a known-good Stability "working" clip as the default OpenAI waiting video.
  // OpenAI provider currently maps to the "stability" portrait agent (see portraitAgentFromProvider()).
  const DEFAULT_STABILITY_WORKING_CLIP =
    "stability_working_sora-2_720x1280_12s_20260205_231943.sq.mute.mp4";
  const DEFAULT_STABILITY_IDLE_CLIP =
    "stability_idle_sora-2_720x1280_12s_20260205_231943.sq.mute.mp4";
  const DEFAULT_FLUX_WORKING_CLIP = "flux_working_sora-2_720x1280_12s_20260209_183745.sq.mute.mp4";
  const DEFAULT_FLUX_IDLE_CLIP = "flux_idle_sora-2_720x1280_12s_20260209_183745.sq.mute.mp4";

  const index = {
    dryrun: { idle: null, working: null },
    openai: { idle: null, working: null },
    gemini: { idle: null, working: null },
    imagen: { idle: null, working: null },
    flux: { idle: null, working: null },
    stability: { idle: null, working: null },
  };

  let entries = [];
  try {
    entries = await readDir(dir, { recursive: false });
  } catch (_) {
    return index;
  }
  try {
    const etcDir = await join(dir, "etc");
    const etcEntries = await readDir(etcDir, { recursive: false });
    if (Array.isArray(etcEntries) && etcEntries.length) {
      entries.push(...etcEntries);
    }
  } catch (_) {}

  const candidates = entries
    .map((e) => ({ path: e?.path, name: basename(e?.path) || e?.name }))
    .filter((e) => {
      if (!e.path) return false;
      const ext = extname(e.path);
      return ext === ".mp4" || ext === ".mov" || ext === ".webm";
    });

  for (const item of candidates) {
    const name = String(item.name || "").toLowerCase();
    // Accept both "agent_idle_*" (timestamped / variant clips) and the stable
    // "agent_idle.mp4" naming used for hand-curated overrides.
    const match = name.match(/^(dryrun|openai|gemini|imagen|flux|stability)_(idle|working)(?:_|\.)/);
    if (!match) continue;
    const agent = match[1];
    const clipState = match[2];
    const stamp = extractPortraitStamp(name);
    let priority = isStablePortraitName(name, agent, clipState) ? 2 : 1;
    if (
      agent === "stability" &&
      clipState === "working" &&
      name === String(DEFAULT_STABILITY_WORKING_CLIP).toLowerCase()
    ) {
      priority = 3;
    }
    if (
      agent === "stability" &&
      clipState === "idle" &&
      name === String(DEFAULT_STABILITY_IDLE_CLIP).toLowerCase()
    ) {
      priority = 3;
    }
    if (agent === "flux" && clipState === "working" && name === String(DEFAULT_FLUX_WORKING_CLIP).toLowerCase()) {
      priority = 3;
    }
    if (agent === "flux" && clipState === "idle" && name === String(DEFAULT_FLUX_IDLE_CLIP).toLowerCase()) {
      priority = 3;
    }
    const slot = index[agent]?.[clipState];
    if (!slot) {
      // First one wins until a higher-priority / newer candidate arrives.
      index[agent][clipState] = { path: item.path, priority, stamp };
      continue;
    }
    const slotPrio = slot.priority || 0;
    const slotStamp = slot.stamp || "";
    const isBetter =
      priority > slotPrio || (priority === slotPrio && stamp && (!slotStamp || stamp > slotStamp));
    if (isBetter) {
      index[agent][clipState] = { path: item.path, priority, stamp };
    }
  }

  // Strip metadata: callers only care about a path or null.
  for (const agent of Object.keys(index)) {
    for (const clipState of ["idle", "working"]) {
      const v = index[agent][clipState];
      index[agent][clipState] = v && v.path ? v.path : null;
    }
  }
  return index;
}

async function ensurePortraitIndex() {
  if (state.portraitMedia.indexChecked) return state.portraitMedia.index;
  if (state.portraitMedia.indexPromise) return await state.portraitMedia.indexPromise;
  state.portraitMedia.indexPromise = (async () => {
    const dir = await resolvePortraitsDir();
    if (!dir) return null;
    return await buildPortraitIndex(dir);
  })();
  try {
    state.portraitMedia.index = await state.portraitMedia.indexPromise;
    state.portraitMedia.indexChecked = true;
    renderPortraitsDirReadout();
    return state.portraitMedia.index;
  } finally {
    state.portraitMedia.indexPromise = null;
  }
}

async function refreshPortraitVideo() {
  // Back-compat shim: older callers still invoke refreshPortraitVideo(). Keep it
  // delegating to the new multi-slot portrait implementation.
  await refreshAgentPortraitVideos();
}

function secondaryProviderFor(primaryProvider, index = null) {
  // Secondary portrait is UI-only. Prefer showing the *other* provider the user is
  // actually configured to use (text vs image), rather than an arbitrary always-on
  // mascot (Flux).
  const primary = String(primaryProvider || "").toLowerCase();
  const textProvider = providerFromModel(settings.textModel);
  const preferred = [];
  if (textProvider) preferred.push(textProvider);
  // Sensible fallbacks if the text provider doesn't have clips.
  preferred.push("gemini", "openai", "imagen", "flux", "sdxl");
  const ordered = Array.from(new Set(preferred.map((p) => String(p || "").toLowerCase()).filter(Boolean)));
  const candidates = ordered.filter((p) => p !== primary);

  function hasIdle(provider) {
    if (!index) return true; // optimistic until the index loads
    const agent = portraitAgentFromProvider(provider);
    return Boolean(index?.[agent]?.idle || index?.[agent]?.working);
  }

  for (const provider of candidates) {
    if (hasIdle(provider)) return provider;
  }

  // Even if we have no clips for any other provider, keep the secondary portrait
  // label different (the video loader will fall back to dryrun clips if needed).
  if (candidates.length) return candidates[0];
  return "gemini";
}

async function refreshPortraitVideoSlot({ videoEl, provider, busy, activeKeyField }) {
  if (!videoEl) return;
  const requestedProvider = String(provider || "").trim().toLowerCase();
  const currentProvider = String(portraitProviderForActiveKey(activeKeyField) || "")
    .trim()
    .toLowerCase();
  // Drop stale refreshes so older async calls cannot overwrite newer provider selections.
  if (requestedProvider !== currentProvider) return;
  // Portraits are decorative UI; they should load even before a run/photo is active.
  const visible = Boolean(els.portraitDock) && !els.portraitDock.classList.contains("hidden");
  if (!visible) {
    try {
      videoEl.pause();
    } catch (_) {}
    videoEl.classList.add("hidden");
    state.portraitMedia[activeKeyField] = null;
    return;
  }

  const agent = portraitAgentFromProvider(provider);
  const fallbackAgent = portraitFallbackAgentFromProvider(provider);
  const openAiBoost = openaiRealtimePortraitBoostActive && isOpenAiProvider(provider);
  const clipState = busy || openAiBoost ? "working" : "idle";
  const index = (await ensurePortraitIndex()) || {};
  const currentProviderAfterIndex = String(portraitProviderForActiveKey(activeKeyField) || "")
    .trim()
    .toLowerCase();
  if (requestedProvider !== currentProviderAfterIndex) return;

  // Prefer provider-native clips, then legacy swapped clips. Never use dryrun clips.
  let clipPath = portraitClipPathForAgent(index, agent, clipState);
  if (!clipPath && fallbackAgent && fallbackAgent !== agent) {
    clipPath = portraitClipPathForAgent(index, fallbackAgent, clipState);
  }

  if (!clipPath) {
    try {
      videoEl.pause();
    } catch (_) {}
    try {
      videoEl.removeAttribute("src");
      videoEl.load();
    } catch (_) {}
    videoEl.classList.add("hidden");
    state.portraitMedia[activeKeyField] = null;
    if (
      !state.portraitMedia.missingToastShown &&
      state.portraitMedia.dirChecked &&
      !state.portraitMedia.dir
    ) {
      state.portraitMedia.missingToastShown = true;
      showToast("Portrait clips not found. Settings -> Portraits Folder -> Chooseâ€¦", "tip", 5200);
    }
    return;
  }

  let url = null;
  try {
    url = await ensureImageUrl(clipPath, state.portraitMedia.urlCache);
  } catch (err) {
    url = null;
    if (!state.portraitMedia.loadErrorToastShown) {
      state.portraitMedia.loadErrorToastShown = true;
      console.warn("Portrait clip load failed:", clipPath, err);
      showToast("Portrait clip failed to load. Check Portraits Folder in Settings.", "tip", 5200);
    }
  }
  if (!url) {
    videoEl.classList.add("hidden");
    state.portraitMedia[activeKeyField] = null;
    return;
  }

  const key = `${clipPath}:${clipState}`;
  const currentSrc = String(videoEl.currentSrc || videoEl.src || "");
  const needsSrcUpdate = Boolean(url && currentSrc !== String(url));
  if (state.portraitMedia[activeKeyField] !== key || needsSrcUpdate) {
    state.portraitMedia[activeKeyField] = key;
    videoEl.classList.remove("hidden");
    videoEl.src = url;
    try {
      videoEl.currentTime = 0;
    } catch (_) {}
    try {
      videoEl.load();
    } catch (_) {}
  }

  try {
    const p = videoEl.play();
    if (p && typeof p.catch === "function") p.catch(() => {});
  } catch (_) {}
}

async function refreshAgentPortraitVideos() {
  await Promise.all([
    refreshPortraitVideoSlot({
      videoEl: els.portraitVideo,
      provider: state.portrait.provider,
      busy: state.portrait.busy,
      activeKeyField: "activeKey1",
    }),
    refreshPortraitVideoSlot({
      videoEl: els.portraitVideo2,
      provider: state.portrait2.provider,
      busy: state.portrait2.busy,
      activeKeyField: "activeKey2",
    }),
  ]);
}

function setPortrait({ title, provider, busy } = {}) {
  // Always show the portrait dock (blank placeholders when clips aren't available).
  if (els.portraitDock) els.portraitDock.classList.remove("hidden");
  if (typeof busy === "boolean") {
    state.portrait.busy = busy;
  }
  if (provider !== undefined) {
    state.portrait.provider = provider;
    if (els.portraitAvatar) {
      els.portraitAvatar.dataset.provider = provider || "";
    }
  }
  if (title !== undefined) {
    state.portrait.title = title;
    if (els.portraitTitle) els.portraitTitle.textContent = title || "";
  }
  syncOpenAiRealtimePortraitBusyClasses();
  renderHudReadout();
  refreshAgentPortraitVideos().catch(() => {});
}

function setPortrait2({ title, provider, busy } = {}) {
  // Always show the portrait dock (blank placeholders when clips aren't available).
  if (els.portraitDock) els.portraitDock.classList.remove("hidden");
  if (typeof busy === "boolean") {
    state.portrait2.busy = busy;
  }
  if (provider !== undefined) {
    state.portrait2.provider = provider;
    if (els.portraitAvatar2) {
      els.portraitAvatar2.dataset.provider = provider || "";
    }
  }
  if (title !== undefined) {
    state.portrait2.title = title;
    if (els.portraitTitle2) els.portraitTitle2.textContent = title || "";
  }
  syncOpenAiRealtimePortraitBusyClasses();
  renderHudReadout();
  refreshAgentPortraitVideos().catch(() => {});
}

function updatePortraitIdle({ fromSettings = false } = {}) {
  // Persist the last provider we showed during an action until another action
  // replaces it (visual only; does not affect provider routing).
  //
  // When invoked from a settings change, prefer the selected model's provider.
  const providerDefault = providerFromModel(settings.imageModel);
  const provider = fromSettings ? providerDefault : state.portrait.provider || providerDefault;
  const hasImage = Boolean(state.activeId);
  const index = state.portraitMedia.index;
  const provider2Default = secondaryProviderFor(provider, index);
  let provider2 = fromSettings ? provider2Default : state.portrait2.provider || provider2Default;
  if (provider2 && provider && String(provider2).toLowerCase() === String(provider).toLowerCase()) {
    provider2 = secondaryProviderFor(provider, index);
  }
  setPortrait({
    visible: hasImage,
    busy: false,
    provider,
    title: portraitTitleForSlot("primary", provider),
  });
  setPortrait2({
    visible: hasImage,
    busy: false,
    provider: provider2,
    title: portraitTitleForSlot("secondary", provider2),
  });
  renderHudReadout();
}

function motherMoodMenuIsOpen() {
  if (!els.motherMoodMenu) return false;
  return !els.motherMoodMenu.classList.contains("hidden");
}

function setMotherMoodMenuOpen(open) {
  if (!els.motherMoodMenu) return;
  const next = Boolean(open);
  els.motherMoodMenu.classList.toggle("hidden", !next);
  if (els.canvasMoodStatus) els.canvasMoodStatus.classList.toggle("is-open", next);
  if (els.motherMoodToggle) {
    els.motherMoodToggle.setAttribute("aria-expanded", next ? "true" : "false");
  }
}

function renderMotherMoodStatus() {
  const selectedMood = motherNormalizeMood(state.motherMood || "");
  const config = selectedMood ? motherMoodConfig(selectedMood) : null;
  if (els.motherMoodToggle) {
    els.motherMoodToggle.textContent = config?.emoji || MOTHER_MOOD_PLACEHOLDER_EMOJI;
    const title = config ? `Mood: ${config.label}` : "Mood status (unset)";
    els.motherMoodToggle.title = title;
    els.motherMoodToggle.setAttribute("aria-label", config ? `Mood: ${config.label}` : "Set mood");
    els.motherMoodToggle.dataset.empty = config ? "false" : "true";
  }
  if (els.motherMoodMenu) {
    const options = els.motherMoodMenu.querySelectorAll("button[data-mood]");
    for (const option of options) {
      const mood = motherNormalizeMood(option?.dataset?.mood || "");
      const active = Boolean(selectedMood && mood && mood === selectedMood);
      option.classList.toggle("is-active", active);
      option.setAttribute("aria-checked", active ? "true" : "false");
    }
  }
}

function setMotherMood(moodRaw = "") {
  const mood = motherNormalizeMood(moodRaw);
  state.motherMood = mood || null;
  saveMotherMoodPreference(state.motherMood);
  if (state.motherIdle?.intent && typeof state.motherIdle.intent === "object") {
    state.motherIdle.intent.creative_directive = motherCurrentCreativeDirective();
  }
  renderMotherMoodStatus();
}

function portraitWorking(_actionLabel, { providerOverride = null, forceProvider = false, clearDirector = true } = {}) {
  if (clearDirector && (state.lastDirectorText || state.lastDirectorMeta)) {
    state.lastDirectorText = null;
    state.lastDirectorMeta = null;
  }
  // Keep portrait identities stable during normal actions. Realtime paths can force
  // a provider switch (for example intent realtime OpenAI vs image-model Gemini).
  const overrideProvider = String(providerOverride || "")
    .trim()
    .toLowerCase();
  const providerDefault = providerFromModel(settings.imageModel) || overrideProvider || "gemini";
  const provider = forceProvider && overrideProvider ? overrideProvider : state.portrait.provider || providerDefault;
  setPortrait({
    visible: Boolean(state.activeId),
    busy: true,
    provider,
    title: portraitTitleForSlot("primary", provider),
  });
  // Secondary portrait is display-only for now (idle loop).
  const provider2Existing = state.portrait2.provider;
  const provider2 = forceProvider
    ? secondaryProviderFor(provider, state.portraitMedia.index)
    : provider2Existing || secondaryProviderFor(provider, state.portraitMedia.index);
  setPortrait2({
    visible: Boolean(state.activeId),
    busy: false,
    provider: provider2,
    title: portraitTitleForSlot("secondary", provider2),
  });
  renderHudReadout();
}

function renderKeyStatus(status) {
  if (!els.keyStatus) return;
  if (!status || typeof status !== "object") {
    els.keyStatus.textContent = "Key detection unavailable.";
    return;
  }
  const lines = [];
  lines.push(`OpenAI: ${status.openai ? "ok" : "missing"}`);
  lines.push(`OpenRouter: ${status.openrouter ? "ok" : "missing"}`);
  lines.push(`Gemini: ${status.gemini ? "ok" : "missing"}`);
  lines.push(`Imagen: ${status.imagen ? "ok" : "missing"}`);
  lines.push(`Flux: ${status.flux ? "ok" : "missing"}`);
  lines.push(`Anthropic: ${status.anthropic ? "ok" : "missing"}`);
  if (status.realtime_provider_default) {
    lines.push(
      `Realtime(default): ${status.realtime_provider_default} ${status.realtime_ready ? "ready" : "missing keys"}`
    );
  }
  if (status.realtime_provider_canvas_context) {
    lines.push(
      `Realtime(canvas): ${status.realtime_provider_canvas_context} ${
        status.realtime_ready_canvas_context ? "ready" : "missing keys"
      }`
    );
  }
  if (status.realtime_provider_intent) {
    lines.push(
      `Realtime(intent): ${status.realtime_provider_intent} ${status.realtime_ready_intent ? "ready" : "missing keys"}`
    );
  }
  if (status.realtime_provider_mother_intent) {
    lines.push(
      `Realtime(mother): ${status.realtime_provider_mother_intent} ${
        status.realtime_ready_mother_intent ? "ready" : "missing keys"
      }`
    );
  }
  els.keyStatus.textContent = lines.join("\n");
}

async function refreshKeyStatus() {
  try {
    const status = await invoke("get_key_status");
    state.keyStatus = status;
    renderKeyStatus(status);
  } catch (err) {
    console.warn("Key detection failed:", err);
    state.keyStatus = null;
    renderKeyStatus(null);
  } finally {
    renderOpenRouterOnboardingStatus();
    updateAlwaysOnVisionReadout();
  }
}

function setStatus(message, isError = false) {
  state.lastStatusText = String(message || "");
  state.lastStatusError = Boolean(isError);
  renderSessionApiCallsReadout();
}

function normalizeErrorMessage(err, fallback = "unknown error") {
  const msg = err?.message || err?.cause?.message || err?.reason?.message || err;
  const text = String(msg || fallback).replace(/\s+/g, " ").trim();
  if (!text) return String(fallback);
  return text.length > 180 ? `${text.slice(0, 179)}â€¦` : text;
}

function reportUserError(context, err, { statusScope = "Engine", retryHint = "Try again." } = {}) {
  const label = String(context || "Action").trim() || "Action";
  const detail = normalizeErrorMessage(err);
  const statusLabel = label.toLowerCase();
  setStatus(`${statusScope}: ${statusLabel} failed (${detail})`, true);
  const hint = String(retryHint || "").trim();
  const suffix = hint ? ` ${hint}` : "";
  showToast(`${label} failed: ${detail}.${suffix}`, "error", 4200);
}

function runWithUserError(context, run, opts = {}) {
  const fn = typeof run === "function" ? run : null;
  if (!fn) return Promise.resolve(false);
  return Promise.resolve()
    .then(() => fn())
    .catch((err) => {
      console.error(`${context} failed:`, err);
      reportUserError(context, err, opts);
      return false;
    });
}

function captureRunResetSnapshot() {
  const queue = topMetricQueueCounts();
  return {
    runName: state.runDir ? basename(state.runDir) : "none",
    imageCount: Math.max(0, Number(state.images?.length) || 0),
    selectedCount: Math.max(0, Number(state.selectedIds?.length) || 0),
    queueDepth: Math.max(0, Number(queue.pending) || 0) + Math.max(0, Number(queue.running) || 0),
  };
}

function announceRunTransition(kind, snapshot) {
  const mode = String(kind || "").trim().toLowerCase();
  const summary = snapshot && typeof snapshot === "object" ? snapshot : captureRunResetSnapshot();
  const pieces = [];
  if (summary.imageCount > 0) pieces.push(`${summary.imageCount} photo${summary.imageCount === 1 ? "" : "s"}`);
  if (summary.selectedCount > 0) pieces.push(`${summary.selectedCount} selection${summary.selectedCount === 1 ? "" : "s"}`);
  if (summary.queueDepth > 0) pieces.push(`${summary.queueDepth} queued action${summary.queueDepth === 1 ? "" : "s"}`);
  const resetting = pieces.length ? pieces.join(", ") : "workspace state";
  if (mode === "open") {
    setStatus("Engine: opening run (resetting workspace)â€¦");
    showToast(`Open Run: resetting ${resetting}.`, "tip", 3200);
    return;
  }
  setStatus("Engine: creating run (resetting workspace)â€¦");
  showToast(`New Run: resetting ${resetting}.`, "tip", 3200);
}

function finalizeRunTransition(kind, { restoredArtifacts = 0, engineReady = true } = {}) {
  const mode = String(kind || "").trim().toLowerCase();
  const runName = basename(state.runDir) || "run";
  const ready = Boolean(engineReady);
  if (!ready) {
    if (mode === "open") {
      showToast(`Opened ${runName}, but engine failed to start. Retry Open Run.`, "error", 4200);
      return;
    }
    showToast(`Run ${runName} created, but engine failed to start. Retry New Run.`, "error", 4200);
    return;
  }
  if (mode === "open") {
    const restored = Math.max(0, Number(restoredArtifacts) || 0);
    showToast(
      `Opened ${runName}. Workspace reset complete; restored ${restored} artifact${restored === 1 ? "" : "s"}.`,
      "tip",
      3600
    );
    return;
  }
  showToast(`New run ready: ${runName}. Workspace reset complete.`, "tip", 3200);
}

function renderSessionApiCallsReadout() {
  renderTopMetricsGrid();
}

function bumpSessionApiCalls({ n = 1 } = {}) {
  const delta = Number(n) || 0;
  if (!Number.isFinite(delta) || delta <= 0) return;
  state.sessionApiCalls = (Number(state.sessionApiCalls) || 0) + delta;
  renderSessionApiCallsReadout();
}

let toastTimer = null;
let topMetricsTickTimer = null;
function showToast(message, kind = "info", timeoutMs = 2400) {
  if (shouldSuppressToastInReelMode(message, kind)) return;
  if (!els.toast) return;
  els.toast.textContent = String(message || "");
  els.toast.dataset.kind = kind;
  els.toast.classList.remove("hidden");
  clearTimeout(toastTimer);
  if (timeoutMs > 0) {
    toastTimer = setTimeout(() => {
      if (!els.toast) return;
      els.toast.classList.add("hidden");
    }, timeoutMs);
  }
}

let lastMotherRenderedText = null;
let motherTypeoutTimer = null;
let motherTypeoutTarget = "";
let motherTypeoutIndex = 0;
let motherGlitchTimer = null;
let motherReadoutFadeTimer = null;
let motherPhaseCardExitTimer = null;
let motherPhaseCardExitInFlight = false;
let motherRolePreviewSankeyRaf = 0;
let motherRolePreviewSankeyBendEpochMs = 0;
let wheelForcePanHeld = false;
const REEL_PRESET_MARGIN_PX = 24;
let reelPresetWindowResizeAttached = false;
const MOTHER_V2_SANKEY_BEND_CYCLE_MS = 2200;

function getReelScaleForViewport() {
  const appWidth = Math.max(1, window.innerWidth - REEL_PRESET_MARGIN_PX);
  const appHeight = Math.max(1, window.innerHeight - REEL_PRESET_MARGIN_PX);
  const widthScale = appWidth / REEL_PRESET.width;
  const heightScale = appHeight / REEL_PRESET.height;
  const rawScale = Math.min(widthScale, heightScale, 1);
  return clamp(rawScale, 0.08, 1);
}

function isReelSizeLocked() {
  return document.documentElement.dataset.reelSizePreset === "active";
}

function shouldSuppressToastInReelMode(message, kind = "info") {
  if (!isReelSizeLocked()) return false;
  if (String(kind || "").toLowerCase() === "error") return false;
  const text = String(message || "").trim();
  if (!text) return false;
  // In reel mode, suppress informational toasts that reveal generated/input filenames.
  return /\b[^\\/\s]+\.(png|jpe?g|webp|heic|gif|bmp|tiff?|mp4|mov|webm)\b/i.test(text);
}

function suppressReelDnaToasts() {
  return isReelSizeLocked();
}

function updateReelSizeButton() {
  const locked = isReelSizeLocked();
  if (els.reelAdminToggle) {
    els.reelAdminToggle.textContent = locked ? "Exit Reel 9:16" : "Enable Reel 9:16";
    els.reelAdminToggle.classList.toggle("is-active", locked);
    els.reelAdminToggle.setAttribute("aria-pressed", locked ? "true" : "false");
    els.reelAdminToggle.title = locked
      ? "Restore normal layout"
      : `Resize app to ${REEL_PRESET.width} Ã— ${REEL_PRESET.height} area`;
  }
}

function setReelSizeLock(enabled) {
  const appEl = document.getElementById("app");
  if (!appEl) return;
  if (!enabled) {
    document.documentElement.removeAttribute("data-reel-size-preset");
    document.documentElement.style.removeProperty("--reel-view-scale");
    appEl.style.removeProperty("width");
    appEl.style.removeProperty("height");
    updateReelSizeButton();
    return;
  }

  const scale = getReelScaleForViewport();
  const width = Math.round(REEL_PRESET.width * scale);
  const height = Math.round(REEL_PRESET.height * scale);

  appEl.style.width = `${width}px`;
  appEl.style.height = `${height}px`;
  document.documentElement.setAttribute("data-reel-size-preset", "active");
  document.documentElement.style.setProperty("--reel-view-scale", "1");
  updateReelSizeButton();
}

function toggleReelSizeLock() {
  const wasLocked = isReelSizeLocked();
  setReelSizeLock(!wasLocked);
  const nowLocked = isReelSizeLocked();
  if (els.overlayCanvas) {
    els.overlayCanvas.style.cursor = nowLocked ? "none" : INTENT_IMPORT_CURSOR;
  }
  if (!nowLocked && state.reelTouch) {
    state.reelTouch.visibleUntil = 0;
    state.reelTouch.downUntil = 0;
    state.reelTouch.down = false;
  }
  // Reel mode changes visible control affordances (2x3 grid, mother readout/actions),
  // so force an immediate UI refresh instead of waiting for later state updates.
  renderQuickActions();
  renderMotherReadout();
  if (nowLocked) {
    setStatus(`App resize preset: ${REEL_PRESET.width} Ã— ${REEL_PRESET.height}`);
  }
}

function stopMotherGlitchLoop() {
  clearTimeout(motherGlitchTimer);
  motherGlitchTimer = null;
  if (els.tipsText) els.tipsText.classList.remove("mother-glitch");
}

function _triggerMotherGlitchBurst() {
  if (!els.tipsText) return;
  if (els.tipsText.classList.contains("mother-proposal-active")) return;
  if (els.tipsText.querySelector(".mother-proposal-icon, .mother-phase-icon")) return;
  // Keep it subtle and infrequent: brief "cosmic storm" interference.
  const durationMs = 140 + Math.floor(Math.random() * 240);
  els.tipsText.classList.add("mother-glitch");
  setTimeout(() => {
    if (!els.tipsText) return;
    els.tipsText.classList.remove("mother-glitch");
  }, durationMs);
}

function _scheduleNextMotherGlitch() {
  clearTimeout(motherGlitchTimer);
  // Infrequent by design.
  const delayMs = 22000 + Math.floor(Math.random() * 52000); // 22s - 74s
  motherGlitchTimer = setTimeout(() => {
    _triggerMotherGlitchBurst();
    // Occasionally double-tap the glitch for a more "stormy" feel.
    if (Math.random() < 0.22) {
      setTimeout(() => _triggerMotherGlitchBurst(), 140 + Math.floor(Math.random() * 260));
    }
    _scheduleNextMotherGlitch();
  }, delayMs);
}

function startMotherGlitchLoop() {
  if (motherGlitchTimer) return;
  _scheduleNextMotherGlitch();
}

function stopMotherTypeout() {
  clearTimeout(motherTypeoutTimer);
  motherTypeoutTimer = null;
  motherTypeoutTarget = "";
  motherTypeoutIndex = 0;
  if (els.tipsText) els.tipsText.classList.remove("mother-typing");
}

function motherV2TriggerReadoutFade() {
  if (!els.tipsText) return;
  clearTimeout(motherReadoutFadeTimer);
  els.tipsText.classList.remove("mother-readout-fade");
  // Force reflow so the fade restarts on each readout change.
  void els.tipsText.offsetWidth; // eslint-disable-line no-unused-expressions
  els.tipsText.classList.add("mother-readout-fade");
  motherReadoutFadeTimer = setTimeout(() => {
    if (!els.tipsText) return;
    els.tipsText.classList.remove("mother-readout-fade");
  }, 280);
}

function motherTypeoutTick() {
  if (!els.tipsText) return;
  const remaining = motherTypeoutTarget.length - motherTypeoutIndex;
  if (remaining <= 0) {
    els.tipsText.classList.remove("mother-typing");
    motherTypeoutTimer = null;
    return;
  }
  let step = 1;
  if (remaining > 900) step = 6;
  else if (remaining > 600) step = 4;
  else if (remaining > 300) step = 3;
  else if (remaining > 140) step = 2;

  motherTypeoutIndex = Math.min(motherTypeoutTarget.length, motherTypeoutIndex + step);
  els.tipsText.textContent = motherTypeoutTarget.slice(0, motherTypeoutIndex);
  motherTypeoutTimer = setTimeout(motherTypeoutTick, 90);
}

function startMotherTypeout(text) {
  if (!els.tipsText) return;
  stopMotherTypeout();
  motherTypeoutTarget = String(text || "");
  motherTypeoutIndex = 0;
  els.tipsText.textContent = "";
  els.tipsText.classList.add("mother-typing");
  motherTypeoutTick();
}

function syncMotherTakeoverClass() {
  if (!els.canvasWrap) return;
  els.canvasWrap.classList.toggle("mother-takeover", Boolean(state.mother?.running));
}

function motherV2CommitUndoAvailable() {
  const idle = state.motherIdle;
  if (!idle?.commitUndo) return false;
  if (Date.now() <= (Number(idle.commitUndo.expiresAt) || 0)) return true;
  // Expired undo should not keep blocking reject follow-up behavior.
  idle.commitUndo = null;
  return false;
}

function renderMotherControls() {
  syncMotherTakeoverClass();

  const idle = state.motherIdle || null;
  const reelLocked = isReelSizeLocked();
  const phase = idle?.phase || motherIdleInitialState();
  const hasProposalImageSet = motherV2HasProposalImageSet();
  const proposalModes = motherV2ProposalModes(idle?.intent || null);
  const undoAvailable = motherV2CommitUndoAvailable();
  const canNextProposal =
    hasProposalImageSet &&
    phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
    proposalModes.length > 1;
  const canConfirm =
    phase === MOTHER_IDLE_STATES.OFFERING ||
    (hasProposalImageSet && phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING);
  const canReject =
    undoAvailable ||
    phase === MOTHER_IDLE_STATES.OFFERING ||
    phase === MOTHER_IDLE_STATES.DRAFTING ||
    (hasProposalImageSet && phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING);
  const nextLabel = "Next proposal";
  const nextTitle = canNextProposal ? "Cycle to next proposal option" : "No alternate proposal available";
  const confirmTitle =
    phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING
      ? "Accept proposal and start draft"
      : phase === MOTHER_IDLE_STATES.OFFERING
        ? "Accept and apply selected draft"
        : "Mother confirm";
  const rejectTitle = undoAvailable
    ? "Undo last Mother commit"
    : phase === MOTHER_IDLE_STATES.DRAFTING
      ? "Cancel drafting"
      : "Reject proposal";

  if (els.motherConfirm) {
    els.motherConfirm.disabled = !canConfirm;
    els.motherConfirm.title = confirmTitle;
    els.motherConfirm.textContent = "V";
    els.motherConfirm.setAttribute("aria-label", confirmTitle);
    els.motherConfirm.classList.toggle("hidden", false);
  }
  if (els.motherStop) {
    const stopAction = els.motherStop.closest(".mother-action");
    if (stopAction) stopAction.classList.toggle("hidden", reelLocked);
    els.motherStop.disabled = !canReject;
    els.motherStop.title = rejectTitle;
    els.motherStop.textContent = undoAvailable ? "â†¶" : "X";
    els.motherStop.setAttribute("aria-label", rejectTitle);
    els.motherStop.classList.toggle("hidden", reelLocked);
  }
  if (els.motherAbilityIcon) {
    els.motherAbilityIcon.disabled = !canNextProposal;
    els.motherAbilityIcon.title = nextTitle;
    els.motherAbilityIcon.textContent = "â†’";
    els.motherAbilityIcon.setAttribute("aria-label", canNextProposal ? nextLabel : `${nextLabel} unavailable`);
  }

  syncMotherPortrait();
}

function motherV2ImageLabelById(imageId) {
  const item = state.imagesById.get(String(imageId || "").trim()) || null;
  if (!item) return String(imageId || "").trim();
  const label = String(item.label || "").trim();
  if (label) return label;
  const pathLabel = basename(item.path || "");
  if (pathLabel) return pathLabel;
  return String(item.id || "").trim();
}

function motherV2PaletteKeyByImageId(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return "";
  const item = state.imagesById.get(id) || null;
  if (!item) return id;
  const path = String(item.path || "").trim();
  if (path) return `${id}|${path}`;
  const label = String(item.label || "").trim();
  if (label) return `${id}|${label}`;
  return id;
}

function motherV2PaletteIndexByImageId(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return 0;
  const paletteLen = Math.max(1, Number(GOOGLE_BRAND_RECT_PALETTE_RGB?.length) || 0);
  const item = state.imagesById.get(id) || null;
  const assigned = Number(item?.uiPaletteIndex);
  if (Number.isFinite(assigned) && assigned >= 0) {
    return Math.floor(assigned) % paletteLen;
  }
  const fallbackOrder = Array.isArray(state.images)
    ? state.images.findIndex((entry) => String(entry?.id || "").trim() === id)
    : -1;
  if (fallbackOrder >= 0) return fallbackOrder % paletteLen;
  return Math.abs(Number(hash32(id)) || 0) % paletteLen;
}

function motherV2SyncSelectOptions(selectEl, currentId = "") {
  if (!selectEl) return;
  const normalizedCurrent = String(currentId || "").trim();
  const options = [{ value: "", label: "Unassigned" }];
  for (const item of motherIdleBaseImageItems()) {
    if (!item?.id) continue;
    options.push({
      value: String(item.id),
      label: motherV2ImageLabelById(item.id),
    });
  }
  const prior = Array.from(selectEl.options || []).map((opt) => `${opt.value}::${opt.text}`).join("|");
  const next = options.map((opt) => `${opt.value}::${opt.label}`).join("|");
  if (prior !== next) {
    selectEl.innerHTML = options
      .map((opt) => `<option value="${escapeHtml(opt.value)}">${escapeHtml(opt.label)}</option>`)
      .join("");
  }
  selectEl.value = normalizedCurrent;
}

function motherV2SyncLayeredPanel() {
  const idle = state.motherIdle;
  if (!idle) return;
  const phase = idle.phase || motherIdleInitialState();
  const interactive =
    phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING ||
    phase === MOTHER_IDLE_STATES.OFFERING ||
    phase === MOTHER_IDLE_STATES.DRAFTING;
  const advancedVisible = motherV2IsAdvancedVisible() && interactive;
  const hintsVisible = motherV2HintsVisible() && interactive;
  const hasIntent = Boolean(idle.intent && typeof idle.intent === "object");

  if (els.motherPanel) {
    els.motherPanel.classList.toggle("mother-panel-layered", interactive || phase === MOTHER_IDLE_STATES.WATCHING);
    els.motherPanel.classList.toggle("mother-hints-visible", hintsVisible);
    els.motherPanel.classList.toggle("mother-advanced-visible", advancedVisible);
  }
  if (els.motherPanelStack) {
    els.motherPanelStack.classList.toggle("mother-panel-interactive", interactive);
    els.motherPanelStack.classList.toggle("mother-panel-advanced", advancedVisible);
  }
  if (els.motherRefineToggle) {
    els.motherRefineToggle.classList.add("hidden");
    els.motherRefineToggle.setAttribute("aria-expanded", advancedVisible ? "true" : "false");
    els.motherRefineToggle.textContent = advancedVisible ? "Hide structure" : "Refine structure";
  }
  if (els.motherAdvanced) {
    els.motherAdvanced.classList.toggle("hidden", !advancedVisible || !hasIntent);
  }
  if (!advancedVisible || !hasIntent) return;

  if (els.motherTransformationMode) {
    if (!els.motherTransformationMode.options.length) {
      els.motherTransformationMode.innerHTML = MOTHER_V2_TRANSFORMATION_MODES.map(
        (mode) => `<option value="${mode}">${mode.toUpperCase()}</option>`
      ).join("");
    }
    const mode = motherV2CurrentTransformationMode();
    els.motherTransformationMode.value = mode;
  }

  motherV2SyncSelectOptions(els.motherRoleSubject, motherV2RoleIds("subject")[0] || "");
  motherV2SyncSelectOptions(els.motherRoleModel, motherV2RoleIds("model")[0] || "");
  motherV2SyncSelectOptions(els.motherRoleMediator, motherV2RoleIds("mediator")[0] || "");
  motherV2SyncSelectOptions(els.motherRoleObject, motherV2RoleIds("object")[0] || "");
}

function syncMotherIntentSourceIndicator() {
  const indicator = els.motherIntentSourceIndicator;
  if (!indicator) return;
  const sourceKind = String(state.motherIdle?.intent?._intent_source_kind || "").trim().toLowerCase();
  const sourceModel = String(state.motherIdle?.intent?._intent_source_model || "").trim();
  const normalized = sourceKind === "realtime" ? "realtime" : "";
  const tone = normalized === "realtime" ? realtimeIntentModelTone(sourceModel) : "";
  indicator.classList.remove(
    "hidden",
    "is-realtime",
    "is-fallback",
    "is-realtime-openai-mini",
    "is-realtime-gemini-flash"
  );
  if (!normalized) {
    indicator.title = intentSourceDotTooltip("", "");
    return;
  }
  indicator.classList.add(`is-${normalized}`);
  if (tone === "openai-mini") indicator.classList.add("is-realtime-openai-mini");
  if (tone === "gemini-flash") indicator.classList.add("is-realtime-gemini-flash");
  indicator.title = intentSourceDotTooltip(normalized, sourceModel);
}

function motherV2RolePreviewEntries() {
  const roleByImageId = new Map();
  for (const roleKey of MOTHER_V2_ROLE_KEYS) {
    for (const imageIdRaw of motherV2RoleIds(roleKey)) {
      const imageId = String(imageIdRaw || "").trim();
      if (!imageId) continue;
      if (!roleByImageId.has(imageId)) roleByImageId.set(imageId, roleKey);
    }
  }
  const visibleIds = new Set(
    getVisibleCanvasImages()
      .map((item) => String(item?.id || "").trim())
      .filter(Boolean)
  );
  const orderedIds = [];
  const pushOrderedId = (rawId) => {
    const imageId = String(rawId || "").trim();
    if (!imageId) return;
    if (!visibleIds.has(imageId)) return;
    if (orderedIds.includes(imageId)) return;
    orderedIds.push(imageId);
  };
  for (const imageIdRaw of Array.isArray(state.freeformZOrder) ? state.freeformZOrder : []) {
    pushOrderedId(imageIdRaw);
  }
  for (const item of getVisibleCanvasImages()) {
    pushOrderedId(item?.id);
  }
  const activeId = String(getVisibleActiveId() || "").trim();

  const entries = [];
  for (const imageId of orderedIds) {
    const rect = state.freeformRects.get(imageId) || null;
    if (!rect) continue;
    const rectTransform = readFreeformRectTransform(rect);
    const roleCandidate = String(roleByImageId.get(imageId) || "")
      .trim()
      .toLowerCase();
    const roleKey = MOTHER_V2_ROLE_KEYS.includes(roleCandidate) ? roleCandidate : "";
    const roleLabel = roleKey ? String(MOTHER_V2_ROLE_LABEL[roleKey] || roleKey.toUpperCase()) : "";
    const paletteIndex = motherV2PaletteIndexByImageId(imageId);
    const accentKey = `palette:${paletteIndex}:${motherV2PaletteKeyByImageId(imageId) || imageId}`;
    const accent = googleBrandRectColorForIndex(paletteIndex, 0.94);
    entries.push({
      imageId,
      roleKey,
      roleLabel,
      accentKey,
      accent,
      isActive: Boolean(activeId && imageId === activeId),
      imageLabel: clampText(motherV2ImageLabelById(imageId), 28),
      rect: {
        x: Math.round(Number(rect.x) || 0),
        y: Math.round(Number(rect.y) || 0),
        w: Math.max(1, Math.round(Number(rect.w) || 1)),
        h: Math.max(1, Math.round(Number(rect.h) || 1)),
      },
      transform: {
        rotateDeg: rectTransform.rotateDeg,
        skewXDeg: rectTransform.skewXDeg,
      },
    });
  }
  return entries;
}

function motherV2RolePreviewSignature(
  entries,
  { canvasCssW, canvasCssH, surfaceW, surfaceH, animationMode = "", promptMotionKey = "" } = {}
) {
  const parts = [
    `canvas=${Math.round(Number(canvasCssW) || 0)}x${Math.round(Number(canvasCssH) || 0)}`,
    `surface=${Math.round(Number(surfaceW) || 0)}x${Math.round(Number(surfaceH) || 0)}`,
    `mode=${state.canvasMode || ""}`,
    `proposal_mode=${String(animationMode || "")}`,
    `prompt_motion=${String(promptMotionKey || "")}`,
  ];
  parts.push(`active=${getVisibleActiveId() || ""}`);
  parts.push(`sel=${getVisibleSelectedIds().join(",")}`);
  for (const entry of Array.isArray(entries) ? entries : []) {
    if (!entry) continue;
    const rect = entry.rect || {};
    const transform = entry.transform || {};
    const rotateDeg = Number(transform.rotateDeg);
    const skewXDeg = Number(transform.skewXDeg);
    parts.push(
      `${entry.imageId}:${entry.roleKey}:${entry.accentKey || ""}:${Math.round(Number(rect.x) || 0)},${Math.round(
        Number(rect.y) || 0
      )},${Math.round(
        Number(rect.w) || 0
      )},${Math.round(Number(rect.h) || 0)}:${Number.isFinite(rotateDeg) ? rotateDeg.toFixed(2) : "0.00"},${
        Number.isFinite(skewXDeg) ? skewXDeg.toFixed(2) : "0.00"
      }`
    );
  }
  return parts.join("|");
}

function motherV2RolePreviewMode() {
  const explicit = motherV2MaybeTransformationMode(state.motherIdle?.intent?.transformation_mode);
  if (explicit) return explicit;
  const remembered = motherV2MaybeTransformationMode(state.motherIdle?.lastProposalMode);
  return remembered || "";
}

function motherV2RolePreviewAnimationMode() {
  const phase = String(state.motherIdle?.phase || "").trim();
  const activePhases = new Set([
    MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING,
    MOTHER_IDLE_STATES.DRAFTING,
    MOTHER_IDLE_STATES.OFFERING,
  ]);
  if (!activePhases.has(phase)) return "";
  const mode = motherV2RolePreviewMode();
  if (!mode) return "";
  if (phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
    const intent = state.motherIdle?.intent || null;
    if (!intent || typeof intent !== "object") return "";
  }
  return mode;
}

function motherV2RolePreviewMotionState() {
  const dragging =
    Boolean(state.pointer?.active) ||
    Boolean(state.motherIdle?.roleGlyphDrag) ||
    Boolean(state.effectTokenDrag);
  return dragging ? "paused" : "running";
}

function motherV2VectorToTarget(fromX, fromY, toX, toY, magnitude = 1) {
  const dx = Number(toX) - Number(fromX);
  const dy = Number(toY) - Number(fromY);
  const len = Math.hypot(dx, dy);
  if (!(len > 0.0001)) return { x: 0, y: 0 };
  return {
    x: (dx / len) * Number(magnitude || 0),
    y: (dy / len) * Number(magnitude || 0),
  };
}

function motherV2BlendNumber(base, target, t = 0) {
  const from = Number(base) || 0;
  const to = Number(target) || 0;
  const amount = clamp(Number(t) || 0, 0, 1);
  return from + (to - from) * amount;
}

const MOTHER_V2_PROMPT_MOTION_KEYWORDS = Object.freeze({
  cinematic: Object.freeze([
    "cinematic",
    "dramatic",
    "hero",
    "high-contrast",
    "moody",
    "rim light",
    "production-grade lighting",
  ]),
  soft: Object.freeze([
    "soft",
    "warm",
    "gentle",
    "dreamy",
    "ethereal",
    "serene",
    "intimate",
    "romantic",
  ]),
  chaos: Object.freeze([
    "chaotic",
    "chaos",
    "fracture",
    "destabilize",
    "glitch",
    "shatter",
    "fragment",
    "volatile",
  ]),
  precise: Object.freeze([
    "clean",
    "minimal",
    "crisp",
    "coherent",
    "structured",
    "grid",
    "focal hierarchy",
    "perspective",
  ]),
  fusion: Object.freeze([
    "integrate all references",
    "single coherent scene",
    "fusion",
    "fuse",
    "blend",
    "hybrid",
    "midpoint",
  ]),
  lighting: Object.freeze([
    "lighting",
    "shadow",
    "contrast",
    "exposure",
    "color",
    "tonal",
    "highlight",
  ]),
});

function motherV2PromptKeywordScore(text = "", keywords = []) {
  const hay = String(text || "").toLowerCase();
  if (!hay || !Array.isArray(keywords) || !keywords.length) return 0;
  let hits = 0;
  for (const rawKeyword of keywords) {
    const keyword = String(rawKeyword || "").trim().toLowerCase();
    if (!keyword) continue;
    if (hay.includes(keyword)) hits += 1;
  }
  return clamp(hits / Math.max(1, keywords.length), 0, 1);
}

function motherV2PromptMotionProfileFromCompiled(compiled = {}) {
  const payload = compiled && typeof compiled === "object" ? compiled : {};
  const positive = String(payload.positive_prompt || payload.prompt || "").trim();
  const negative = String(payload.negative_prompt || "").trim();
  const summary = String(payload.summary || payload.intent_summary || "").trim();
  const directive = String(payload.creative_directive || "").trim();
  const transformationMode = motherV2MaybeTransformationMode(payload.transformation_mode) || "";
  const raw = [positive, negative, summary, directive, transformationMode].filter(Boolean).join("\n").trim().toLowerCase();
  if (!raw) return null;

  const cinematic = motherV2PromptKeywordScore(raw, MOTHER_V2_PROMPT_MOTION_KEYWORDS.cinematic);
  const softness = motherV2PromptKeywordScore(raw, MOTHER_V2_PROMPT_MOTION_KEYWORDS.soft);
  const chaos = motherV2PromptKeywordScore(raw, MOTHER_V2_PROMPT_MOTION_KEYWORDS.chaos);
  const precision = motherV2PromptKeywordScore(raw, MOTHER_V2_PROMPT_MOTION_KEYWORDS.precise);
  const fusion = motherV2PromptKeywordScore(raw, MOTHER_V2_PROMPT_MOTION_KEYWORDS.fusion);
  const lighting = motherV2PromptKeywordScore(raw, MOTHER_V2_PROMPT_MOTION_KEYWORDS.lighting);

  const promptHash = hash32(raw);
  const seedA = rand01(promptHash + 0.17);
  const seedB = rand01(promptHash + 1.93);
  const seedC = rand01(promptHash + 3.71);
  const seedD = rand01(promptHash + 5.29);

  const tempo = clamp(1 + cinematic * 0.2 + chaos * 0.22 - softness * 0.1 + (seedA - 0.5) * 0.08, 0.72, 1.42);
  const spread = clamp(1 + chaos * 0.2 - fusion * 0.17 - precision * 0.12 + (seedB - 0.5) * 0.12, 0.72, 1.35);
  const pulse = clamp(0.22 + cinematic * 0.45 + fusion * 0.24 + seedC * 0.12, 0.08, 0.96);
  const verticalLift = clamp(cinematic * 0.65 + softness * 0.28 - chaos * 0.18 + (seedD - 0.5) * 0.08, -0.24, 1);
  const focusPull = clamp(precision * 0.62 + fusion * 0.42 - chaos * 0.26, 0, 1);
  const chaosGain = clamp(0.62 + chaos * 0.94 - precision * 0.14 + (seedA - 0.5) * 0.12, 0.45, 1.75);
  const key = [
    promptHash.toString(16),
    Math.round(cinematic * 100),
    Math.round(softness * 100),
    Math.round(chaos * 100),
    Math.round(precision * 100),
    Math.round(fusion * 100),
    Math.round(lighting * 100),
  ].join(":");

  return {
    key,
    tempo,
    spread,
    pulse,
    verticalLift,
    focusPull,
    chaosGain,
    cinematic,
    softness,
    chaos,
    precision,
    fusion,
    lighting,
  };
}

function motherV2CurrentPromptMotionProfile() {
  const idle = state.motherIdle;
  if (!idle) return null;
  const phase = String(idle.phase || "").trim();
  const canUseStored = phase === MOTHER_IDLE_STATES.DRAFTING || phase === MOTHER_IDLE_STATES.OFFERING || phase === MOTHER_IDLE_STATES.COMMITTING || phase === MOTHER_IDLE_STATES.COOLDOWN;
  if (canUseStored && idle.promptMotionProfile && typeof idle.promptMotionProfile === "object") {
    return idle.promptMotionProfile;
  }
  const fallbackCompiled = {
    positive_prompt: String(idle.pendingPromptLine || idle.intent?.summary || "").trim(),
    creative_directive: String(idle.intent?.creative_directive || "").trim(),
    transformation_mode: String(idle.intent?.transformation_mode || "").trim(),
  };
  return motherV2PromptMotionProfileFromCompiled(fallbackCompiled);
}

function motherV2RolePreviewMergeBlend(mode = "") {
  const modeKey = String(mode || "").trim().toLowerCase();
  switch (modeKey) {
    case "amplify":
      return 0.24;
    case "transcend":
      return 0.4;
    case "destabilize":
      return 0.08;
    case "purify":
      return 0.66;
    case "hybridize":
      return 0.98;
    case "mythologize":
      return 0.2;
    case "monumentalize":
      return 0.56;
    case "fracture":
      return 0.03;
    case "romanticize":
      return 0.92;
    case "alienate":
      return 0;
    default:
      return 0;
  }
}

function motherV2RolePreviewMotionProfile({
  mode = "",
  roleKey = "",
  centerX = 0,
  centerY = 0,
  rectW = 0,
  rectH = 0,
  surfaceW = 0,
  surfaceH = 0,
  subjectCenter = null,
  modelCenter = null,
  focusCenter = null,
  mergeRect = null,
  promptMotion = null,
} = {}) {
  const panelCenterX = (Number(surfaceW) || 0) / 2;
  const panelCenterY = (Number(surfaceH) || 0) / 2;
  const dx = Number(centerX) - panelCenterX;
  const dy = Number(centerY) - panelCenterY;
  const len = Math.max(0.0001, Math.hypot(dx, dy));
  const ux = dx / len;
  const uy = dy / len;
  const tx = -uy;
  const ty = ux;
  const towardCenterX = -ux;
  const towardCenterY = -uy;
  const signX = dx >= 0 ? 1 : -1;

  const out = {
    preMx: 0,
    preMy: 0,
    preScale: 1,
    preResizeX: 1,
    preResizeY: 1,
    preRot: 0,
    preSat: 1,
    preBright: 1,
    preAlpha: 0.92,
    mx: 0,
    my: 0,
    scale: 1,
    resizeX: 1,
    resizeY: 1,
    rot: 0,
    sat: 1,
    bright: 1,
    alpha: 0.84,
    speedMs: 3000,
    animKind: "flow",
    jitterAx: 2.2,
    jitterAy: 1.6,
    mergeStrength: 0,
  };

  const modeKey = String(mode || "").trim().toLowerCase();
  if (!modeKey) return out;

  switch (modeKey) {
    case "amplify":
      out.animKind = "amplify";
      out.speedMs = 1100;
      out.mx = ux * 5.6;
      out.my = uy * 5.2;
      out.scale = 1.2;
      out.resizeX = 1.16;
      out.resizeY = 1.16;
      out.rot = signX * 2.4;
      out.sat = 1.42;
      out.bright = 1.22;
      out.mergeStrength = 0.16;
      break;
    case "transcend":
      out.animKind = "transcend";
      out.speedMs = 5200;
      out.mx = tx * 1.6 + towardCenterX * 0.8;
      out.my = -7.2 + towardCenterY * 1.1;
      out.scale = 1.02;
      out.resizeX = 0.9;
      out.resizeY = 1.24;
      out.sat = 0.98;
      out.bright = 1.24;
      out.rot = tx * 3.2;
      out.jitterAx = 1.1;
      out.jitterAy = 0.9;
      out.mergeStrength = 0.44;
      break;
    case "destabilize":
      out.animKind = "destabilize";
      out.speedMs = 620;
      out.mx = ux * 2.8 + tx * 1.8;
      out.my = uy * 2.6 + ty * 1.2;
      out.scale = 1;
      out.resizeX = 1.24;
      out.resizeY = 0.78;
      out.rot = signX * 5.2;
      out.sat = 1.26;
      out.bright = 0.98;
      out.jitterAx = 5.8;
      out.jitterAy = 4.2;
      out.alpha = 0.78;
      out.mergeStrength = 0.06;
      break;
    case "purify":
      out.animKind = "purify";
      out.speedMs = 4400;
      out.mx = towardCenterX * 4.2;
      out.my = towardCenterY * 3.4 - 1.4;
      out.scale = 0.96;
      out.resizeX = 0.84;
      out.resizeY = 1.2;
      out.sat = 0.72;
      out.bright = 1.32;
      out.alpha = 0.8;
      out.mergeStrength = 0.8;
      break;
    case "hybridize":
      out.animKind = "hybridize";
      out.speedMs = 1800;
      out.mx = towardCenterX * 5 + tx * 0.8;
      out.my = towardCenterY * 4.2 + ty * 0.8;
      out.scale = 1.08;
      out.resizeX = 1.12;
      out.resizeY = 0.88;
      out.sat = 1.24;
      out.bright = 1.16;
      out.rot = signX * 1.6;
      out.jitterAx = 1.8;
      out.jitterAy = 1.4;
      out.alpha = 0.86;
      out.mergeStrength = 1;
      break;
    case "mythologize":
      out.animKind = "mythologize";
      out.speedMs = 5600;
      out.mx = tx * 6.8;
      out.my = ty * 6.8;
      out.scale = 1.14;
      out.resizeX = 1.22;
      out.resizeY = 0.8;
      out.rot = signX * 7.5;
      out.sat = 1.3;
      out.bright = 1.16;
      out.jitterAx = 3.8;
      out.jitterAy = 2.8;
      out.mergeStrength = 0.24;
      break;
    case "monumentalize":
      out.animKind = "monumentalize";
      out.speedMs = 6200;
      out.mx = towardCenterX * 1.6;
      out.my = -8.8 + towardCenterY * 0.8;
      out.scale = 1.2;
      out.resizeX = 1.1;
      out.resizeY = 1.3;
      out.rot = signX * 0.5;
      out.sat = 1.06;
      out.bright = 1.16;
      out.alpha = 0.88;
      out.mergeStrength = 0.62;
      break;
    case "fracture":
      out.animKind = "fracture";
      out.speedMs = 540;
      out.mx = signX * 8.2 + tx * 2.4;
      out.my = signX * 2.2 - ty * 1.8;
      out.scale = 0.98;
      out.resizeX = 1.36;
      out.resizeY = 0.66;
      out.rot = signX * 8.5;
      out.sat = 1.18;
      out.bright = 0.92;
      out.jitterAx = 7.8;
      out.jitterAy = 5.4;
      out.alpha = 0.72;
      out.mergeStrength = 0.01;
      break;
    case "romanticize": {
      out.animKind = "romanticize";
      out.speedMs = 2600;
      out.mx = towardCenterX * 2.4;
      out.my = towardCenterY * 2.0 - 1.8;
      out.scale = 1.08;
      out.resizeX = 1.2;
      out.resizeY = 0.86;
      out.sat = 1.24;
      out.bright = 1.18;
      out.rot = signX * 1.2;
      out.alpha = 0.86;
      out.mergeStrength = 0.9;

      const hasPair = subjectCenter && modelCenter;
      if (hasPair) {
        const subjectToModel = motherV2VectorToTarget(centerX, centerY, modelCenter.x, modelCenter.y, 4.4);
        const modelToSubject = motherV2VectorToTarget(centerX, centerY, subjectCenter.x, subjectCenter.y, 4.4);
        const pairMidX = (subjectCenter.x + modelCenter.x) / 2;
        const pairMidY = (subjectCenter.y + modelCenter.y) / 2;
        const toPairMid = motherV2VectorToTarget(centerX, centerY, pairMidX, pairMidY, 2.3);
        if (roleKey === "subject") {
          out.mx += subjectToModel.x;
          out.my += subjectToModel.y;
          out.resizeX = 1.28;
          out.resizeY = 0.8;
        } else if (roleKey === "model") {
          out.mx += modelToSubject.x;
          out.my += modelToSubject.y;
          out.resizeX = 1.28;
          out.resizeY = 0.8;
        } else {
          out.mx += toPairMid.x;
          out.my += toPairMid.y;
        }
      }
      break;
    }
    case "alienate":
      out.animKind = "alienate";
      out.speedMs = 3600;
      out.mx = ux * 7.4 + tx * 1.2;
      out.my = uy * 6.8 + ty * 1.2;
      out.scale = 0.86;
      out.resizeX = 0.72;
      out.resizeY = 1.34;
      out.sat = 0.62;
      out.bright = 0.8;
      out.rot = signX * 3.2;
      out.alpha = 0.64;
      out.mergeStrength = 0;
      if (roleKey === "subject" || roleKey === "model") {
        out.resizeX = 0.64;
        out.resizeY = 1.42;
        out.alpha = 0.6;
      }
      break;
    default:
      break;
  }

  const focus = focusCenter && Number.isFinite(Number(focusCenter.x)) && Number.isFinite(Number(focusCenter.y))
    ? { x: Number(focusCenter.x), y: Number(focusCenter.y) }
    : null;
  const mergeStrength = clamp(Number(out.mergeStrength) || 0, 0, 1);
  if (focus && mergeStrength > 0.001) {
    const dist = Math.hypot(focus.x - Number(centerX), focus.y - Number(centerY));
    const mergeMag = clamp(dist * 0.1, 0.6, 6.0) * mergeStrength;
    const mergeVec = motherV2VectorToTarget(centerX, centerY, focus.x, focus.y, mergeMag);
    out.mx += mergeVec.x;
    out.my += mergeVec.y;
    const shapeBlend = clamp(mergeStrength * 0.78, 0, 0.88);
    out.resizeX = motherV2BlendNumber(out.resizeX, 1.02, shapeBlend);
    out.resizeY = motherV2BlendNumber(out.resizeY, 1.02, shapeBlend);
    out.scale = motherV2BlendNumber(out.scale, 1.04, clamp(mergeStrength * 0.5, 0, 0.65));
    out.alpha = motherV2BlendNumber(out.alpha, 0.93, clamp(mergeStrength * 0.6, 0, 0.45));
  }

  const preMerge = {
    mx: out.mx,
    my: out.my,
    scale: out.scale,
    resizeX: out.resizeX,
    resizeY: out.resizeY,
    rot: out.rot,
    sat: out.sat,
    bright: out.bright,
    alpha: out.alpha,
  };

  if (mergeRect && Number(rectW) > 0.0001 && Number(rectH) > 0.0001) {
    const mergeBlend = motherV2RolePreviewMergeBlend(modeKey);
    if (mergeBlend > 0.001) {
      const targetCx = Number(mergeRect.x) + Number(mergeRect.w) / 2;
      const targetCy = Number(mergeRect.y) + Number(mergeRect.h) / 2;
      const centerBlend = clamp(0.14 + mergeBlend * 0.74, 0, 0.92);
      out.mx = motherV2BlendNumber(out.mx, targetCx - Number(centerX), centerBlend);
      out.my = motherV2BlendNumber(out.my, targetCy - Number(centerY), centerBlend);
      const targetScaleX = clamp((Number(mergeRect.w) || 1) / Math.max(1, Number(rectW) || 1), 0.68, 1.55);
      const targetScaleY = clamp((Number(mergeRect.h) || 1) / Math.max(1, Number(rectH) || 1), 0.68, 1.55);
      const shapeBlend = clamp(0.04 + mergeBlend * 0.38, 0, 0.46);
      out.resizeX = motherV2BlendNumber(out.resizeX, targetScaleX, shapeBlend);
      out.resizeY = motherV2BlendNumber(out.resizeY, targetScaleY, shapeBlend);
      out.rot = motherV2BlendNumber(out.rot, 0, clamp(mergeBlend * 0.72, 0, 0.72));
      out.alpha = motherV2BlendNumber(out.alpha, modeKey === "hybridize" ? 0.86 : 0.78, clamp(mergeBlend * 0.84, 0, 0.84));
      out.sat = motherV2BlendNumber(out.sat, modeKey === "hybridize" ? 1.2 : 1.03, clamp(mergeBlend * 0.72, 0, 0.72));
      out.bright = motherV2BlendNumber(out.bright, modeKey === "hybridize" ? 1.12 : 1.04, clamp(mergeBlend * 0.66, 0, 0.66));
      out.scale = motherV2BlendNumber(out.scale, 1.03, clamp(mergeBlend * 0.1, 0, 0.1));
    }
  }

  const promptProfile = promptMotion && typeof promptMotion === "object" ? promptMotion : null;
  if (promptProfile) {
    const tempo = clamp(Number(promptProfile.tempo) || 1, 0.72, 1.42);
    out.speedMs = Math.max(420, Math.round((Number(out.speedMs) || 3000) / tempo));

    const spread = clamp(Number(promptProfile.spread) || 1, 0.72, 1.35);
    out.mx *= spread;
    out.my *= spread;

    const focusPull = clamp(Number(promptProfile.focusPull) || 0, 0, 1);
    const focusBlendX = clamp(focusPull * 0.45, 0, 0.45);
    const focusBlendY = clamp(focusPull * 0.34, 0, 0.34);
    out.mx = motherV2BlendNumber(out.mx, out.mx * 0.82, focusBlendX);
    out.my = motherV2BlendNumber(out.my, out.my * 0.84, focusBlendY);

    const lift = clamp(Number(promptProfile.verticalLift) || 0, -0.24, 1);
    out.my -= lift * 2.4;

    const pulse = clamp(Number(promptProfile.pulse) || 0, 0, 1);
    out.scale = clamp((Number(out.scale) || 1) + pulse * 0.08 - focusPull * 0.02, 0.84, 1.4);

    const chaos = clamp(Number(promptProfile.chaos) || 0, 0, 1);
    const chaosGain = clamp(Number(promptProfile.chaosGain) || 1, 0.45, 1.75);
    out.jitterAx = clamp((Number(out.jitterAx) || 2.2) * chaosGain, 0.7, 12);
    out.jitterAy = clamp((Number(out.jitterAy) || 1.6) * (0.85 + Math.max(0, chaosGain - 1) * 0.8), 0.55, 9);

    const cinematic = clamp(Number(promptProfile.cinematic) || 0, 0, 1);
    const softness = clamp(Number(promptProfile.softness) || 0, 0, 1);
    const lighting = clamp(Number(promptProfile.lighting) || 0, 0, 1);
    out.sat = clamp((Number(out.sat) || 1) + cinematic * 0.12 - softness * 0.08, 0.74, 1.5);
    out.bright = clamp((Number(out.bright) || 1) + lighting * 0.1 - chaos * 0.04 + softness * 0.03, 0.78, 1.38);
    out.alpha = clamp((Number(out.alpha) || 1) + pulse * 0.05 - chaos * 0.05, 0.6, 1);
  }

  // Keep proposal rects visibly filled but semi-transparent across all modes.
  preMerge.alpha = clamp(Number(preMerge.alpha) || 0.7, 0.34, 0.74);
  out.alpha = clamp(Number(out.alpha) || 0.7, 0.34, 0.74);

  const round = (n) => Math.round(Number(n || 0) * 100) / 100;
  return {
    ...out,
    preMx: round(preMerge.mx),
    preMy: round(preMerge.my),
    preScale: round(preMerge.scale),
    preResizeX: round(preMerge.resizeX),
    preResizeY: round(preMerge.resizeY),
    preRot: round(preMerge.rot),
    preSat: round(preMerge.sat),
    preBright: round(preMerge.bright),
    preAlpha: round(preMerge.alpha),
    mx: round(out.mx),
    my: round(out.my),
    scale: round(out.scale),
    resizeX: round(out.resizeX),
    resizeY: round(out.resizeY),
    rot: round(out.rot),
    sat: round(out.sat),
    bright: round(out.bright),
    alpha: round(out.alpha),
    jitterAx: round(out.jitterAx),
    jitterAy: round(out.jitterAy),
    mergeStrength: round(out.mergeStrength),
  };
}

function motherV2SyncRolePreviewViewport(root, projection, { canvasCssW = 0, canvasCssH = 0 } = {}) {
  if (!root) return;
  const existing = root.querySelector(".mother-role-preview-viewport");
  // Keep the panel preview clean: do not render a viewport overlay box here.
  if (existing) existing.remove();
}

function motherV2RolePreviewViewportHtml(projection, { canvasCssW = 0, canvasCssH = 0 } = {}) {
  // Keep the panel preview clean: do not include a viewport overlay box.
  return "";
}

function motherV2SankeyBendAmountForMode(mode = "", nowMs = performance.now()) {
  if (motherV2NormalizeTransformationMode(mode) !== "hybridize") return 0;
  const now = Number(nowMs);
  if (!Number.isFinite(now)) return 0;
  if (!(motherRolePreviewSankeyBendEpochMs > 0)) {
    motherRolePreviewSankeyBendEpochMs = now;
  }
  const cycleMs = Math.max(400, Number(MOTHER_V2_SANKEY_BEND_CYCLE_MS) || 2200);
  const t = ((now - motherRolePreviewSankeyBendEpochMs) % cycleMs + cycleMs) % cycleMs / cycleMs;
  const wave = Math.sin(Math.PI * t);
  return clamp(wave * wave, 0, 1);
}

function motherV2BuildSankeyPrismFromEdgePair({
  sourceTop = null,
  sourceBottom = null,
  targetTop = null,
  targetBottom = null,
  surfaceW = 0,
  surfaceH = 0,
  laneOffset = 0,
  bendAmount = 0,
} = {}) {
  const toPt = (p) => ({
    x: Number(p?.x),
    y: Number(p?.y),
  });
  const st = toPt(sourceTop);
  const sb = toPt(sourceBottom);
  const tt = toPt(targetTop);
  const tb = toPt(targetBottom);
  if (![st.x, st.y, sb.x, sb.y, tt.x, tt.y, tb.x, tb.y].every(Number.isFinite)) return null;
  const scx = (st.x + sb.x) * 0.5;
  const scy = (st.y + sb.y) * 0.5;
  const tcx = (tt.x + tb.x) * 0.5;
  const tcy = (tt.y + tb.y) * 0.5;
  const laneDx = tcx - scx;
  const laneDy = tcy - scy;
  const laneLen = Math.hypot(laneDx, laneDy);
  const minCurveLen = clamp(Math.min(Math.max(1, Number(surfaceW) || 1), Math.max(1, Number(surfaceH) || 1)) * 0.2, 26, 68);
  const dirX = laneLen > 0.001 ? laneDx : 10;
  const dirY = laneLen > 0.001 ? laneDy : 0;
  const dirLen = Math.hypot(dirX, dirY);
  const ux = dirX / Math.max(0.0001, dirLen);
  const uy = dirY / Math.max(0.0001, dirLen);
  const nx = -uy;
  const ny = ux;
  const effectiveLen = Math.max(laneLen, minCurveLen);
  const bendNorm = clamp(Number(bendAmount) || 0, 0, 1);
  const bendBase = clamp(effectiveLen * 0.14, 7, 34);
  const laneBend = (Number(laneOffset) || 0) * 0.72;
  const bend1 = (bendBase + laneBend) * bendNorm;
  const bend2 = -(bendBase - laneBend) * bendNorm;

  const spine0 = { x: scx, y: scy };
  const spine1 = {
    x: scx + ux * (effectiveLen * 0.34) + nx * bend1,
    y: scy + uy * (effectiveLen * 0.34) + ny * bend1,
  };
  const spine2 = {
    x: tcx - ux * (effectiveLen * 0.30) + nx * bend2,
    y: tcy - uy * (effectiveLen * 0.30) + ny * bend2,
  };
  const spine3 = { x: tcx, y: tcy };

  const normalizeVec = (x, y, fallbackX = 1, fallbackY = 0) => {
    const len = Math.hypot(x, y);
    if (len > 0.0001) return { x: x / len, y: y / len };
    const fallbackLen = Math.hypot(fallbackX, fallbackY);
    if (fallbackLen > 0.0001) return { x: fallbackX / fallbackLen, y: fallbackY / fallbackLen };
    return { x: 1, y: 0 };
  };
  const lerp = (a, b, t) => a + (b - a) * t;
  const cubicPoint = (p0, p1, p2, p3, t) => {
    const u = 1 - t;
    const uu = u * u;
    const tt2 = t * t;
    return {
      x: p0.x * uu * u + 3 * p1.x * uu * t + 3 * p2.x * u * tt2 + p3.x * tt2 * t,
      y: p0.y * uu * u + 3 * p1.y * uu * t + 3 * p2.y * u * tt2 + p3.y * tt2 * t,
    };
  };
  const cubicTangent = (p0, p1, p2, p3, t) => {
    const u = 1 - t;
    return {
      x: 3 * u * u * (p1.x - p0.x) + 6 * u * t * (p2.x - p1.x) + 3 * t * t * (p3.x - p2.x),
      y: 3 * u * u * (p1.y - p0.y) + 6 * u * t * (p2.y - p1.y) + 3 * t * t * (p3.y - p2.y),
    };
  };
  const lit = (p) => `${p.x.toFixed(2)} ${p.y.toFixed(2)}`;

  const widthStartVec = { x: sb.x - st.x, y: sb.y - st.y };
  const widthEndVec = { x: tb.x - tt.x, y: tb.y - tt.y };
  const widthStart = Math.max(1, Math.hypot(widthStartVec.x, widthStartVec.y));
  const widthEnd = Math.max(1, Math.hypot(widthEndVec.x, widthEndVec.y));
  const widthStartDir = normalizeVec(widthStartVec.x, widthStartVec.y, nx, ny);
  const widthEndDir = normalizeVec(widthEndVec.x, widthEndVec.y, widthStartDir.x, widthStartDir.y);

  const sampleCount = Math.max(6, Math.round(clamp(effectiveLen / 24, 6, 18)));
  const frontTop = [];
  const frontBottom = [];
  const backTop = [];
  const backBottom = [];

  for (let i = 0; i <= sampleCount; i += 1) {
    const t = i / sampleCount;
    const center = cubicPoint(spine0, spine1, spine2, spine3, t);
    const tangent = cubicTangent(spine0, spine1, spine2, spine3, t);
    const tangentDir = normalizeVec(tangent.x, tangent.y, ux, uy);
    const localNormal = { x: -tangentDir.y, y: tangentDir.x };
    const widthBlend = normalizeVec(
      lerp(widthStartDir.x, widthEndDir.x, t),
      lerp(widthStartDir.y, widthEndDir.y, t),
      localNormal.x,
      localNormal.y
    );
    const width = lerp(widthStart, widthEnd, t);
    const halfWidth = width * 0.5;

    const top = {
      x: center.x - widthBlend.x * halfWidth,
      y: center.y - widthBlend.y * halfWidth,
    };
    const bottom = {
      x: center.x + widthBlend.x * halfWidth,
      y: center.y + widthBlend.y * halfWidth,
    };

    const depth = clamp(width * 0.18, 1.2, 8);
    const depthSeed = {
      x: tangentDir.x * 0.42 + localNormal.x * 0.58,
      y: tangentDir.y * 0.42 + localNormal.y * 0.58,
    };
    const depthOrtho = {
      x: depthSeed.x - widthBlend.x * (depthSeed.x * widthBlend.x + depthSeed.y * widthBlend.y),
      y: depthSeed.y - widthBlend.y * (depthSeed.x * widthBlend.x + depthSeed.y * widthBlend.y),
    };
    const depthDir = normalizeVec(depthOrtho.x, depthOrtho.y, tangentDir.x, tangentDir.y);

    const topBack = {
      x: top.x - depthDir.x * depth,
      y: top.y - depthDir.y * depth,
    };
    const bottomBack = {
      x: bottom.x - depthDir.x * depth,
      y: bottom.y - depthDir.y * depth,
    };

    frontTop.push(top);
    frontBottom.push(bottom);
    backTop.push(topBack);
    backBottom.push(bottomBack);
  }

  const buildRibbonLoop = (a, b) => {
    if (!Array.isArray(a) || !Array.isArray(b) || !a.length || !b.length) return "";
    const path = [`M ${lit(a[0])}`];
    for (let i = 1; i < a.length; i += 1) path.push(`L ${lit(a[i])}`);
    for (let i = b.length - 1; i >= 0; i -= 1) path.push(`L ${lit(b[i])}`);
    path.push("Z");
    return path.join(" ");
  };

  const endIdx = frontTop.length - 1;
  const frontD = buildRibbonLoop(frontTop, frontBottom);
  const topFaceD = buildRibbonLoop(backTop, frontTop);
  const sideFaceD =
    endIdx > 0
      ? `M ${lit(frontTop[endIdx])} L ${lit(backTop[endIdx])} L ${lit(backBottom[endIdx])} L ${lit(frontBottom[endIdx])} Z`
      : "";
  return {
    frontD,
    topFaceD,
    sideFaceD,
  };
}

function motherV2RolePreviewHtml(
  entries,
  projection,
  { mode = "", surfaceW = 0, surfaceH = 0, canvasCssW = 0, canvasCssH = 0, promptMotion = null } = {}
) {
  if (!projection) return "";
  const maxSurfaceW = Math.max(1, Number(surfaceW) || 1);
  const maxSurfaceH = Math.max(1, Number(surfaceH) || 1);
  const projectedEntries = [];
  for (const entry of Array.isArray(entries) ? entries : []) {
    if (!entry) continue;
    const projectedRaw = projectWorldRectToSurface(entry.rect, projection);
    if (!projectedRaw) continue;
    // Preserve world-relative size/position in the role preview projection.
    const projected = {
      x: Math.round(clamp(Number(projectedRaw.x) || 0, 0, Math.max(0, maxSurfaceW - 1))),
      y: Math.round(clamp(Number(projectedRaw.y) || 0, 0, Math.max(0, maxSurfaceH - 1))),
      w: Math.max(1, Math.round(Number(projectedRaw.w) || 1)),
      h: Math.max(1, Math.round(Number(projectedRaw.h) || 1)),
    };
    projectedEntries.push({
      entry,
      projected,
      cx: projected.x + projected.w / 2,
      cy: projected.y + projected.h / 2,
    });
  }
  if (!projectedEntries.length) {
    return `<div class="mother-role-preview-surface"></div>`;
  }

  // Use exact projection geometry first, then apply one uniform panel-level zoom so
  // the preview stays readable without changing relative spacing between rectangles.
  {
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (const rec of projectedEntries) {
      const p = rec?.projected;
      if (!p) continue;
      const x = Number(p.x) || 0;
      const y = Number(p.y) || 0;
      const w = Math.max(1, Number(p.w) || 1);
      const h = Math.max(1, Number(p.h) || 1);
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + w);
      maxY = Math.max(maxY, y + h);
    }
    const boxW = Math.max(1, maxX - minX);
    const boxH = Math.max(1, maxY - minY);
    const targetW = Math.max(1, maxSurfaceW * clamp(Number(MOTHER_V2_ROLE_PREVIEW_PANEL_FILL_RATIO) || 0.68, 0.4, 0.9));
    const targetH = Math.max(1, maxSurfaceH * clamp(Number(MOTHER_V2_ROLE_PREVIEW_PANEL_FILL_RATIO) || 0.68, 0.4, 0.9));
    const zoom = clamp(
      Math.min(targetW / boxW, targetH / boxH),
      1,
      Math.max(1, Number(MOTHER_V2_ROLE_PREVIEW_PANEL_ZOOM_MAX) || 2.2)
    );
    if (zoom > 1.001) {
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY) / 2;
      for (const rec of projectedEntries) {
        const p = rec?.projected;
        if (!p) continue;
        const x = Number(p.x) || 0;
        const y = Number(p.y) || 0;
        const w = Math.max(1, Number(p.w) || 1);
        const h = Math.max(1, Number(p.h) || 1);
        const nextW = w * zoom;
        const nextH = h * zoom;
        const nextX = cx + (x - cx) * zoom;
        const nextY = cy + (y - cy) * zoom;
        rec.projected = {
          x: nextX,
          y: nextY,
          w: nextW,
          h: nextH,
        };
        rec.cx = nextX + nextW / 2;
        rec.cy = nextY + nextH / 2;
      }
      let scaledMinX = Number.POSITIVE_INFINITY;
      let scaledMinY = Number.POSITIVE_INFINITY;
      let scaledMaxX = Number.NEGATIVE_INFINITY;
      let scaledMaxY = Number.NEGATIVE_INFINITY;
      for (const rec of projectedEntries) {
        const p = rec?.projected;
        if (!p) continue;
        scaledMinX = Math.min(scaledMinX, Number(p.x) || 0);
        scaledMinY = Math.min(scaledMinY, Number(p.y) || 0);
        scaledMaxX = Math.max(scaledMaxX, (Number(p.x) || 0) + Math.max(1, Number(p.w) || 1));
        scaledMaxY = Math.max(scaledMaxY, (Number(p.y) || 0) + Math.max(1, Number(p.h) || 1));
      }
      const pad = Math.max(0, Math.round(Number(MOTHER_V2_ROLE_PREVIEW_PANEL_PAD_PX) || 0));
      const scaledW = Math.max(1, scaledMaxX - scaledMinX);
      const scaledH = Math.max(1, scaledMaxY - scaledMinY);
      const availW = Math.max(1, maxSurfaceW - pad * 2);
      const availH = Math.max(1, maxSurfaceH - pad * 2);
      const targetMinX = scaledW <= availW ? clamp(scaledMinX, pad, maxSurfaceW - pad - scaledW) : (maxSurfaceW - scaledW) / 2;
      const targetMinY = scaledH <= availH ? clamp(scaledMinY, pad, maxSurfaceH - pad - scaledH) : (maxSurfaceH - scaledH) / 2;
      const dx = targetMinX - scaledMinX;
      const dy = targetMinY - scaledMinY;
      for (const rec of projectedEntries) {
        const p = rec?.projected;
        if (!p) continue;
        const x = Number(p.x) + dx;
        const y = Number(p.y) + dy;
        const w = Math.max(1, Number(p.w) || 1);
        const h = Math.max(1, Number(p.h) || 1);
        const clampedX = clamp(x, -w + 1, maxSurfaceW - 1);
        const clampedY = clamp(y, -h + 1, maxSurfaceH - 1);
        rec.projected = {
          x: clampedX,
          y: clampedY,
          w,
          h,
        };
        rec.cx = clampedX + w / 2;
        rec.cy = clampedY + h / 2;
      }
    }
  }

  const subjectRec = projectedEntries.find((it) => String(it?.entry?.roleKey || "") === "subject") || null;
  const modelRec = projectedEntries.find((it) => String(it?.entry?.roleKey || "") === "model") || null;
  const subjectCenter = subjectRec ? { x: subjectRec.cx, y: subjectRec.cy } : null;
  const modelCenter = modelRec ? { x: modelRec.cx, y: modelRec.cy } : null;
  const modeKey = String(mode || "").trim().toLowerCase();
  const modeAccent = String(
    MOTHER_V2_PROPOSAL_ICON_ACCENT_BY_MODE[modeKey] || "rgba(230, 237, 243, 0.94)"
  );
  let focusCenter = null;
  if (subjectCenter && modelCenter) {
    focusCenter = {
      x: (subjectCenter.x + modelCenter.x) / 2,
      y: (subjectCenter.y + modelCenter.y) / 2,
    };
  } else if (subjectCenter) {
    focusCenter = { ...subjectCenter };
  } else if (modelCenter) {
    focusCenter = { ...modelCenter };
  } else {
    const sum = projectedEntries.reduce(
      (acc, rec) => {
        acc.x += Number(rec.cx) || 0;
        acc.y += Number(rec.cy) || 0;
        return acc;
      },
      { x: 0, y: 0 }
    );
    focusCenter = {
      x: sum.x / Math.max(1, projectedEntries.length),
      y: sum.y / Math.max(1, projectedEntries.length),
    };
  }

  let mergeRect = null;
  if (modeKey && projectedEntries.length > 1 && focusCenter) {
    const mergeBlend = motherV2RolePreviewMergeBlend(modeKey);
    const compactness = clamp(0.66 + mergeBlend * 0.24, 0.66, 0.93);
    const squareBias = clamp(0.26 + mergeBlend * 0.48, 0.26, 0.86);
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    let sumW = 0;
    let sumH = 0;
    let sumArea = 0;
    for (const rec of projectedEntries) {
      const w = Math.max(1, Number(rec?.projected?.w) || 1);
      const h = Math.max(1, Number(rec?.projected?.h) || 1);
      const x = Number(rec?.projected?.x) || 0;
      const y = Number(rec?.projected?.y) || 0;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x + w);
      maxY = Math.max(maxY, y + h);
      sumW += w;
      sumH += h;
      sumArea += w * h;
    }
    const n = Math.max(1, projectedEntries.length);
    const unionW = Math.max(1, maxX - minX);
    const unionH = Math.max(1, maxY - minY);
    const avgW = sumW / n;
    const avgH = sumH / n;
    const areaSide = Math.max(1, Math.sqrt(sumArea / n));
    const maxTargetW = Math.max(10, (Number(surfaceW) || unionW) * 0.78);
    const maxTargetH = Math.max(10, (Number(surfaceH) || unionH) * 0.78);
    let targetW = clamp(avgW * compactness + areaSide * 0.52 + unionW * 0.06, 10, maxTargetW);
    let targetH = clamp(avgH * compactness + areaSide * 0.52 + unionH * 0.06, 10, maxTargetH);
    const blendedDim = (targetW + targetH) / 2;
    targetW = motherV2BlendNumber(targetW, blendedDim, squareBias);
    targetH = motherV2BlendNumber(targetH, blendedDim, squareBias);
    const cx = Number(focusCenter.x) || 0;
    const cy = Number(focusCenter.y) || 0;
    const x = clamp(cx - targetW / 2, 0, Math.max(0, (Number(surfaceW) || targetW) - targetW));
    const y = clamp(cy - targetH / 2, 0, Math.max(0, (Number(surfaceH) || targetH) - targetH));
    mergeRect = { x, y, w: targetW, h: targetH };
  }

  const flowHtml = "";

  const rects = [];
  for (let i = 0; i < projectedEntries.length; i += 1) {
    const rec = projectedEntries[i];
    const entry = rec.entry;
    const projected = rec.projected;
    const title = entry.roleLabel ? `${entry.roleLabel}: ${entry.imageLabel}` : entry.imageLabel;
    const roleClass = entry.roleKey ? ` is-${escapeHtml(entry.roleKey)}` : "";
    const profile = motherV2RolePreviewMotionProfile({
      mode,
      roleKey: entry.roleKey,
      centerX: rec.cx,
      centerY: rec.cy,
      rectW: projected.w,
      rectH: projected.h,
      surfaceW,
      surfaceH,
      subjectCenter,
      modelCenter,
      focusCenter,
      mergeRect,
      promptMotion,
    });
    const animKindRaw = String(profile.animKind || "").trim().toLowerCase();
    const animKind = [
      "flow",
      "amplify",
      "transcend",
      "destabilize",
      "purify",
      "hybridize",
      "mythologize",
      "monumentalize",
      "fracture",
      "romanticize",
      "alienate",
    ].includes(animKindRaw)
      ? animKindRaw
      : "flow";
    const accentKey = String(
      entry.accentKey || motherV2PaletteKeyByImageId(entry.imageId) || entry.imageId || entry.imagePath || entry.imageLabel || ""
    );
    const accent = String(entry.accent || googleBrandRectColorForKey(accentKey, 0.94));
    const entryTransform = readFreeformRectTransform(entry.transform || null);
    const outerStyle = `left:${projected.x}px;top:${projected.y}px;width:${projected.w}px;height:${projected.h}px;z-index:${
      20 + i
    };--mother-role-accent:${escapeHtml(accent)};--mother-role-base-rot:${escapeHtml(
      `${entryTransform.rotateDeg}deg`
    )};--mother-role-base-skew:${escapeHtml(`${entryTransform.skewXDeg}deg`)}`;
    const coreStyle = `--mother-role-stagger:${(i % 8) * 90}ms;--mother-role-mode-ms:${escapeHtml(
      `${Math.max(420, Number(profile.speedMs) || 3000)}ms`
    )};--mother-role-pre-mx:${escapeHtml(`${profile.preMx}px`)};--mother-role-pre-my:${escapeHtml(
      `${profile.preMy}px`
    )};--mother-role-pre-scale:${escapeHtml(String(profile.preScale))};--mother-role-pre-resize-x:${escapeHtml(
      String(profile.preResizeX)
    )};--mother-role-pre-resize-y:${escapeHtml(String(profile.preResizeY))};--mother-role-pre-rot:${escapeHtml(
      `${profile.preRot}deg`
    )};--mother-role-pre-sat:${escapeHtml(String(profile.preSat))};--mother-role-pre-bright:${escapeHtml(
      String(profile.preBright)
    )};--mother-role-pre-alpha:${escapeHtml(String(profile.preAlpha))};--mother-role-mx:${escapeHtml(
      `${profile.mx}px`
    )};--mother-role-my:${escapeHtml(`${profile.my}px`)};--mother-role-scale:${escapeHtml(
      String(profile.scale)
    )};--mother-role-resize-x:${escapeHtml(String(profile.resizeX))};--mother-role-resize-y:${escapeHtml(
      String(profile.resizeY)
    )};--mother-role-rot:${escapeHtml(`${profile.rot}deg`)};--mother-role-sat:${escapeHtml(
      String(profile.sat)
    )};--mother-role-bright:${escapeHtml(String(profile.bright))};--mother-role-alpha:${escapeHtml(
      String(profile.alpha)
    )};--mother-role-jitter-ax:${escapeHtml(`${profile.jitterAx}px`)};--mother-role-jitter-ay:${escapeHtml(
      `${profile.jitterAy}px`
    )}`;
    rects.push(`
      <div
        class="mother-role-preview-rect${roleClass}"
        data-image-id="${escapeHtml(String(entry.imageId || entry.imagePath || entry.imageLabel || ""))}"
        data-anim="${escapeHtml(animKind)}"
        style="${outerStyle}"
        title="${escapeHtml(title)}"
        aria-label="${escapeHtml(title)}"
      >
        <div class="mother-role-preview-rect-core" aria-hidden="true" style="${coreStyle}">
          <span class="mother-role-preview-corner" data-corner="0" aria-hidden="true"></span>
          <span class="mother-role-preview-corner" data-corner="1" aria-hidden="true"></span>
          <span class="mother-role-preview-corner" data-corner="2" aria-hidden="true"></span>
          <span class="mother-role-preview-corner" data-corner="3" aria-hidden="true"></span>
        </div>
      </div>
    `);
  }
  const mergeCore = mergeRect
    ? `<div class="mother-role-preview-merge-core" style="left:${Math.round(mergeRect.x)}px;top:${Math.round(mergeRect.y)}px;width:${Math.max(1, Math.round(mergeRect.w))}px;height:${Math.max(1, Math.round(mergeRect.h))}px;--mother-role-accent:${escapeHtml(modeAccent)};"></div>`
    : "";
  const viewport = motherV2RolePreviewViewportHtml(projection, { canvasCssW, canvasCssH });
  return `<div class="mother-role-preview-surface">${flowHtml}${rects.join("")}${mergeCore}${viewport}</div>`;
}

function motherV2RolePreviewCornerPoint(marker, surfaceRect) {
  if (!marker || !surfaceRect) return null;
  const rect = marker.getBoundingClientRect();
  return {
    x: rect.left + rect.width * 0.5 - surfaceRect.left,
    y: rect.top + rect.height * 0.5 - surfaceRect.top,
  };
}

function motherV2RolePreviewBuildCornerMap(root) {
  if (!root) return null;
  const surface = root.querySelector(".mother-role-preview-surface");
  if (!surface) return null;
  const surfaceRect = surface.getBoundingClientRect();
  const surfaceW = Math.max(1, surfaceRect.width);
  const surfaceH = Math.max(1, surfaceRect.height);
  const rectEls = root.querySelectorAll(".mother-role-preview-rect[data-image-id]");
  const byId = new Map();
  for (const rectEl of rectEls) {
    const imageId = String(rectEl?.dataset?.imageId || "").trim();
    if (!imageId) continue;
    const points = [];
    for (let i = 0; i < 4; i += 1) {
      const marker = rectEl.querySelector(`.mother-role-preview-corner[data-corner="${i}"]`);
      const pt = motherV2RolePreviewCornerPoint(marker, surfaceRect);
      if (!pt) break;
      points.push(pt);
    }
    if (points.length !== 4) {
      const rr = rectEl.getBoundingClientRect();
      const x = rr.left - surfaceRect.left;
      const y = rr.top - surfaceRect.top;
      const w = Math.max(1, rr.width);
      const h = Math.max(1, rr.height);
      points.length = 0;
      points.push(
        { x, y },
        { x: x + w, y },
        { x: x + w, y: y + h },
        { x, y: y + h }
      );
    }
    const center = points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
    byId.set(imageId, {
      corners: points,
      cx: center.x / 4,
      cy: center.y / 4,
    });
  }
  return {
    byId,
    surfaceW,
    surfaceH,
  };
}

function motherV2SyncRolePreviewSankeyStreams(root) {
  if (!root) return;
  const streams = root.querySelectorAll(".mother-role-preview-sankey-stream");
  if (!streams.length) return;
  const cornerMap = motherV2RolePreviewBuildCornerMap(root);
  if (!cornerMap) return;
  const { byId, surfaceW, surfaceH } = cornerMap;
  const modeKey = String(root.getAttribute("data-mode") || "").trim().toLowerCase();
  const bendAmount = motherV2SankeyBendAmountForMode(modeKey, performance.now());
  const midpoint = (a, b) => ({
    x: ((Number(a?.x) || 0) + (Number(b?.x) || 0)) * 0.5,
    y: ((Number(a?.y) || 0) + (Number(b?.y) || 0)) * 0.5,
  });
  for (const stream of streams) {
    const sourceId = String(stream?.dataset?.sourceId || "").trim();
    const targetId = String(stream?.dataset?.targetId || "").trim();
    const source = sourceId ? byId.get(sourceId) : null;
    const target = targetId ? byId.get(targetId) : null;
    if (!source || !target) continue;
    if (!Array.isArray(source?.corners) || source.corners.length !== 4) continue;
    if (!Array.isArray(target?.corners) || target.corners.length !== 4) continue;
    const sourceTop = midpoint(source.corners[0], source.corners[1]);
    const sourceBottom = midpoint(source.corners[3], source.corners[2]);
    const targetTop = midpoint(target.corners[0], target.corners[1]);
    const targetBottom = midpoint(target.corners[3], target.corners[2]);
    const laneOffset = Number(stream?.dataset?.laneOffset) || 0;
    const prismGeom = motherV2BuildSankeyPrismFromEdgePair({
      sourceTop,
      sourceBottom,
      targetTop,
      targetBottom,
      surfaceW,
      surfaceH,
      laneOffset,
      bendAmount,
    });
    if (!prismGeom) continue;
    const setPathD = (role, d) => {
      const path = stream.querySelector(`path[data-stream-role="${role}"]`);
      if (!path || typeof d !== "string" || !d) return;
      path.setAttribute("d", d);
    };
    setPathD("core", prismGeom.frontD);
    setPathD("top", prismGeom.topFaceD);
    setPathD("side", prismGeom.sideFaceD);
  }
}

function motherV2StopRolePreviewSankeyTicker() {
  if (motherRolePreviewSankeyRaf) cancelAnimationFrame(motherRolePreviewSankeyRaf);
  motherRolePreviewSankeyRaf = 0;
  motherRolePreviewSankeyBendEpochMs = 0;
}

function motherV2RolePreviewSankeyTick() {
  motherRolePreviewSankeyRaf = 0;
  const root = els.motherRolePreview;
  if (!root || root.classList.contains("hidden")) return;
  motherV2SyncRolePreviewSankeyStreams(root);
  if (root.getAttribute("data-motion") === "paused") return;
  motherRolePreviewSankeyRaf = requestAnimationFrame(motherV2RolePreviewSankeyTick);
}

function motherV2StartRolePreviewSankeyTicker() {
  // Sankey visualization is disabled; keep rectangle-only role preview rendering.
  motherV2StopRolePreviewSankeyTicker();
}

function renderMotherRolePreview() {
  const root = els.motherRolePreview;
  if (!root) return;
  const phase = state.motherIdle?.phase || motherIdleInitialState();
  if (phase === MOTHER_IDLE_STATES.DRAFTING || phase === MOTHER_IDLE_STATES.COOLDOWN) {
    motherV2StopRolePreviewSankeyTicker();
    root.innerHTML = "";
    root.dataset.previewSig = "";
    root.classList.add("hidden");
    return;
  }
  const hasProposalImageSet = motherV2HasProposalImageSet();
  if (!hasProposalImageSet) {
    motherV2StopRolePreviewSankeyTicker();
    root.innerHTML = "";
    root.dataset.previewSig = "";
    root.classList.add("hidden");
    return;
  }
  const animationMode = motherV2RolePreviewAnimationMode();
  if (animationMode) {
    root.setAttribute("data-mode", animationMode);
  } else {
    root.removeAttribute("data-mode");
  }
  root.setAttribute("data-motion", motherV2RolePreviewMotionState());

  const wrap = els.canvasWrap;
  const canvasCssW = Math.max(1, Math.round(Number(wrap?.clientWidth) || 0));
  const canvasCssH = Math.max(1, Math.round(Number(wrap?.clientHeight) || 0));
  if (canvasCssW > 1 && canvasCssH > 1) {
    ensureFreeformLayoutRectsCss(state.images || [], canvasCssW, canvasCssH);
  }

  const entries = motherV2RolePreviewEntries();
  root.classList.remove("hidden");
  const rootW = Math.round(Number(root.clientWidth) || 0);
  const rootH = Math.round(Number(root.clientHeight) || 0);
  if (!rootW || !rootH) return;

  const rootStyle = window.getComputedStyle(root);
  const surfaceInset = Math.max(0, Math.round(parseFloat(rootStyle.getPropertyValue("--mother-role-preview-inset")) || 6));
  const surfaceW = Math.max(1, rootW - surfaceInset * 2);
  const surfaceH = Math.max(1, rootH - surfaceInset * 2);
  const projection = computeWorldProjection({
    canvasCssW,
    canvasCssH,
    surfaceW,
    surfaceH,
    padPx: 6,
  });
  if (!projection) return;
  const promptMotion = motherV2CurrentPromptMotionProfile();
  const promptMotionKey = String(promptMotion?.key || "").trim();

  const sig = motherV2RolePreviewSignature(entries, {
    canvasCssW,
    canvasCssH,
    surfaceW,
    surfaceH,
    animationMode,
    promptMotionKey,
  });
  if (!sig) return;
  if (root.dataset.previewSig === sig) {
    motherV2SyncRolePreviewViewport(root, projection, { canvasCssW, canvasCssH });
    motherV2StopRolePreviewSankeyTicker();
    return;
  }

  const html = motherV2RolePreviewHtml(entries, projection, {
    mode: animationMode,
    surfaceW,
    surfaceH,
    canvasCssW,
    canvasCssH,
    promptMotion,
  });
  if (!html) {
    motherV2StopRolePreviewSankeyTicker();
    root.innerHTML = "";
    root.dataset.previewSig = "";
    return;
  }
  root.innerHTML = html;
  root.dataset.previewSig = sig;
  motherV2SyncRolePreviewViewport(root, projection, { canvasCssW, canvasCssH });
  motherV2StopRolePreviewSankeyTicker();
}

function buildMotherText() {
  const idle = state.motherIdle || null;
  const phase = idle?.phase || motherIdleInitialState();
  const cooldownMs = Math.max(0, (Number(idle?.cooldownUntil) || 0) - Date.now());
  const undoAvailable = motherV2CommitUndoAvailable();
  const canPropose = motherIdleHasArmedCanvas();

  if (phase === MOTHER_IDLE_STATES.WATCHING) {
    return "";
  }
  if (phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
    if (Array.isArray(idle?.pendingVisionImageIds) && idle.pendingVisionImageIds.length) return "";
    if (idle?.pendingIntent) return "";
    return "";
  }
  if (phase === MOTHER_IDLE_STATES.DRAFTING) {
    return "";
  }
  if (phase === MOTHER_IDLE_STATES.OFFERING) {
    if (isReelSizeLocked()) {
      return "Proposal ready. âœ“ deploy, R reroll.";
    }
    return "Proposal ready. âœ“ deploy, âœ• dismiss, R reroll.";
  }
  if (phase === MOTHER_IDLE_STATES.COMMITTING) {
    return "Committing draft to canvasâ€¦";
  }
  if (phase === MOTHER_IDLE_STATES.COOLDOWN) {
    const sec = (cooldownMs / 1000).toFixed(1);
    const undo = undoAvailable ? "\nUNDO READY" : "";
    return `Cooling down ${sec}s${undo}`;
  }

  if (!state.images.length) {
    return "";
  }
  if (!canPropose) {
    return "";
  }
  if (motherV2InCooldown()) {
    const sec = (cooldownMs / 1000).toFixed(1);
    return `Cooling down ${sec}s`;
  }

  const aov = state.alwaysOnVision;
  const raw = typeof aov?.lastText === "string" ? aov.lastText.trim() : "";
  const hasOutput = Boolean(raw);

  if (aov?.enabled) {
    if (aov.rtState === "connecting" && !aov.pending && !hasOutput) {
      if (isReelSizeLocked()) return "";
      return "Mother connectingâ€¦";
    }
    if (aov.pending) {
      if (isReelSizeLocked()) return "";
      return "Mother scanningâ€¦";
    }
    if (phase === MOTHER_IDLE_STATES.OBSERVING && motherIdleHasArmedCanvas()) {
      return "";
    }
    return "Pause for intent hypothesis.";
  }

  const fallback = typeof state.lastTipText === "string" ? state.lastTipText.trim() : "";
  return fallback || "Pause for intent hypothesis.";
}

function motherV2StatusText() {
  const idle = state.motherIdle || null;
  const phase = idle?.phase || motherIdleInitialState();
  const canPropose = motherIdleHasArmedCanvas();
  if (
    (phase === MOTHER_IDLE_STATES.OBSERVING || phase === MOTHER_IDLE_STATES.WATCHING) &&
    idle?.liveProposalUpdating &&
    motherV2CanUseLiveProposalRefresh(idle)
  ) {
    return "Updating proposal";
  }
  if (!canPropose && (phase === MOTHER_IDLE_STATES.WATCHING || phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING)) {
    return "Observing";
  }
  if (phase === MOTHER_IDLE_STATES.OBSERVING) return "Observing";
  if (phase === MOTHER_IDLE_STATES.WATCHING) return "Watching";
  if (phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
    if (idle?.liveProposalUpdating) return "Updating proposal";
    if (Array.isArray(idle?.pendingVisionImageIds) && idle.pendingVisionImageIds.length) return "Proposing";
    if (idle?.pendingIntent) return "Proposing";
    if (idle?.intent && typeof idle.intent === "object") return "Proposed";
    return "Proposing";
  }
  if (phase === MOTHER_IDLE_STATES.DRAFTING) return "Drafting";
  if (phase === MOTHER_IDLE_STATES.OFFERING) return "Proposal ready";
  if (phase === MOTHER_IDLE_STATES.COMMITTING) return "Deploying";
  if (phase === MOTHER_IDLE_STATES.COOLDOWN) {
    const cooldownMs = Math.max(0, (Number(idle?.cooldownUntil) || 0) - Date.now());
    return `Cooldown ${(cooldownMs / 1000).toFixed(1)}s`;
  }
  return "";
}

function motherV2LabelsFromIds(ids = [], { limit = 2 } = {}) {
  const out = [];
  const maxCount = Number.isFinite(Number(limit)) && Number(limit) > 0 ? Math.floor(Number(limit)) : 2;
  for (const rawId of Array.isArray(ids) ? ids : []) {
    const imageId = String(rawId || "").trim();
    if (!imageId) continue;
    if (!isVisibleCanvasImageId(imageId)) continue;
    const label = motherV2ImageLabelById(imageId);
    if (!label || out.includes(label)) continue;
    out.push(label);
    if (out.length >= maxCount) break;
  }
  return out;
}

function motherV2HasRealProposalPayload(intentPayload = null) {
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : null;
  if (!intent) return false;
  if (!motherV2HasProposalImageSet()) return false;
  const mode = motherV2MaybeTransformationMode(intent.transformation_mode);
  const candidateModes = Array.isArray(intent.transformation_mode_candidates)
    ? intent.transformation_mode_candidates
        .map((entry) => motherV2MaybeTransformationMode(entry?.mode || entry?.transformation_mode))
        .filter(Boolean)
    : [];
  const hasModeSignal = Boolean(mode || candidateModes.length);
  if (!hasModeSignal) return false;
  const targetIds = motherV2NormalizeImageIdList(
    (Array.isArray(intent.target_ids) && intent.target_ids.length ? intent.target_ids : motherV2RoleIds("subject")) || []
  );
  const refIds = motherV2NormalizeImageIdList(
    (Array.isArray(intent.reference_ids) ? intent.reference_ids : motherV2RoleContextIds({ limit: 6 })) || []
  );
  const hasScopeSignal = targetIds.length > 0 || refIds.length > 0;
  const sentence = motherV2ProposalSentence(intent);
  const hasSummarySignal = typeof sentence === "string" && sentence.trim().length > 0;
  if (hasScopeSignal || hasSummarySignal) return true;
  const phase = String(state.motherIdle?.phase || "").trim();
  const phaseImpliesProposal = phase === MOTHER_IDLE_STATES.DRAFTING || phase === MOTHER_IDLE_STATES.OFFERING;
  return Boolean(phaseImpliesProposal || motherV2CurrentDraft());
}

function motherV2ProposalBadgeIconSvg(kind = "target") {
  const iconKind = String(kind || "target").trim();
  if (iconKind === "reference") {
    return '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M8.1 12a3.3 3.3 0 0 1 3.3-3.3h3.2"/><path d="M15.9 12a3.3 3.3 0 0 1-3.3 3.3H9.4"/><path d="M13.5 8.7h2.1a3.2 3.2 0 1 1 0 6.4h-2.1"/><path d="M10.5 15.3H8.4a3.2 3.2 0 0 1 0-6.4h2.1"/></svg>';
  }
  if (iconKind === "output") {
    return '<svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3.8 14.2 9.2 20 12l-5.8 2.8L12 20.2l-2.2-5.4L4 12l5.8-2.8z"/></svg>';
  }
  return '<svg viewBox="0 0 24 24" aria-hidden="true"><circle cx="12" cy="12" r="7"/><circle cx="12" cy="12" r="2.2"/></svg>';
}

function motherV2IntentSourceKind(source = "") {
  const raw = String(source || "").trim().toLowerCase();
  if (!raw) return "";
  if (raw === "realtime") return "realtime";
  if (realtimeSourceSupported(raw)) return "realtime";
  if (raw.startsWith("openai_realtime") || raw.startsWith("gemini_flash")) return "realtime";
  if (raw.includes("intent_rt") || raw.includes("realtime")) return "realtime";
  return "";
}

function motherV2ProposalCardHtml({ phase, statusText, next, readoutHtml }) {
  const normalizedPhase = String(phase || "").trim();
  const isDraftingPhase = normalizedPhase === MOTHER_IDLE_STATES.DRAFTING;
  const isOfferingPhase = normalizedPhase === MOTHER_IDLE_STATES.OFFERING;
  const isCooldownPhase = normalizedPhase === MOTHER_IDLE_STATES.COOLDOWN;
  const visibleImageCount = motherIdleBaseImageItems().length;
  if (visibleImageCount < MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL) return "";
  const cardVisiblePhases = new Set([
    MOTHER_IDLE_STATES.WATCHING,
    MOTHER_IDLE_STATES.OBSERVING,
    MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING,
    MOTHER_IDLE_STATES.DRAFTING,
    MOTHER_IDLE_STATES.OFFERING,
    MOTHER_IDLE_STATES.COMMITTING,
    MOTHER_IDLE_STATES.COOLDOWN,
  ]);
  if (!cardVisiblePhases.has(normalizedPhase)) {
    return "";
  }
  const intent = state.motherIdle?.intent && typeof state.motherIdle.intent === "object" ? state.motherIdle.intent : null;
  const hasPendingProposalWork = Boolean(
    normalizedPhase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
      (state.motherIdle?.pendingIntent || state.motherIdle?.pendingPromptCompile)
  );
  const hasProposalContext = Boolean(
    motherV2HasRealProposalPayload(intent) ||
      motherV2CurrentDraft() ||
      hasPendingProposalWork ||
      normalizedPhase === MOTHER_IDLE_STATES.WATCHING ||
      normalizedPhase === MOTHER_IDLE_STATES.OBSERVING ||
      normalizedPhase === MOTHER_IDLE_STATES.DRAFTING ||
      normalizedPhase === MOTHER_IDLE_STATES.COMMITTING ||
      normalizedPhase === MOTHER_IDLE_STATES.COOLDOWN
  );
  if (!hasProposalContext) return "";
  const explicitMode = motherV2MaybeTransformationMode(intent?.transformation_mode);
  const rememberedMode = motherV2MaybeTransformationMode(state.motherIdle?.lastProposalMode);
  const modeForDisplay = explicitMode || rememberedMode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
  const hasConfirmedIntentSource = Boolean(motherV2IntentSourceKind(intent?._intent_source_kind));
  const modeLabel = hasConfirmedIntentSource ? motherV2ProposalModeLabel(modeForDisplay) : "";
  const modeAccent = hasConfirmedIntentSource ? motherV2ProposalIconAccent(modeForDisplay) : "";
  const modeAria = hasConfirmedIntentSource ? `Proposal mode ${modeLabel}` : "";
  const proposalVisualHtml = motherV2ProposalIconsHtml(intent, { phase: normalizedPhase });
  const visualHtml = readoutHtml || proposalVisualHtml;
  const visualLine = visualHtml ? `<div class="mother-proposal-visual">${visualHtml}</div>` : "";
  const flowLine = `<div class="mother-proposal-flow">${visualLine}</div>`;
  const modeLine = !isDraftingPhase && !isOfferingPhase && !isCooldownPhase && modeLabel
    ? `<div class="mother-proposal-mode" style="--proposal-mode-accent:${escapeHtml(modeAccent)}" aria-label="${escapeHtml(modeAria)}">${escapeHtml(modeLabel)}</div>`
    : "";
  return `
    <div class="mother-proposal-card" aria-label="Mother proposal" data-compact="1">
      ${flowLine}
      ${modeLine}
    </div>
  `;
}

function motherV2PhaseCardKind(phase = null) {
  const statePhase = phase || state.motherIdle?.phase || motherIdleInitialState();
  if (statePhase === MOTHER_IDLE_STATES.COOLDOWN) return "cooldown";
  if (statePhase === MOTHER_IDLE_STATES.OFFERING) return "ready";
  if (statePhase !== MOTHER_IDLE_STATES.DRAFTING) return "";
  return "drafting";
}

function renderMotherReadout() {
  renderMotherControls();
  syncMotherIntentSourceIndicator();
  const phase = state.motherIdle?.phase || motherIdleInitialState();
  const isPhaseCardState =
    phase === MOTHER_IDLE_STATES.DRAFTING ||
    phase === MOTHER_IDLE_STATES.OFFERING ||
    phase === MOTHER_IDLE_STATES.COOLDOWN;
  if (els.motherPanel) {
    els.motherPanel.classList.toggle(
      "mother-drafting-view",
      isPhaseCardState || motherPhaseCardExitInFlight
    );
  }
  renderMotherRolePreview();
  if (!els.tipsText) return;
  if (isPhaseCardState && !motherPhaseCardExitInFlight) {
    clearTimeout(motherPhaseCardExitTimer);
    els.tipsText.classList.remove("mother-phase-card-exit");
  }
  motherV2SyncLayeredPanel();
  const next = buildMotherText();
  const aov = state.alwaysOnVision;
  const isRealtime = realtimeSourceSupported(aov?.lastMeta?.source);
  const hasOutput = typeof aov?.lastText === "string" && aov.lastText.trim();
  const proposalIconsHtml = motherV2ProposalIconsHtml(state.motherIdle?.intent || null, { phase });
  const draftStatusHtml = motherV2DraftStatusHtml({ phase });
  const statusText = motherV2StatusText();
  const readoutHtml = phase === MOTHER_IDLE_STATES.DRAFTING || phase === MOTHER_IDLE_STATES.OFFERING || phase === MOTHER_IDLE_STATES.COOLDOWN
    ? draftStatusHtml
    : proposalIconsHtml || draftStatusHtml;
  const proposalCardHtml = motherV2ProposalCardHtml({ phase, statusText, next, readoutHtml });
  const renderKey = proposalCardHtml || readoutHtml || next;
  const nextPhaseCardKind = motherV2PhaseCardKind(phase);
  const currentPhaseCardKind = String(els.tipsText.dataset.phaseCardKind || "").trim();
  const phaseCardMissing = isPhaseCardState && !els.tipsText.querySelector(".mother-phase-icons.is-draft-card");
  const changed = phaseCardMissing || renderKey !== lastMotherRenderedText;
  const shouldTypeout = Boolean(
    phase === MOTHER_IDLE_STATES.OBSERVING && aov?.enabled && isRealtime && hasOutput && !aov.pending
  );

  if (els.motherState) {
    const normalizedPhase = String(phase || "").trim();
    const phaseLabel = normalizedPhase
      ? normalizedPhase.replace(/_/g, " ").replace(/\b([a-z])/g, (m) => m.toUpperCase())
      : "";
    const normalizedStatus = String(statusText || "")
      .trim()
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "");
    els.motherState.textContent = statusText;
    els.motherState.setAttribute("data-phase", String(phase || ""));
    if (normalizedStatus) {
      els.motherState.setAttribute("data-status", normalizedStatus);
    } else {
      els.motherState.removeAttribute("data-status");
    }
    const accessibilityLabel = statusText || phaseLabel;
    if (accessibilityLabel) {
      els.motherState.setAttribute("aria-label", accessibilityLabel);
    } else {
      els.motherState.removeAttribute("aria-label");
    }
    const stateRow = els.motherState.closest(".mother-state-row");
    if (stateRow) {
      stateRow.classList.toggle("hidden", !accessibilityLabel);
    }
  }
  els.tipsText.classList.toggle("mother-proposal-active", Boolean(proposalCardHtml));
  if (els.motherPanel) {
    els.motherPanel.classList.toggle("mother-proposal-overlay", Boolean(proposalCardHtml));
  }
  els.tipsText.classList.remove("mother-cursor");
  const showingPhaseCard = Boolean(els.tipsText.querySelector(".mother-phase-icons.is-draft-card"));
  const isPhaseToPhaseSwap = Boolean(
    isPhaseCardState && nextPhaseCardKind && currentPhaseCardKind && nextPhaseCardKind !== currentPhaseCardKind
  );
  const shouldFadeOutExistingPhaseCard = Boolean(
    showingPhaseCard &&
      !motherPhaseCardExitInFlight &&
      (
        !isPhaseCardState ||
        isPhaseToPhaseSwap
      )
  );
  if (shouldFadeOutExistingPhaseCard) {
    clearTimeout(motherPhaseCardExitTimer);
    motherPhaseCardExitInFlight = true;
    els.tipsText.classList.add("mother-phase-card-exit");
    motherPhaseCardExitTimer = setTimeout(() => {
      if (!els.tipsText) return;
      els.tipsText.classList.remove("mother-phase-card-exit");
      delete els.tipsText.dataset.phaseCardKind;
      if (!isPhaseToPhaseSwap) {
        els.tipsText.innerHTML = "";
      }
      motherPhaseCardExitInFlight = false;
      lastMotherRenderedText = null;
      renderMotherReadout();
    }, 170);
    return;
  }
  if (motherPhaseCardExitInFlight) return;

  if (!changed) {
    return;
  }

  lastMotherRenderedText = renderKey;
  if (shouldTypeout && !proposalCardHtml) {
    motherV2TriggerReadoutFade();
    startMotherTypeout(next);
    return;
  }

  stopMotherTypeout();
  if (proposalCardHtml) {
    els.tipsText.innerHTML = proposalCardHtml;
    if (nextPhaseCardKind) {
      els.tipsText.dataset.phaseCardKind = nextPhaseCardKind;
    } else {
      delete els.tipsText.dataset.phaseCardKind;
    }
    motherV2TriggerReadoutFade();
    return;
  }
  if (readoutHtml) {
    els.tipsText.innerHTML = readoutHtml;
    if (nextPhaseCardKind) {
      els.tipsText.dataset.phaseCardKind = nextPhaseCardKind;
    } else {
      delete els.tipsText.dataset.phaseCardKind;
    }
    motherV2TriggerReadoutFade();
    return;
  }
  delete els.tipsText.dataset.phaseCardKind;
  els.tipsText.textContent = next;
  motherV2TriggerReadoutFade();
}

function syncMotherPortrait() {
  const overlay = els.motherOverlay || els.motherPanel;
  const videoEl = els.motherVideo;

  const motherRunning = Boolean(state.mother?.running);
  const reelLocked = isReelSizeLocked();
  const aov = state.alwaysOnVision;
  const now = Date.now();
  const mother = state.mother;
  const hasImages = Boolean(state.images && state.images.length);
  const pending = Boolean(aov?.enabled && aov.pending);
  const pendingAt = Math.max(0, Number(aov?.pendingAt) || 0);

  // Presentability hack: keep the realtime "pulse" + video visible for a minimum duration
  // so short calls still read as "alive", and subsequent calls don't restart it.
  if (!aov?.enabled) {
    mother.rtHoldUntil = 0;
    clearTimeout(mother.rtHoldTimer);
    mother.rtHoldTimer = null;
  } else if (pending) {
    const until = (pendingAt || now) + MOTHER_REALTIME_MIN_MS;
    mother.rtHoldUntil = Math.max(Number(mother.rtHoldUntil) || 0, until);
    clearTimeout(mother.rtHoldTimer);
    mother.rtHoldTimer = null;
  }

  const holdUntil = Math.max(0, Number(mother.rtHoldUntil) || 0);
  const held = Boolean(aov?.enabled && holdUntil && now < holdUntil);
  const realtimeActive = Boolean(aov?.enabled && (pending || held));
  const idleFor = now - (state.lastMotherHotAt || 0);
  const userHot = Boolean(aov?.enabled && hasImages && idleFor < MOTHER_USER_HOT_IDLE_MS);
  const userHotUntil = Math.max(0, Number(state.lastMotherHotAt) || 0) + MOTHER_USER_HOT_IDLE_MS;
  const idlePhase = state.motherIdle?.phase || motherIdleInitialState();

  // Realtime border/video is driven by Mother's idle suggestion flow window, with
  // hysteresis to prevent brief watch-phase spikes from blinking the portrait/border.
  const rawRealtime = !reelLocked && !motherRunning && hasImages && motherIdleUsesRealtimeVisual(idlePhase);
  if (rawRealtime) {
    mother.rtVisualRawSince = Math.max(0, Number(mother.rtVisualRawSince) || 0) || now;
  } else {
    mother.rtVisualRawSince = 0;
  }

  let showRealtime = Boolean(mother.rtVisualActive);
  const rawSince = Math.max(0, Number(mother.rtVisualRawSince) || 0);
  const minUntil = Math.max(0, Number(mother.rtVisualMinUntil) || 0);
  if (rawRealtime) {
    if (!showRealtime && rawSince && now - rawSince >= MOTHER_RT_VISUAL_ON_DELAY_MS) {
      showRealtime = true;
      mother.rtVisualActive = true;
      mother.rtVisualMinUntil = now + MOTHER_RT_VISUAL_MIN_ON_MS;
    }
  } else if (showRealtime && now >= minUntil) {
    showRealtime = false;
    mother.rtVisualActive = false;
    mother.rtVisualMinUntil = 0;
  }
  if (!showRealtime && !rawRealtime) {
    mother.rtVisualMinUntil = 0;
  }

  if (els.canvasWrap) {
    els.canvasWrap.classList.toggle("mother-rt-active", showRealtime);
  }

  const refreshAts = [];
  if (!pending) {
    if (held) refreshAts.push(holdUntil);
    if (userHot) refreshAts.push(userHotUntil);
  }
  if (rawRealtime && !showRealtime && rawSince) {
    refreshAts.push(rawSince + MOTHER_RT_VISUAL_ON_DELAY_MS);
  }
  if (!rawRealtime && showRealtime && minUntil) {
    refreshAts.push(minUntil);
  }
  const refreshAt = refreshAts.length ? Math.min(...refreshAts) : 0;
  if (refreshAt && refreshAt > now) {
    clearTimeout(mother.rtHoldTimer);
    mother.rtHoldTimer = setTimeout(() => {
      mother.rtHoldTimer = null;
      syncMotherPortrait();
    }, Math.max(30, refreshAt - Date.now() + 24));
  } else {
    clearTimeout(mother.rtHoldTimer);
    mother.rtHoldTimer = null;
  }

  // In Reel mode, keep Mother on a single stable loop to avoid frequent clip source
  // swaps while idle-state phases change.
  const mode = reelLocked ? (motherRunning ? "takeover" : "idle") : motherRunning ? "takeover" : showRealtime ? "realtime" : "idle";
  const src =
    mode === "takeover"
      ? MOTHER_VIDEO_TAKEOVER_SRC
      : mode === "realtime"
        ? MOTHER_VIDEO_REALTIME_SRC
        : mode === "working"
          ? MOTHER_VIDEO_WORKING_SRC
          : MOTHER_VIDEO_IDLE_SRC;

  if (overlay) overlay.classList.toggle("busy", mode !== "idle");
  if (!videoEl) return;

  if (!videoEl.hasAttribute("muted")) videoEl.muted = true;
  videoEl.loop = true;
  videoEl.autoplay = true;
  videoEl.playsInline = true;
  // Mirror only during Mother takeover so she faces left.
  videoEl.style.transform = mode === "takeover" ? "scaleX(-1) scale(1.02)" : "scale(1.02)";

  const nextKey = `${mode}:${src}`;
  const lastAssignedSrc = String(videoEl.dataset.motherSrc || "");
  if (state.portraitMedia.activeKeyMother !== nextKey || (src && lastAssignedSrc !== String(src))) {
    state.portraitMedia.activeKeyMother = nextKey;
    videoEl.classList.remove("hidden");
    videoEl.dataset.motherSrc = String(src || "");
    videoEl.src = src;
    try {
      videoEl.currentTime = 0;
    } catch (_) {}
    try {
      videoEl.load();
    } catch (_) {}
  }
  videoEl.classList.remove("hidden");

  try {
    const p = videoEl.play();
    if (p && typeof p.catch === "function") p.catch(() => {});
  } catch (_) {}
}

function motherV2CollectCommitSeedIds(intent = null) {
  const ids = [];
  const pushId = (rawId) => {
    const id = String(rawId || "").trim();
    if (!id) return;
    if (!isVisibleCanvasImageId(id)) return;
    if (!ids.includes(id)) ids.push(id);
  };
  const pushMany = (list) => {
    for (const rawId of Array.isArray(list) ? list : []) pushId(rawId);
  };
  const normalizedIntent = intent && typeof intent === "object" ? intent : null;
  const roles = normalizedIntent?.roles && typeof normalizedIntent.roles === "object"
    ? normalizedIntent.roles
    : null;
  for (const role of MOTHER_V2_ROLE_KEYS) {
    pushMany(roles?.[role]);
  }
  pushMany(normalizedIntent?.target_ids);
  pushMany(normalizedIntent?.reference_ids);
  pushMany(state.pendingMotherDraft?.sourceIds);
  if (!ids.length) {
    pushMany(motherV2RoleContextIds({ limit: Number.POSITIVE_INFINITY }));
  }
  return ids;
}

function motherV2OfferingHiddenSeedIds() {
  // Keep parent inputs visible while Mother is drafting/offering.
  // We intentionally no-op this legacy hide path and dim instead.
  return new Set();
}

function motherV2OfferingDimSeedIds() {
  const idle = state.motherIdle;
  if (!idle) return new Set();
  if (idle.phase !== MOTHER_IDLE_STATES.OFFERING) return new Set();
  if (state.canvasMode !== "multi") return new Set();
  if (!motherV2CurrentDraft()) return new Set();
  const intent = idle.intent && typeof idle.intent === "object" ? idle.intent : null;
  const seedIds = motherV2CollectCommitSeedIds(intent);
  return new Set(
    seedIds
      .map((rawId) => String(rawId || "").trim())
      .filter((id) => Boolean(id) && state.imagesById.has(id))
  );
}

function motherV2SnapshotImageForUndo(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return null;
  const item = state.imagesById.get(id) || null;
  if (!item?.path) return null;
  const rect = state.freeformRects.get(id) || null;
  const imageIndex = (state.images || []).findIndex((entry) => String(entry?.id || "") === id);
  const zIndex = (state.freeformZOrder || []).indexOf(id);
  const selectedIndex = getSelectedIds().indexOf(id);
  return {
    id,
    imageIndex,
    zIndex,
    selectedIndex,
    wasActive: state.activeId === id,
    rect: rect ? { ...rect } : null,
    item: {
      id,
      path: String(item.path),
      receiptPath: item.receiptPath ? String(item.receiptPath) : null,
      kind: item.kind ? String(item.kind) : null,
      source: item.source ? String(item.source) : null,
      label: item.label ? String(item.label) : null,
      timelineNodeId: item.timelineNodeId ? String(item.timelineNodeId) : null,
      visionDesc: item.visionDesc ? String(item.visionDesc) : null,
      visionDescMeta: item.visionDescMeta && typeof item.visionDescMeta === "object" ? { ...item.visionDescMeta } : null,
      width: Number(item.width) || null,
      height: Number(item.height) || null,
    },
  };
}

async function motherV2DiscardCommitSeedImages({ seedIds = [], keepIds = [] } = {}) {
  const keep = new Set(
    (Array.isArray(keepIds) ? keepIds : [])
      .map((v) => String(v || "").trim())
      .filter(Boolean)
  );
  const removed = [];
  const seen = new Set();
  for (const rawId of Array.isArray(seedIds) ? seedIds : []) {
    const id = String(rawId || "").trim();
    if (!id || seen.has(id) || keep.has(id)) continue;
    seen.add(id);
    const snapshot = motherV2SnapshotImageForUndo(id);
    if (!snapshot) continue;
    const ok = await removeImageFromCanvas(id).catch(() => false);
    if (ok) removed.push(snapshot);
  }
  return removed;
}

function motherV2MoveImageToIndex(imageId, targetIndex) {
  const id = String(imageId || "").trim();
  if (!id || !Array.isArray(state.images) || !state.images.length) return;
  const from = state.images.findIndex((entry) => String(entry?.id || "") === id);
  if (from < 0) return;
  const maxIndex = Math.max(0, state.images.length - 1);
  const desired = Math.max(0, Math.min(maxIndex, Math.floor(Number(targetIndex) || 0)));
  if (from === desired) return;
  const [entry] = state.images.splice(from, 1);
  state.images.splice(desired, 0, entry);
}

function motherV2MoveFreeformZToIndex(imageId, targetIndex) {
  const id = String(imageId || "").trim();
  if (!id || !Array.isArray(state.freeformZOrder) || !state.freeformZOrder.length) return;
  const from = state.freeformZOrder.indexOf(id);
  if (from < 0) return;
  const maxIndex = Math.max(0, state.freeformZOrder.length - 1);
  const desired = Math.max(0, Math.min(maxIndex, Math.floor(Number(targetIndex) || 0)));
  if (from === desired) return;
  state.freeformZOrder.splice(from, 1);
  state.freeformZOrder.splice(desired, 0, id);
}

async function motherV2RestoreDiscardedSeeds(removedSeeds = []) {
  const snapshots = (Array.isArray(removedSeeds) ? removedSeeds : [])
    .filter((entry) => entry?.item?.id && entry?.item?.path)
    .sort((a, b) => {
      const ai = Number.isFinite(Number(a?.imageIndex)) ? Number(a.imageIndex) : Number.MAX_SAFE_INTEGER;
      const bi = Number.isFinite(Number(b?.imageIndex)) ? Number(b.imageIndex) : Number.MAX_SAFE_INTEGER;
      if (ai !== bi) return ai - bi;
      const az = Number.isFinite(Number(a?.zIndex)) ? Number(a.zIndex) : Number.MAX_SAFE_INTEGER;
      const bz = Number.isFinite(Number(b?.zIndex)) ? Number(b.zIndex) : Number.MAX_SAFE_INTEGER;
      return az - bz;
    });
  if (!snapshots.length) return;
  for (const snapshot of snapshots) {
    const saved = snapshot.item;
    const id = String(saved?.id || "").trim();
    if (!id || state.imagesById.has(id)) continue;
    addImage(
      {
        id,
        path: String(saved.path),
        receiptPath: saved.receiptPath ? String(saved.receiptPath) : null,
        kind: saved.kind ? String(saved.kind) : null,
        source: saved.source ? String(saved.source) : null,
        label: saved.label ? String(saved.label) : basename(saved.path),
        timelineNodeId: saved.timelineNodeId ? String(saved.timelineNodeId) : null,
        visionDesc: saved.visionDesc ? String(saved.visionDesc) : null,
        visionDescMeta:
          saved.visionDescMeta && typeof saved.visionDescMeta === "object"
            ? { ...saved.visionDescMeta }
            : null,
        width: Number(saved.width) || null,
        height: Number(saved.height) || null,
      },
      { select: false }
    );
    if (snapshot.rect) {
      state.freeformRects.set(id, { ...snapshot.rect });
    }
    if (Number.isFinite(Number(snapshot.imageIndex)) && Number(snapshot.imageIndex) >= 0) {
      motherV2MoveImageToIndex(id, Number(snapshot.imageIndex));
    }
    if (Number.isFinite(Number(snapshot.zIndex)) && Number(snapshot.zIndex) >= 0) {
      motherV2MoveFreeformZToIndex(id, Number(snapshot.zIndex));
    }
  }
  const selected = getSelectedIds();
  let selectedChanged = false;
  const withSelection = snapshots
    .filter((entry) => Number.isFinite(Number(entry?.selectedIndex)) && Number(entry.selectedIndex) >= 0)
    .sort((a, b) => Number(a.selectedIndex) - Number(b.selectedIndex));
  for (const entry of withSelection) {
    const id = String(entry?.item?.id || "").trim();
    if (!id || !state.imagesById.has(id) || selected.includes(id)) continue;
    const index = Math.max(0, Math.min(selected.length, Math.floor(Number(entry.selectedIndex) || 0)));
    selected.splice(index, 0, id);
    selectedChanged = true;
  }
  if (selectedChanged) setSelectedIds(selected.filter((id) => state.imagesById.has(id)));
  const active = snapshots.find((entry) => entry?.wasActive && state.imagesById.has(String(entry?.item?.id || "")));
  if (active?.item?.id) {
    await setActiveImage(String(active.item.id), { preserveSelection: true }).catch(() => {});
  }
}

async function motherV2CommitSelectedDraft() {
  const idle = state.motherIdle;
  if (!idle) return false;
  const draft = motherV2CurrentDraft();
  if (!draft?.path) return false;
  const reelLocked = isReelSizeLocked();
  const intent = motherV2SanitizeIntentImageIds(idle.intent && typeof idle.intent === "object" ? idle.intent : {}) || {};
  const targetIds = Array.isArray(intent.target_ids) ? intent.target_ids.map((v) => String(v || "").trim()).filter(Boolean) : [];
  const targetId = targetIds[0] || getVisibleActiveId();
  const policy = String(intent.placement_policy || "adjacent").trim() || "adjacent";
  const seedIds = motherV2CollectCommitSeedIds(intent);
  const beforeTarget = targetId && state.imagesById.has(targetId)
    ? (() => {
        const t = state.imagesById.get(targetId);
        return t
          ? {
              path: String(t.path || ""),
              receiptPath: t.receiptPath ? String(t.receiptPath) : null,
              kind: t.kind ? String(t.kind) : null,
              source: t.source ? String(t.source) : null,
              motherVersionId: t.motherVersionId ? String(t.motherVersionId) : null,
              receiptMeta: t.receiptMeta && typeof t.receiptMeta === "object" ? { ...t.receiptMeta } : null,
              receiptMetaChecked: Boolean(t.receiptMetaChecked),
            }
          : null;
      })()
    : null;

  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.DEPLOY);
  idle.commitMutationInFlight = true;
  try {
    let commitUndo = null;
    let committedImageId = null;
    if (policy === "replace" && targetId && state.imagesById.has(targetId)) {
      const ok = await replaceImageInPlace(targetId, {
        path: draft.path,
        receiptPath: draft.receiptPath || null,
        kind: "engine",
        label: basename(draft.path),
      }).catch(() => false);
      if (!ok) throw new Error("Mother commit failed to replace target.");
      const targetItem = state.imagesById.get(targetId) || null;
      if (targetItem) {
        targetItem.source = MOTHER_GENERATED_SOURCE;
        targetItem.motherVersionId = draft.versionId ? String(draft.versionId) : null;
        if (draft.receiptMeta && typeof draft.receiptMeta === "object") {
          targetItem.receiptMeta = { ...draft.receiptMeta };
          targetItem.receiptMetaChecked = true;
          targetItem.receiptMetaLoading = false;
        }
      }
      committedImageId = String(targetId);
      commitUndo = {
        mode: "replace",
        targetId: String(targetId),
        before: beforeTarget,
      };
    } else {
      const offerRect = motherV2OfferPreviewRectCss({ policy, targetId, draftIndex: 0 });
      let rect = offerRect || motherIdleComputePlacementCss({ policy, targetId, draftIndex: 0 });
      if (rect) {
        const wrap = els.canvasWrap;
        const canvasCssW = Math.max(1, Number(wrap?.clientWidth) || 1);
        const canvasCssH = Math.max(1, Number(wrap?.clientHeight) || 1);
        if (!offerRect) {
          const visibleRatio = rectVisibleRatioInViewport(rect);
          // Keep accepted Mother artifacts visible to the user.
          if (reelLocked || visibleRatio < 0.35) {
            rect = recenterRectToViewport(rect);
          }
        }
        rect = clampFreeformRectCss(rect, canvasCssW, canvasCssH);
      }
      if (rect) state.freeformRects.set(draft.id, { ...rect });
      addImage(
        {
          id: draft.id,
          kind: "engine",
          source: MOTHER_GENERATED_SOURCE,
          path: draft.path,
          receiptPath: draft.receiptPath || null,
          label: basename(draft.path),
          timelineAction: "Mother Suggestion",
          timelineParents: [],
          motherVersionId: draft.versionId ? String(draft.versionId) : null,
          receiptMeta: draft.receiptMeta && typeof draft.receiptMeta === "object" ? { ...draft.receiptMeta } : null,
          receiptMetaChecked: Boolean(draft.receiptMeta),
          receiptMetaLoading: false,
        },
        { select: false }
      );
      committedImageId = String(draft.id);
      commitUndo = {
        mode: "insert",
        insertedId: String(draft.id),
      };
    }
    const removedSeeds = await motherV2DiscardCommitSeedImages({
      seedIds,
      keepIds: committedImageId ? [committedImageId] : [],
    });
    idle.commitUndo = {
      ...(commitUndo || {}),
      removedSeeds,
      expiresAt: Date.now() + 4500,
    };
  } finally {
    idle.commitMutationInFlight = false;
  }

  idle.telemetry.deployed = (Number(idle.telemetry?.deployed) || 0) + 1;
  appendMotherTraceLog({
    kind: "deployed",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    deployed: Number(idle.telemetry?.deployed) || 0,
    intent_id: intent.intent_id || null,
    placement_policy: policy,
    optimization_target: motherCurrentOptimizationTarget(),
    proposal_mode: motherV2NormalizeTransformationMode(intent?.transformation_mode),
    proposal_candidates: motherV2ProposalCandidateSummary(intent, { limit: MOTHER_V2_MAX_RANKED_PROPOSALS }),
    proposal_confidence: Number(intent?.confidence) || 0,
  }).catch(() => {});
  // Prevent immediate auto-reproposal loops right after deploy.
  idle.blockedUntilUserInteraction = true;
  state.lastInteractionAt = Date.now();
  state.lastMotherHotAt = state.lastInteractionAt;
  appendMotherTraceLog({
    kind: "post_commit_wait_for_user_interaction",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
  }).catch(() => {});
  motherV2ClearIntentAndDrafts({ removeFiles: false });
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.COMMIT_DONE);
  motherV2ArmCooldown({ rejected: false });
  setStatus("Mother: committed.");
  if (!reelLocked) {
    showToast("Mother commit applied. Undo available briefly.", "tip", 2200);
  }
  renderMotherReadout();
  requestRender();
  return true;
}

async function motherV2UndoCommit() {
  const idle = state.motherIdle;
  if (!idle?.commitUndo) return false;
  const undo = idle.commitUndo;
  if (Date.now() > (Number(undo.expiresAt) || 0)) {
    idle.commitUndo = null;
    renderMotherReadout();
    return false;
  }
  if (undo.mode === "insert" && undo.insertedId) {
    await removeImageFromCanvas(String(undo.insertedId)).catch(() => {});
  } else if (undo.mode === "replace" && undo.targetId && undo.before?.path) {
    const ok = await replaceImageInPlace(String(undo.targetId), {
      path: String(undo.before.path),
      receiptPath: undo.before.receiptPath ? String(undo.before.receiptPath) : null,
      kind: undo.before.kind || null,
      clearVision: false,
    }).catch(() => false);
    if (ok) {
      const targetItem = state.imagesById.get(String(undo.targetId)) || null;
      if (targetItem) {
        targetItem.source = undo.before.source || null;
        targetItem.motherVersionId = undo.before.motherVersionId ? String(undo.before.motherVersionId) : null;
        targetItem.receiptMeta =
          undo.before.receiptMeta && typeof undo.before.receiptMeta === "object"
            ? { ...undo.before.receiptMeta }
            : null;
        targetItem.receiptMetaChecked = Boolean(undo.before.receiptMetaChecked);
        targetItem.receiptMetaLoading = false;
      }
    }
  }
  if (Array.isArray(undo.removedSeeds) && undo.removedSeeds.length) {
    await motherV2RestoreDiscardedSeeds(undo.removedSeeds);
  }
  idle.commitUndo = null;
  showToast("Undid Mother commit.", "tip", 1800);
  renderMotherReadout();
  requestRender();
  return true;
}

function motherV2RejectOrDismiss({ queueFollowup = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const phase = idle.phase || motherIdleInitialState();
  const currentIntent = idle.intent && typeof idle.intent === "object" ? idle.intent : null;
  const shouldQueueFollowup = Boolean(
    queueFollowup &&
      !motherV2CommitUndoAvailable() &&
      motherIdleHasArmedCanvas() &&
      (phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING ||
        phase === MOTHER_IDLE_STATES.OFFERING ||
        phase === MOTHER_IDLE_STATES.DRAFTING)
  );
  const contextSig = currentIntent ? motherV2IntentContextSignature(currentIntent) : "";
  const imageSetSig = currentIntent ? motherV2IntentImageSetSignature(currentIntent) : "";
  const rejectedMode = currentIntent ? motherV2NormalizeTransformationMode(currentIntent.transformation_mode) : null;
  if (currentIntent) {
    idle.lastRejectedProposal = {
      contextSig,
      imageSetSig,
      mode: rejectedMode,
      summary: String(currentIntent.summary || "").trim(),
      at_ms: Date.now(),
    };
    if (shouldQueueFollowup && rejectedMode) {
      if (contextSig) motherV2RememberRejectedMode(contextSig, rejectedMode);
      if (imageSetSig && imageSetSig !== contextSig) motherV2RememberRejectedMode(imageSetSig, rejectedMode);
    }
  } else {
    idle.lastRejectedProposal = null;
  }
  idle.pendingFollowupAfterCooldown = shouldQueueFollowup;
  if (!shouldQueueFollowup) idle.pendingFollowupReason = null;
  idle.telemetry.rejected = (Number(idle.telemetry?.rejected) || 0) + 1;
  appendMotherTraceLog({
    kind: "rejected",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    rejected: Number(idle.telemetry?.rejected) || 0,
    phase,
    queue_followup: shouldQueueFollowup,
    optimization_target: motherCurrentOptimizationTarget(),
    proposal_mode: motherV2NormalizeTransformationMode(currentIntent?.transformation_mode),
    proposal_candidates: motherV2ProposalCandidateSummary(currentIntent, { limit: MOTHER_V2_MAX_RANKED_PROPOSALS }),
    proposal_confidence: Number(currentIntent?.confidence) || 0,
  }).catch(() => {});

  if (phase === MOTHER_IDLE_STATES.DRAFTING) {
    motherV2CancelInFlight({ reason: "manual_reject_drafting" });
    motherV2ClearIntentAndDrafts({ removeFiles: true });
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.REJECT);
    if (state.motherIdle?.phase === MOTHER_IDLE_STATES.COOLDOWN) {
      motherV2ArmCooldown({ rejected: true });
    }
    renderMotherReadout();
    return;
  }

  motherV2ClearIntentAndDrafts({ removeFiles: true });
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.REJECT);
  if (state.motherIdle?.phase === MOTHER_IDLE_STATES.COOLDOWN) {
    motherV2ArmCooldown({ rejected: true });
  }
  renderMotherReadout();
}

async function startMotherTakeover() {
  const idle = state.motherIdle;
  if (!idle) return;
  closeMotherWheelMenu({ immediate: true });
  const phase = idle.phase || motherIdleInitialState();
  if (phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
    if (state.pointer.active) {
      showToast("Finish dragging before confirming.", "tip", 1600);
      return;
    }
    const hasPrefetchedDraft = motherV2CurrentProposalHasPrefetchedDraft();
    const awaitingMatchingSpeculative = motherV2InFlightSpeculativeMatchesCurrentProposal();
    const staleSpeculativeDispatchInFlight = Boolean(
      idle.pendingDispatchSpeculative &&
      motherV2DispatchInFlight(idle) &&
      !awaitingMatchingSpeculative
    );
    const awaitingSpeculativeCompile = Boolean(
      idle.pendingPromptCompile &&
      idle.pendingPromptCompileSpeculative &&
      (Number(idle.pendingActionVersion) || 0) === (Number(idle.actionVersion) || 0)
    );
    idle.telemetry.accepted = (Number(idle.telemetry?.accepted) || 0) + 1;
    appendMotherTraceLog({
      kind: "accepted",
      traceId: idle.telemetry?.traceId || null,
      actionVersion: Number(idle.actionVersion) || 0,
      accepted: Number(idle.telemetry?.accepted) || 0,
      intent_id: idle.intent?.intent_id || null,
      optimization_target: motherCurrentOptimizationTarget(),
      proposal_mode: motherV2NormalizeTransformationMode(idle.intent?.transformation_mode),
      proposal_candidates: motherV2ProposalCandidateSummary(idle.intent, { limit: MOTHER_V2_MAX_RANKED_PROPOSALS }),
      proposal_confidence: Number(idle.intent?.confidence) || 0,
    }).catch(() => {});
    if (hasPrefetchedDraft) {
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.CONFIRM);
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.DRAFT_READY);
      setStatus("Mother: proposal ready.");
      renderMotherReadout();
      requestRender();
      return;
    }
    if (staleSpeculativeDispatchInFlight) {
      motherV2CancelInFlight({ reason: "confirm_stale_speculative_dispatch" });
    }
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.CONFIRM);
    if (awaitingMatchingSpeculative || awaitingSpeculativeCompile) {
      idle.pendingDispatchSpeculative = false;
      idle.pendingPromptCompileSpeculative = false;
      setStatus("Mother: draftingâ€¦");
      renderMotherReadout();
      return;
    }
    motherIdleDispatchGeneration().catch(() => {});
    renderMotherReadout();
    return;
  }
  if (phase === MOTHER_IDLE_STATES.WAITING_FOR_USER) {
    const draftReady = Boolean(motherV2CurrentDraft());
    if (!draftReady) {
      showToast("Mother is still drafting.", "tip", 1400);
      return;
    }
    motherV2ForcePhase(MOTHER_IDLE_STATES.OFFERING, "confirm_waiting_for_user");
    await motherV2CommitSelectedDraft();
    return;
  }
  if (phase === MOTHER_IDLE_STATES.OFFERING) {
    await motherV2CommitSelectedDraft();
    return;
  }
  if (phase === MOTHER_IDLE_STATES.COOLDOWN) {
    showToast("Mother cooling down.", "tip", 1400);
    return;
  }
  showToast("Arrange images, then pause for intent.", "tip", 1800);
}

function stopMotherTakeover() {
  const idle = state.motherIdle;
  if (!idle) return;
  if (motherV2CommitUndoAvailable()) {
    motherV2UndoCommit().catch(() => {});
    return;
  }
  motherV2RejectOrDismiss({ queueFollowup: true });
}

function computeWorldProjection({
  canvasCssW,
  canvasCssH,
  surfaceW,
  surfaceH,
  overscanRatio = WORLD_PROJECTION_OVERSCAN_RATIO,
  padPx = 6,
} = {}) {
  const worldCanvasW = Math.max(1, Number(canvasCssW) || 1);
  const worldCanvasH = Math.max(1, Number(canvasCssH) || 1);
  const drawSurfaceW = Math.max(1, Number(surfaceW) || 1);
  const drawSurfaceH = Math.max(1, Number(surfaceH) || 1);
  const pad = Math.max(0, Number(padPx) || 0);
  const overscan = Math.max(0, Number(overscanRatio) || 0);
  const worldPadX = Math.max(0, worldCanvasW * overscan);
  const worldPadY = Math.max(0, worldCanvasH * overscan);
  const worldLeft = -worldPadX;
  const worldTop = -worldPadY;
  const worldW = Math.max(1, worldCanvasW + worldPadX * 2);
  const worldH = Math.max(1, worldCanvasH + worldPadY * 2);
  const availW = Math.max(1, drawSurfaceW - pad * 2);
  const availH = Math.max(1, drawSurfaceH - pad * 2);
  const scale = Math.max(0.0001, Math.min(availW / worldW, availH / worldH));
  const drawW = worldW * scale;
  const drawH = worldH * scale;
  const ox = Math.round((drawSurfaceW - drawW) / 2);
  const oy = Math.round((drawSurfaceH - drawH) / 2);
  return { worldLeft, worldTop, worldW, worldH, scale, ox, oy };
}

function projectWorldRectToSurface(rect, projection) {
  if (!rect || !projection) return null;
  const x = Number(rect.x) || 0;
  const y = Number(rect.y) || 0;
  const w = Math.max(1, Number(rect.w) || 1);
  const h = Math.max(1, Number(rect.h) || 1);
  return {
    x: Math.round(projection.ox + (x - projection.worldLeft) * projection.scale),
    y: Math.round(projection.oy + (y - projection.worldTop) * projection.scale),
    w: Math.max(1, Math.round(w * projection.scale)),
    h: Math.max(1, Math.round(h * projection.scale)),
  };
}

function setTip(message) {
  state.lastTipText = String(message || "");
  if (state.alwaysOnVision?.enabled) {
    // Mother panel is reserved for CTX output while always-on vision is enabled.
    return;
  }
  renderMotherReadout();
}

function setDirectorText(text, meta = null) {
  state.lastDirectorText = text ? String(text) : null;
  state.lastDirectorMeta = meta && typeof meta === "object" ? meta : null;
  renderHudReadout();
}

function setRunInfo(message) {
  if (!els.runInfo) return;
  els.runInfo.textContent = message;
}

function isMotherGeneratedImageItem(item) {
  return String(item?.source || "").trim() === MOTHER_GENERATED_SOURCE;
}

function motherIdleBaseImageItems() {
  // Mother v2 follow-ups should be able to reason over newly generated outputs too.
  return getVisibleCanvasImages();
}

function motherV2NormalizeTransformationMode(rawMode) {
  const mode = String(rawMode || "").trim().toLowerCase();
  if (MOTHER_V2_TRANSFORMATION_MODES.includes(mode)) return mode;
  return MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
}

function motherV2MaybeTransformationMode(rawMode) {
  const mode = String(rawMode || "").trim().toLowerCase();
  if (MOTHER_V2_TRANSFORMATION_MODES.includes(mode)) return mode;
  return null;
}

function motherV2NormalizeAweJoyScore(rawScore, rawConfidence = null) {
  if (typeof rawScore === "number" && Number.isFinite(rawScore)) {
    return clamp(Number(rawScore) || 0, 0, 100);
  }
  if (typeof rawConfidence === "number" && Number.isFinite(rawConfidence)) {
    return clamp((Number(rawConfidence) || 0) * 100, 0, 100);
  }
  return null;
}

function motherV2NormalizeModeCandidate(rawEntry = null, { fallbackMode = null, idx = 0 } = {}) {
  const entry = rawEntry && typeof rawEntry === "object" ? rawEntry : {};
  const mode = motherV2MaybeTransformationMode(
    entry.mode ||
      entry.transformation_mode ||
      (typeof rawEntry === "string" ? rawEntry : null) ||
      fallbackMode
  );
  if (!mode) return null;
  const confidence =
    typeof entry.confidence === "number" && Number.isFinite(entry.confidence)
      ? clamp(Number(entry.confidence) || 0, 0, 1)
      : null;
  const aweJoyScore = motherV2NormalizeAweJoyScore(entry.awe_joy_score, confidence);
  return {
    mode,
    awe_joy_score: aweJoyScore,
    confidence,
    _idx: Number.isFinite(Number(idx)) ? Number(idx) : Number.MAX_SAFE_INTEGER,
  };
}

function motherV2CompareModeCandidates(a, b) {
  const as = typeof a?.awe_joy_score === "number" ? a.awe_joy_score : -1;
  const bs = typeof b?.awe_joy_score === "number" ? b.awe_joy_score : -1;
  if (bs !== as) return bs - as;
  const ac = typeof a?.confidence === "number" ? a.confidence : -1;
  const bc = typeof b?.confidence === "number" ? b.confidence : -1;
  if (bc !== ac) return bc - ac;
  const ai = Number.isFinite(Number(a?._idx)) ? Number(a._idx) : Number.MAX_SAFE_INTEGER;
  const bi = Number.isFinite(Number(b?._idx)) ? Number(b._idx) : Number.MAX_SAFE_INTEGER;
  if (ai !== bi) return ai - bi;
  return String(a?.mode || "").localeCompare(String(b?.mode || ""));
}

function motherV2ProposalLimit(rawLimit = MOTHER_V2_MAX_RANKED_PROPOSALS) {
  const parsed = Number(rawLimit);
  if (!Number.isFinite(parsed)) return MOTHER_V2_MAX_RANKED_PROPOSALS;
  return clamp(Math.floor(parsed), 1, MOTHER_V2_MAX_RANKED_PROPOSALS);
}

function motherV2CurrentTransformationMode() {
  const idle = state.motherIdle;
  const mode = idle?.intent?.transformation_mode;
  return motherV2NormalizeTransformationMode(mode);
}

function motherV2NormalizeImageIdList(list = []) {
  const out = [];
  for (const raw of Array.isArray(list) ? list : []) {
    const id = String(raw || "").trim();
    if (!id) continue;
    if (!isVisibleCanvasImageId(id)) continue;
    if (!out.includes(id)) out.push(id);
  }
  return out;
}

function motherV2SanitizeIntentImageIds(intentPayload = null) {
  if (!intentPayload || typeof intentPayload !== "object") return null;
  const roles = intentPayload.roles && typeof intentPayload.roles === "object"
    ? {
        subject: motherV2NormalizeImageIdList(intentPayload.roles.subject),
        model: motherV2NormalizeImageIdList(intentPayload.roles.model),
        mediator: motherV2NormalizeImageIdList(intentPayload.roles.mediator),
        object: motherV2NormalizeImageIdList(intentPayload.roles.object),
      }
    : null;
  return {
    ...intentPayload,
    target_ids: motherV2NormalizeImageIdList(intentPayload.target_ids),
    reference_ids: motherV2NormalizeImageIdList(intentPayload.reference_ids),
    ...(roles ? { roles } : {}),
  };
}

function motherV2RoleContextIds({ limit = 6 } = {}) {
  const maxCount = Number.isFinite(Number(limit)) && Number(limit) > 0
    ? Math.floor(Number(limit))
    : Number.POSITIVE_INFINITY;
  const ids = [];
  const pushId = (rawId) => {
    const normalized = String(rawId || "").trim();
    if (!normalized) return;
    if (!isVisibleCanvasImageId(normalized)) return;
    if (ids.includes(normalized)) return;
    ids.push(normalized);
  };
  const pushMany = (list) => {
    for (const rawId of Array.isArray(list) ? list : []) {
      pushId(rawId);
      if (ids.length >= maxCount) return true;
    }
    return false;
  };

  // Keep role anchors first, then expand to full inferred intent context.
  for (const role of MOTHER_V2_ROLE_KEYS) {
    if (pushMany(motherV2RoleIds(role))) return ids;
  }
  const intent = state.motherIdle?.intent && typeof state.motherIdle.intent === "object"
    ? state.motherIdle.intent
    : null;
  if (intent) {
    if (pushMany(intent.target_ids)) return ids;
    if (pushMany(intent.reference_ids)) return ids;
  }
  if (pushMany(getVisibleSelectedIds())) return ids;
  pushId(getVisibleActiveId());
  return ids;
}

function motherV2IsAdvancedVisible() {
  const idle = state.motherIdle;
  if (!idle) return false;
  return Boolean(idle.advancedOpen || idle.optionReveal);
}

function motherV2HintsVisible() {
  const idle = state.motherIdle;
  if (!idle) return false;
  if (motherV2IsAdvancedVisible()) return true;
  return Date.now() < (Number(idle.hintVisibleUntil) || 0);
}

function motherV2HideHints({ immediate = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const close = () => {
    idle.hintVisibleUntil = 0;
    idle.hintLevel = 0;
    clearTimeout(idle.hintFadeTimer);
    idle.hintFadeTimer = null;
    requestRender();
  };
  if (immediate) {
    close();
    return;
  }
  clearTimeout(idle.hintFadeTimer);
  idle.hintFadeTimer = setTimeout(close, 420);
}

function motherV2RevealHints({ engaged = false, ms = 1400 } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const phase = idle.phase || motherIdleInitialState();
  if (!(phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING || phase === MOTHER_IDLE_STATES.OFFERING)) return;
  const level = engaged ? 2 : 1;
  idle.hintLevel = Math.max(Number(idle.hintLevel) || 0, level);
  const ttl = engaged ? Math.max(2000, Number(ms) || 0) : Math.max(900, Number(ms) || 0);
  idle.hintVisibleUntil = Date.now() + ttl;
  clearTimeout(idle.hintFadeTimer);
  idle.hintFadeTimer = setTimeout(() => {
    if (motherV2IsAdvancedVisible()) return;
    if (Date.now() < (Number(idle.hintVisibleUntil) || 0)) return;
    idle.hintLevel = 0;
    requestRender();
  }, ttl + 24);
  requestRender();
}

function motherV2ProposalSentence(intent) {
  const mode = motherV2NormalizeTransformationMode(intent?.transformation_mode);
  if (mode === "hybridize") {
    const uniqueIds = new Set();
    const pushMany = (list) => {
      for (const raw of Array.isArray(list) ? list : []) {
        const id = String(raw || "").trim();
        if (!id) continue;
        if (!isVisibleCanvasImageId(id)) continue;
        uniqueIds.add(id);
      }
    };
    pushMany(intent?.target_ids);
    pushMany(intent?.reference_ids);
    const roles = intent?.roles && typeof intent.roles === "object" ? intent.roles : null;
    if (roles) {
      pushMany(roles.subject);
      pushMany(roles.model);
      pushMany(roles.mediator);
      pushMany(roles.object);
    }
    if (uniqueIds.size >= 3) return "Fuse all references into one striking visual world.";
  }
  return MOTHER_V2_PROPOSAL_BY_MODE[mode] || MOTHER_V2_PROPOSAL_BY_MODE[MOTHER_V2_DEFAULT_TRANSFORMATION_MODE];
}

function motherV2ShotTypeHintForMode(rawMode = "") {
  const mode = motherV2NormalizeTransformationMode(rawMode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE);
  const preset = MOTHER_V2_SHOT_HINTS_BY_MODE[mode];
  if (preset && typeof preset === "object") return { mode, ...preset };
  return {
    mode,
    primary: "balanced medium shot",
    alternate: "wide establishing shot",
    rationale: "maintain clarity while keeping visual variety",
    lighting_profile: "balanced cinematic key/fill with coherent directionality",
    alternate_lighting_profile: "soft directional fill with shared ambient bounce",
    lens_guidance: "35-50mm balanced medium perspective",
    alternate_lens_guidance: "24-35mm wide establishing perspective",
  };
}

function motherV2ShotTypeHints({ preferredMode = "", candidateModes = [] } = {}) {
  const primaryMode = motherV2NormalizeTransformationMode(preferredMode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE);
  const modes = [];
  const pushMode = (rawMode) => {
    const mode = motherV2MaybeTransformationMode(rawMode);
    if (!mode) return;
    if (!modes.includes(mode)) modes.push(mode);
  };
  pushMode(primaryMode);
  for (const entry of Array.isArray(candidateModes) ? candidateModes : []) {
    if (entry && typeof entry === "object") {
      pushMode(entry.mode || entry.transformation_mode);
    } else {
      pushMode(entry);
    }
  }
  const primaryPreset = motherV2ShotTypeHintForMode(primaryMode);
  const alternateMode = modes.find((mode) => mode !== primaryMode) || null;
  let alternateShotType = "";
  if (alternateMode) {
    alternateShotType = String(motherV2ShotTypeHintForMode(alternateMode)?.primary || "").trim();
  }
  if (!alternateShotType) {
    alternateShotType = String(primaryPreset?.alternate || "").trim();
  }
  if (alternateShotType && alternateShotType.toLowerCase() === String(primaryPreset?.primary || "").toLowerCase()) {
    alternateShotType = "";
  }
  const primaryLightingProfile = String(primaryPreset?.lighting_profile || "balanced cinematic key/fill with coherent directionality").trim();
  let alternateLightingProfile = "";
  if (alternateMode) {
    alternateLightingProfile = String(motherV2ShotTypeHintForMode(alternateMode)?.lighting_profile || "").trim();
  }
  if (!alternateLightingProfile) {
    alternateLightingProfile = String(primaryPreset?.alternate_lighting_profile || "").trim();
  }
  if (
    alternateLightingProfile &&
    alternateLightingProfile.toLowerCase() === primaryLightingProfile.toLowerCase()
  ) {
    alternateLightingProfile = "";
  }
  const primaryLensGuidance = String(primaryPreset?.lens_guidance || "35-50mm balanced medium perspective").trim();
  let alternateLensGuidance = "";
  if (alternateMode) {
    alternateLensGuidance = String(motherV2ShotTypeHintForMode(alternateMode)?.lens_guidance || "").trim();
  }
  if (!alternateLensGuidance) {
    alternateLensGuidance = String(primaryPreset?.alternate_lens_guidance || "").trim();
  }
  if (
    alternateLensGuidance &&
    alternateLensGuidance.toLowerCase() === primaryLensGuidance.toLowerCase()
  ) {
    alternateLensGuidance = "";
  }
  const primaryShotType = String(primaryPreset?.primary || "balanced medium shot").trim();
  const shotInstruction = alternateShotType
    ? `Prefer ${primaryShotType}. If composition clarity or emphasis weakens, try ${alternateShotType}.`
    : `Prefer ${primaryShotType}.`;
  const lightingInstruction = alternateLightingProfile
    ? `Light with ${primaryLightingProfile}. If mood or subject separation is weak, try ${alternateLightingProfile}.`
    : `Light with ${primaryLightingProfile}.`;
  const lensInstruction = alternateLensGuidance
    ? `Lens guidance: ${primaryLensGuidance} (fallback ${alternateLensGuidance}).`
    : `Lens guidance: ${primaryLensGuidance}.`;
  const instruction = `${shotInstruction} ${lightingInstruction} ${lensInstruction}`;
  return {
    primary_mode: primaryMode,
    primary_shot_type: primaryShotType,
    alternate_mode: alternateMode,
    alternate_shot_type: alternateShotType || null,
    primary_lighting_profile: primaryLightingProfile,
    alternate_lighting_profile: alternateLightingProfile || null,
    primary_lens_guidance: primaryLensGuidance,
    alternate_lens_guidance: alternateLensGuidance || null,
    rationale: String(primaryPreset?.rationale || "").trim() || null,
    shot_instruction: shotInstruction,
    lighting_instruction: lightingInstruction,
    lens_instruction: lensInstruction,
    instruction,
  };
}

function motherV2EnsureProposalCandidates(intentPayload = null) {
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : null;
  if (!intent) return intent;
  const modes = [];
  const confidenceByMode = new Map();
  const aweJoyScoreByMode = new Map();
  const firstIdxByMode = new Map();
  let modeIndex = 0;
  const pushMode = (rawMode, rawConfidence = null, rawAweJoyScore = null, { prepend = false } = {}) => {
    const normalized = motherV2NormalizeModeCandidate(
      {
        mode: rawMode,
        confidence: rawConfidence,
        awe_joy_score: rawAweJoyScore,
      },
      { idx: modeIndex }
    );
    modeIndex += 1;
    if (!normalized) return;
    const { mode, confidence, awe_joy_score: aweJoyScore, _idx: firstIdx } = normalized;
    if (!firstIdxByMode.has(mode)) firstIdxByMode.set(mode, firstIdx);
    const existingIdx = modes.indexOf(mode);
    if (existingIdx < 0) {
      if (prepend) modes.unshift(mode);
      else modes.push(mode);
      confidenceByMode.set(mode, confidence);
      aweJoyScoreByMode.set(mode, aweJoyScore);
      return;
    }
    if (prepend && existingIdx > 0) {
      modes.splice(existingIdx, 1);
      modes.unshift(mode);
    }
    if (typeof confidence === "number") {
      const prior = confidenceByMode.get(mode);
      if (!(typeof prior === "number") || confidence > prior) {
        confidenceByMode.set(mode, confidence);
      }
    }
    if (typeof aweJoyScore === "number") {
      const prior = aweJoyScoreByMode.get(mode);
      if (!(typeof prior === "number") || aweJoyScore > prior) {
        aweJoyScoreByMode.set(mode, aweJoyScore);
      }
    }
  };
  for (const entry of Array.isArray(intent.transformation_mode_candidates) ? intent.transformation_mode_candidates : []) {
    pushMode(entry?.mode || entry?.transformation_mode, entry?.confidence, entry?.awe_joy_score);
  }
  const current = motherV2MaybeTransformationMode(intent.transformation_mode);
  if (current) pushMode(current, null, null, { prepend: true });
  const baseMode = current || modes[0] || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
  const baseIdx = Math.max(0, MOTHER_V2_TRANSFORMATION_MODES.indexOf(baseMode));
  for (let offset = 0; offset < MOTHER_V2_TRANSFORMATION_MODES.length && modes.length < MOTHER_V2_MAX_RANKED_PROPOSALS; offset += 1) {
    const idx = (baseIdx + offset) % MOTHER_V2_TRANSFORMATION_MODES.length;
    const candidate = MOTHER_V2_TRANSFORMATION_MODES[idx];
    if (!candidate) continue;
    pushMode(candidate);
  }
  modes.sort((a, b) =>
    motherV2CompareModeCandidates(
      {
        mode: a,
        awe_joy_score: typeof aweJoyScoreByMode.get(a) === "number" ? aweJoyScoreByMode.get(a) : null,
        confidence: typeof confidenceByMode.get(a) === "number" ? confidenceByMode.get(a) : null,
        _idx: Number(firstIdxByMode.get(a) ?? Number.MAX_SAFE_INTEGER),
      },
      {
        mode: b,
        awe_joy_score: typeof aweJoyScoreByMode.get(b) === "number" ? aweJoyScoreByMode.get(b) : null,
        confidence: typeof confidenceByMode.get(b) === "number" ? confidenceByMode.get(b) : null,
        _idx: Number(firstIdxByMode.get(b) ?? Number.MAX_SAFE_INTEGER),
      }
    )
  );
  const rankedModes = modes.slice(0, motherV2ProposalLimit());
  intent.transformation_mode_candidates = rankedModes.map((mode) => ({
    mode,
    awe_joy_score: typeof aweJoyScoreByMode.get(mode) === "number" ? aweJoyScoreByMode.get(mode) : null,
    confidence: typeof confidenceByMode.get(mode) === "number" ? confidenceByMode.get(mode) : null,
  }));
  const normalizedCurrent = motherV2MaybeTransformationMode(intent.transformation_mode);
  if ((!normalizedCurrent || !rankedModes.includes(normalizedCurrent)) && rankedModes.length) {
    intent.transformation_mode = rankedModes[0];
  }
  return intent;
}

function motherV2ProposalModes(intentPayload = null) {
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : null;
  if (!intent) return [];
  const modes = [];
  const pushMode = (rawMode) => {
    const mode = motherV2MaybeTransformationMode(rawMode);
    if (!mode) return;
    if (!modes.includes(mode)) modes.push(mode);
  };
  const rawCandidates = Array.isArray(intent.transformation_mode_candidates) ? intent.transformation_mode_candidates : [];
  for (const entry of rawCandidates) {
    pushMode(entry?.mode || entry?.transformation_mode);
  }
  const current = motherV2MaybeTransformationMode(intent.transformation_mode);
  if (!modes.length) modes.push(current || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE);
  return modes.slice(0, motherV2ProposalLimit());
}

function motherV2ProposalCandidateSummary(intentPayload = null, { limit = MOTHER_V2_MAX_RANKED_PROPOSALS } = {}) {
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : null;
  if (!intent) return [];
  const candidates = [];
  const pushCandidate = (rawMode, rawConfidence = null, rawAweJoyScore = null, { prepend = false } = {}) => {
    const normalized = motherV2NormalizeModeCandidate({
      mode: rawMode,
      confidence: rawConfidence,
      awe_joy_score: rawAweJoyScore,
    }, { idx: candidates.length });
    if (!normalized) return;
    const { mode, confidence, awe_joy_score: aweJoyScore } = normalized;
    const existing = candidates.find((entry) => entry.mode === mode) || null;
    if (!existing) {
      if (prepend) candidates.unshift({ mode, awe_joy_score: aweJoyScore, confidence });
      else candidates.push({ mode, awe_joy_score: aweJoyScore, confidence });
      return;
    }
    if (prepend) {
      const idx = candidates.findIndex((entry) => entry.mode === mode);
      if (idx > 0) {
        const [entry] = candidates.splice(idx, 1);
        candidates.unshift(entry);
      }
    }
    if (typeof confidence === "number") {
      if (!(typeof existing.confidence === "number") || confidence > existing.confidence) {
        existing.confidence = confidence;
      }
    }
    if (typeof aweJoyScore === "number") {
      if (!(typeof existing.awe_joy_score === "number") || aweJoyScore > existing.awe_joy_score) {
        existing.awe_joy_score = aweJoyScore;
      }
    }
  };
  for (const entry of Array.isArray(intent.transformation_mode_candidates) ? intent.transformation_mode_candidates : []) {
    pushCandidate(entry?.mode || entry?.transformation_mode, entry?.confidence, entry?.awe_joy_score);
  }
  pushCandidate(intent.transformation_mode, null, null);
  candidates.sort(motherV2CompareModeCandidates);
  const maxItems = motherV2ProposalLimit(limit);
  return candidates.slice(0, maxItems).map((entry) => ({
    mode: entry.mode,
    awe_joy_score: typeof entry.awe_joy_score === "number" ? entry.awe_joy_score : null,
    confidence: typeof entry.confidence === "number" ? entry.confidence : null,
  }));
}

function motherV2ProposalIconAccent(mode) {
  const normalizedMode = motherV2NormalizeTransformationMode(mode);
  return MOTHER_V2_PROPOSAL_ICON_ACCENT_BY_MODE[normalizedMode] || "rgba(230, 237, 243, 0.94)";
}

function motherV2ProposalModeLabel(mode) {
  const normalizedMode = motherV2NormalizeTransformationMode(mode);
  return normalizedMode.replace(/_/g, " ").replace(/\b([a-z])/g, (m) => m.toUpperCase());
}

function motherV2ProposalIconSvg(mode) {
  const normalizedMode = motherV2NormalizeTransformationMode(mode);
  let inner = "";
  if (normalizedMode === "amplify") {
    inner = '<circle cx="12" cy="12" r="3.2"/><path d="M12 2.6v3.2M12 18.2v3.2M2.6 12h3.2M18.2 12h3.2M5.3 5.3l2.2 2.2M16.5 16.5l2.2 2.2M18.7 5.3l-2.2 2.2M7.5 16.5l-2.2 2.2"/>';
  } else if (normalizedMode === "transcend") {
    inner = '<path d="M12 20.6V6.3"/><path d="M7.8 10.4L12 6.2l4.2 4.2"/><path d="M4 18.2c2.2-1.7 4.9-2.6 8-2.6s5.8.9 8 2.6"/>';
  } else if (normalizedMode === "destabilize") {
    inner = '<path d="M12 3.4l7.8 8.6L12 20.6 4.2 12z"/><path d="M8.1 8.2l2.4 2.1-2.6 2.3 2.6 2.2"/><path d="M14.8 7.7l-2.1 2 2.2 2.1-2.3 2.2"/>';
  } else if (normalizedMode === "purify") {
    inner = '<path d="M12 4.2c2.8 3 4.8 5.8 4.8 8.3a4.8 4.8 0 1 1-9.6 0c0-2.5 2-5.3 4.8-8.3z"/><path d="M12 9.2v5.8"/><path d="M9.3 12.1h5.4"/>';
  } else if (normalizedMode === "hybridize") {
    inner = '<circle cx="9" cy="12" r="4.4"/><circle cx="15" cy="12" r="4.4"/><path d="M12 7.6v8.8"/>';
  } else if (normalizedMode === "mythologize") {
    inner = '<circle cx="12" cy="12" r="8"/><path d="M12 6.1l1.7 3.4 3.8.6-2.8 2.7.7 3.8L12 14.8 8.6 16.6l.7-3.8-2.8-2.7 3.8-.6z"/>';
  } else if (normalizedMode === "monumentalize") {
    inner = '<path d="M4.5 19.5h15"/><path d="M6.4 18.8V7.6h3.1v11.2M10.6 18.8V5.8h2.8v13M14.5 18.8V7.6h3.1v11.2"/><path d="M5.6 5.8h12.8"/>';
  } else if (normalizedMode === "fracture") {
    inner = '<path d="M5 3.6h14v16.8H5z"/><path d="M13.8 4.7 10.6 10h2.4l-3 4.1 1.2 5.8"/>';
  } else if (normalizedMode === "romanticize") {
    inner = '<path d="M12 20.4c-5.2-3.6-8-6.4-8-9.7 0-2.2 1.8-4 4-4 1.7 0 3.1.8 4 2.1.9-1.3 2.3-2.1 4-2.1 2.2 0 4 1.8 4 4 0 3.3-2.8 6.1-8 9.7z"/>';
  } else if (normalizedMode === "alienate") {
    inner = '<path d="M2.8 12s3.3-5.2 9.2-5.2 9.2 5.2 9.2 5.2-3.3 5.2-9.2 5.2-9.2-5.2-9.2-5.2z"/><circle cx="12" cy="12" r="2.4"/><path d="M18.6 4.6l1.9-1.9M5.4 19.4l-1.9 1.9"/>';
  } else {
    inner = '<circle cx="12" cy="12" r="4.2"/>';
  }
  return `<svg viewBox="0 0 24 24" aria-hidden="true">${inner}</svg>`;
}

function motherV2ProposalIconsHtml(intentPayload = null, { phase = null } = {}) {
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : null;
  const normalizedPhase = String(phase || state.motherIdle?.phase || "").trim();
  if (motherIdleBaseImageItems().length < MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL) return "";
  const activePhases = new Set([
    MOTHER_IDLE_STATES.WATCHING,
    MOTHER_IDLE_STATES.OBSERVING,
    MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING,
    MOTHER_IDLE_STATES.DRAFTING,
    MOTHER_IDLE_STATES.OFFERING,
    MOTHER_IDLE_STATES.COMMITTING,
    MOTHER_IDLE_STATES.COOLDOWN,
  ]);
  if (!activePhases.has(normalizedPhase)) {
    if (!intent) return "";
  }
  const hasConfirmedIntentSource = Boolean(motherV2IntentSourceKind(intent?._intent_source_kind));
  if (!hasConfirmedIntentSource) return "";
  let activeMode = null;
  let description = "";
  if (intent) {
    if (!motherV2HasRealProposalPayload(intent)) {
      if (!activePhases.has(normalizedPhase)) return "";
    } else {
      const modes = motherV2ProposalModes(intent);
      if (!modes.length) return "";
      const activeNormalized = motherV2NormalizeTransformationMode(intent.transformation_mode || modes[0]);
      activeMode = modes.includes(activeNormalized) ? activeNormalized : modes[0];
      description = motherV2ProposalSentence({
        ...intent,
        transformation_mode: activeMode,
      });
    }
  }
  if (!activeMode) {
    const rememberedMode = motherV2MaybeTransformationMode(state.motherIdle?.lastProposalMode);
    if (rememberedMode) {
      activeMode = rememberedMode;
      if (!description) description = "Mother proposal";
    }
  }
  if (!activeMode) {
    activeMode = MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
    if (!description) description = "Proposal pending";
  }
  if (state.motherIdle && activeMode) {
    state.motherIdle.lastProposalMode = activeMode;
  }
  const label = motherV2ProposalModeLabel(activeMode);
  const tooltip = `${label}: ${description}`;
  const accent = motherV2ProposalIconAccent(activeMode);
  const icon = motherV2ProposalIconSvg(activeMode);
  const chip = `<span class="mother-proposal-icon is-active" data-mode="${escapeHtml(activeMode)}" title="${escapeHtml(tooltip)}" aria-label="${escapeHtml(tooltip)}" style="--proposal-accent:${escapeHtml(accent)}">${icon}</span>`;
  return `<div class="mother-proposal-icons" aria-label="Proposal option">${chip}</div>`;
}

function motherV2DraftStatusIconSvg(kind = "drafting") {
  const iconKind = String(kind || "drafting").trim();
  let inner = "";
  if (iconKind === "braiding") {
    inner = '<path d="M4.8 8c2.9 0 3.3 7.8 7.2 7.8s4.3-7.8 7.2-7.8"/><path d="M4.8 16c2.9 0 3.3-7.8 7.2-7.8s4.3 7.8 7.2 7.8"/><circle cx="4.8" cy="8" r="1.2"/><circle cx="4.8" cy="16" r="1.2"/><circle cx="19.2" cy="8" r="1.2"/><circle cx="19.2" cy="16" r="1.2"/>';
  } else if (iconKind === "ready") {
    inner = '<path d="M5 12.7 9.3 17l9.7-9.7"/><path d="M12 4.2v2.1"/><path d="M6.8 6.1 8.2 7.5"/><path d="M17.2 6.1 15.8 7.5"/>';
  } else if (iconKind === "cooldown") {
    inner = '<circle cx="12" cy="12" r="7.4"/><path d="M12 8.4v4.4l2.9 2"/><path d="M9.6 3.8h4.8"/><path d="M6.2 6.2 4.6 4.6"/><path d="M17.8 6.2 19.4 4.6"/>';
  } else {
    inner = '<path d="M4.6 5.2h10.2M4.6 9.5h8.4M4.6 13.8h6.8"/><path d="M14.2 14.4 19 9.6l2.4 2.4-4.8 4.8-3 1z"/><path d="M18 8.2l2.8 2.8"/>';
  }
  return `<svg viewBox="0 0 24 24" aria-hidden="true">${inner}</svg>`;
}

function motherV2DraftStatusHtml({ phase = null } = {}) {
  const statePhase = phase || state.motherIdle?.phase || motherIdleInitialState();
  if (
    statePhase !== MOTHER_IDLE_STATES.DRAFTING &&
    statePhase !== MOTHER_IDLE_STATES.OFFERING &&
    statePhase !== MOTHER_IDLE_STATES.COOLDOWN
  ) {
    return "";
  }
  if (statePhase === MOTHER_IDLE_STATES.COOLDOWN) {
    const accent = "rgba(143, 222, 255, 0.95)";
    const tooltip = "Mother is cooling down before the next intent cycle.";
    const label = "COOLDOWN";
    const icon = motherV2DraftStatusIconSvg("cooldown");
    return `<div class="mother-phase-icons is-draft-card" aria-label="${escapeHtml(tooltip)}"><span class="mother-phase-icon is-cooldown is-draft-card" title="${escapeHtml(tooltip)}" aria-label="${escapeHtml(tooltip)}" style="--phase-accent:${escapeHtml(accent)}">${icon}</span><span class="mother-phase-label is-draft-card" style="--phase-accent:${escapeHtml(accent)}">${escapeHtml(label)}</span></div>`;
  }
  if (statePhase === MOTHER_IDLE_STATES.OFFERING) {
    const accent = "rgba(122, 238, 178, 0.96)";
    const tooltip = "Mother proposal is ready. Deploy, dismiss, or reroll.";
    const label = "PROPOSAL READY";
    const icon = motherV2DraftStatusIconSvg("ready");
    return `<div class="mother-phase-icons is-draft-card" aria-label="${escapeHtml(tooltip)}"><span class="mother-phase-icon is-ready is-draft-card" title="${escapeHtml(tooltip)}" aria-label="${escapeHtml(tooltip)}" style="--phase-accent:${escapeHtml(accent)}">${icon}</span><span class="mother-phase-label is-draft-card" style="--phase-accent:${escapeHtml(accent)}">${escapeHtml(label)}</span></div>`;
  }
  const iconKind = "drafting";
  const accent = "rgba(145, 238, 184, 0.95)";
  const tooltip = "Mother is drafting now. No canvas mutation until deploy.";
  const label = "DRAFTING";
  const icon = motherV2DraftStatusIconSvg(iconKind);
  return `<div class="mother-phase-icons is-draft-card" aria-label="${escapeHtml(tooltip)}"><span class="mother-phase-icon is-${escapeHtml(iconKind)} is-draft-card" title="${escapeHtml(tooltip)}" aria-label="${escapeHtml(tooltip)}" style="--phase-accent:${escapeHtml(accent)}">${icon}</span><span class="mother-phase-label is-draft-card" style="--phase-accent:${escapeHtml(accent)}">${escapeHtml(label)}</span></div>`;
}

function motherV2CycleProposal(step = 1) {
  const idle = state.motherIdle;
  if (!idle || !idle.intent || typeof idle.intent !== "object") return false;
  if ((idle.phase || motherIdleInitialState()) !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) return false;
  const modes = motherV2ProposalModes(idle.intent);
  if (modes.length < 2) return false;
  const activeMode = motherV2NormalizeTransformationMode(idle.intent.transformation_mode || modes[0]);
  const activeIdx = Math.max(0, modes.indexOf(activeMode));
  const dir = Number(step) < 0 ? -1 : 1;
  const nextIdx = (activeIdx + dir + modes.length) % modes.length;
  const nextMode = modes[nextIdx];
  if (!nextMode || nextMode === activeMode) return false;
  idle.intent.transformation_mode = nextMode;
  idle.intent.summary = motherV2ProposalSentence({
    ...idle.intent,
    transformation_mode: nextMode,
  });
  const currentDraft = motherV2CurrentDraft();
  const draftMode = motherV2CurrentDraftMode(currentDraft);
  if (currentDraft && draftMode && draftMode !== nextMode) {
    for (const draft of Array.isArray(idle.drafts) ? idle.drafts : []) {
      if (draft?.path) removeFile(String(draft.path)).catch(() => {});
      if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
    }
    idle.drafts = [];
    idle.selectedDraftId = null;
    idle.hoverDraftId = null;
    idle.speculativePrefetchReadyMode = null;
  }
  const pendingMode = motherV2NormalizeTransformationMode(idle.pendingDispatchProposalMode);
  if (idle.pendingPromptCompile && idle.pendingPromptCompileSpeculative) {
    idle.pendingPromptCompile = false;
    idle.pendingPromptCompileSpeculative = false;
    idle.pendingPromptCompilePath = null;
    clearTimeout(idle.pendingPromptCompileTimeout);
    idle.pendingPromptCompileTimeout = null;
  }
  if (idle.pendingDispatchSpeculative && idle.pendingDispatchToken && pendingMode && pendingMode !== nextMode) {
    motherV2CancelInFlight({ reason: "proposal_cycle_speculative_mismatch" });
  }
  motherV2RevealHints({ engaged: true, ms: 1900 });
  renderMotherReadout();
  requestRender();
  return true;
}

function motherV2IntentContextSignature(intentPayload = null) {
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : {};
  const ids = new Set();
  const pushMany = (list) => {
    for (const raw of Array.isArray(list) ? list : []) {
      const id = String(raw || "").trim();
      if (!id) continue;
      if (!isVisibleCanvasImageId(id)) continue;
      ids.add(id);
    }
  };
  pushMany(intent.target_ids);
  pushMany(intent.reference_ids);
  const roles = intent.roles && typeof intent.roles === "object" ? intent.roles : null;
  if (roles) {
    pushMany(roles.subject);
    pushMany(roles.model);
    pushMany(roles.mediator);
    pushMany(roles.object);
  }
  return Array.from(ids).sort().join("|");
}

function motherV2IntentImageSetSignature(intentPayload = null) {
  const intentSig = motherV2IntentContextSignature(intentPayload);
  if (intentSig) return intentSig;
  const ids = [];
  for (const item of motherIdleBaseImageItems()) {
    const id = String(item?.id || "").trim();
    if (!id) continue;
    if (!ids.includes(id)) ids.push(id);
  }
  return ids.sort().join("|");
}

function motherV2IntentRequiredImageIds() {
  const selected = getVisibleSelectedIds().map((v) => String(v || "").trim()).filter(Boolean);
  const images = motherIdleBaseImageItems().map((item) => {
    const rect = state.freeformRects.get(item.id) || null;
    return {
      id: String(item?.id || "").trim(),
      rect: rect
        ? {
            x: Number(rect.x) || 0,
            y: Number(rect.y) || 0,
            w: Number(rect.w) || 0,
            h: Number(rect.h) || 0,
          }
        : null,
    };
  });
  const rankedIds = motherV2RankImageIdsByProminence(images);
  const activeId = String(getVisibleActiveId() || "").trim();

  const targetIds = selected.length
    ? selected.slice(0, Math.max(1, Number(MOTHER_V2_INTENT_TARGET_IMAGE_LIMIT) || 2))
    : activeId
      ? [activeId]
      : rankedIds.slice(0, 1);
  const targetSet = new Set(targetIds);
  const referenceIds = rankedIds
    .filter((id) => !targetSet.has(id))
    .slice(0, Math.max(0, Number(MOTHER_V2_INTENT_REFERENCE_IMAGE_LIMIT) || 1));
  const out = [];
  for (const id of [...targetIds, ...referenceIds]) {
    if (!id) continue;
    if (!state.imagesById.has(id)) continue;
    if (!out.includes(id)) out.push(id);
  }
  return out;
}

function motherV2VisionReadyForIntent({ schedule = true } = {}) {
  const requiredIds = motherV2IntentRequiredImageIds();
  const missingIds = [];
  for (const imageId of requiredIds) {
    const item = state.imagesById.get(imageId) || null;
    if (!item?.path) continue;
    const desc = typeof item.visionDesc === "string" ? item.visionDesc.trim() : "";
    if (desc) continue;
    missingIds.push(String(imageId));
    if (schedule) scheduleVisionDescribe(item.path, { priority: true, fallback: true });
  }
  return {
    requiredIds,
    missingIds,
    ready: missingIds.length === 0,
  };
}

function motherV2RejectedModesForContext(contextSig = "") {
  const idle = state.motherIdle;
  if (!idle) return [];
  const key = String(contextSig || "").trim();
  if (!key) return [];
  const byContext =
    idle.rejectedModeHistoryByContext && typeof idle.rejectedModeHistoryByContext === "object"
      ? idle.rejectedModeHistoryByContext
      : {};
  const raw = Array.isArray(byContext[key]) ? byContext[key] : [];
  return raw.map((mode) => motherV2NormalizeTransformationMode(mode)).filter(Boolean);
}

function motherV2RememberRejectedMode(contextSig = "", mode = "") {
  const idle = state.motherIdle;
  if (!idle) return;
  const key = String(contextSig || "").trim();
  if (!key) return;
  const normalizedMode = motherV2NormalizeTransformationMode(mode);
  const byContext =
    idle.rejectedModeHistoryByContext && typeof idle.rejectedModeHistoryByContext === "object"
      ? idle.rejectedModeHistoryByContext
      : {};
  const prior = motherV2RejectedModesForContext(key).filter((m) => m !== normalizedMode);
  const next = prior.concat([normalizedMode]).slice(-MOTHER_V2_TRANSFORMATION_MODES.length);
  byContext[key] = next;
  const keys = Object.keys(byContext);
  while (keys.length > 64) {
    const drop = keys.shift();
    if (!drop) break;
    delete byContext[drop];
  }
  idle.rejectedModeHistoryByContext = byContext;
}

function motherV2DiversifyIntentForRejectFollowup(intentPayload = null) {
  const idle = state.motherIdle;
  const intent = intentPayload && typeof intentPayload === "object" ? intentPayload : null;
  if (!idle || !intent) return intent;
  if (String(idle.pendingFollowupReason || "") !== "reject_followup") {
    idle.pendingFollowupReason = null;
    return intent;
  }
  idle.pendingFollowupReason = null;

  const rejected = idle.lastRejectedProposal && typeof idle.lastRejectedProposal === "object" ? idle.lastRejectedProposal : null;
  const contextSig = motherV2IntentContextSignature(intent);
  const imageSetSig = motherV2IntentImageSetSignature(intent);
  const sigs = Array.from(new Set([contextSig, imageSetSig].map((v) => String(v || "").trim()).filter(Boolean)));
  if (!sigs.length) return intent;
  const rejectedModes = [];
  for (const sig of sigs) {
    for (const mode of motherV2RejectedModesForContext(sig)) {
      if (!rejectedModes.includes(mode)) rejectedModes.push(mode);
    }
  }
  if (!rejectedModes.length) return intent;

  const proposedMode = motherV2NormalizeTransformationMode(intent.transformation_mode);
  const proposedSummary = String(intent.summary || "").trim();
  const rejectedMode = motherV2NormalizeTransformationMode(rejected?.mode);
  const rejectedSummary = String(rejected?.summary || "").trim();
  const sameContextAsLastRejected = sigs.includes(String(rejected?.contextSig || "")) || sigs.includes(String(rejected?.imageSetSig || ""));
  const matchesRejected =
    sameContextAsLastRejected && (proposedMode === rejectedMode || (proposedSummary && proposedSummary === rejectedSummary));
  const alreadyRejectedForContext = rejectedModes.includes(proposedMode);
  if (!alreadyRejectedForContext && !matchesRejected) return intent;

  const baseIndex = Math.max(0, MOTHER_V2_TRANSFORMATION_MODES.indexOf(proposedMode));
  let replacementMode = null;
  for (let offset = 1; offset <= MOTHER_V2_TRANSFORMATION_MODES.length; offset += 1) {
    const idx = (baseIndex + offset) % MOTHER_V2_TRANSFORMATION_MODES.length;
    const candidate = MOTHER_V2_TRANSFORMATION_MODES[idx];
    if (!candidate || candidate === proposedMode) continue;
    if (!rejectedModes.includes(candidate)) {
      replacementMode = candidate;
      break;
    }
  }
  if (!replacementMode) {
    for (let offset = 1; offset <= MOTHER_V2_TRANSFORMATION_MODES.length; offset += 1) {
      const idx = (baseIndex + offset) % MOTHER_V2_TRANSFORMATION_MODES.length;
      const candidate = MOTHER_V2_TRANSFORMATION_MODES[idx];
      if (!candidate || candidate === proposedMode) continue;
      replacementMode = candidate;
      break;
    }
  }
  if (!replacementMode) return intent;

  return {
    ...intent,
    transformation_mode: replacementMode,
    summary: motherV2ProposalSentence({ transformation_mode: replacementMode }),
  };
}

function motherV2SetAdvancedOpen(nextOpen) {
  const idle = state.motherIdle;
  if (!idle) return;
  const next = Boolean(nextOpen);
  if (idle.advancedOpen === next) return;
  idle.advancedOpen = next;
  if (next) {
    motherV2RevealHints({ engaged: true, ms: 2400 });
  } else if (!idle.optionReveal) {
    motherV2HideHints({ immediate: true });
  }
  renderMotherReadout();
  requestRender();
}

function motherV2InvalidateOfferingForStructureEdit(reason = "structure_edit") {
  const idle = state.motherIdle;
  if (!idle) return;
  if (idle.phase !== MOTHER_IDLE_STATES.OFFERING) return;
  for (const draft of Array.isArray(idle.drafts) ? idle.drafts : []) {
    if (draft?.path) removeFile(String(draft.path)).catch(() => {});
    if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
  }
  idle.drafts = [];
  idle.selectedDraftId = null;
  idle.hoverDraftId = null;
  motherV2ForcePhase(MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING, reason);
}

function motherSuggestionLogPath() {
  if (!state.runDir) return null;
  return `${state.runDir}/${MOTHER_SUGGESTION_LOG_FILENAME}`;
}

async function appendMotherSuggestionLog(entry = {}) {
  const logPath = motherSuggestionLogPath();
  if (!logPath) return false;
  const line = `${JSON.stringify({ at: new Date().toISOString(), ...entry })}\n`;
  try {
    await appendTextWithFallback(logPath, line);
    return true;
  } catch {
    return false;
  }
}

function motherTraceLogPath() {
  if (!state.runDir) return null;
  return `${state.runDir}/${MOTHER_TRACE_FILENAME}`;
}

async function appendMotherTraceLog(entry = {}) {
  const logPath = motherTraceLogPath();
  if (!logPath) return false;
  const line = `${JSON.stringify({ at: new Date().toISOString(), ...entry })}\n`;
  try {
    await appendTextWithFallback(logPath, line);
    return true;
  } catch {
    return false;
  }
}

let automationEventSeq = 0;

function _automationStateEnvelope() {
  const mode = state.canvasMode || "multi";
  const modeView = mode === "multi" ? state.multiView : state.view;
  const selectedIds = getSelectedIds().slice(0, 3);
  const motherPhase = String(state.motherIdle?.phase || "").toLowerCase().trim() || null;
  const motherStatus = String(state.mother?.status || "").trim() || null;
  return {
    mother_phase: motherPhase,
    mother_status: motherStatus,
    canvas_mode: mode,
    canvas_scale: Number(modeView?.scale) || 1,
    canvas_offset_x: Number(modeView?.offsetX) || 0,
    canvas_offset_y: Number(modeView?.offsetY) || 0,
    mother: {
      running: Boolean(state.mother?.running),
      status: motherStatus,
      phase: motherPhase || null,
    },
    canvas: {
      mode,
      active_id: state.activeId || null,
      selected_ids: selectedIds,
      scale: Number(modeView?.scale) || 1,
      offset_x: Number(modeView?.offsetX) || 0,
      offset_y: Number(modeView?.offsetY) || 0,
      tool: state.tool || null,
    },
  };
}

function _makeAutomationEvent(type, entry = {}, { requestId = null } = {}) {
  return {
    type,
    schema: "brood.desktop_automation_event",
    schema_version: 1,
    seq: ++automationEventSeq,
    at: new Date().toISOString(),
    request_id: requestId || null,
    source: "desktop_ui_automation",
    ...entry,
  };
}

async function _appendAutomationEvents(events, { requestId = null } = {}) {
  const outPath = state.eventsPath;
  if (!outPath) return false;
  const batch = Array.isArray(events) ? events : [events];
  const payloads = [];
  for (const event of batch) {
    if (!event || typeof event !== "object") continue;
    payloads.push(`${JSON.stringify(_makeAutomationEvent(event.type || "automation", event, { requestId }))}\n`);
  }
  if (!payloads.length) return false;
  const text = payloads.join("");
  try {
    await appendTextWithFallback(outPath, text);
    return true;
  } catch {
    return false;
  }
}

function _coerceAutomationCanvasNumber(value, fallback) {
  const parsed = typeof value === "number" ? value : Number(value);
  if (Number.isFinite(parsed)) return parsed;
  return fallback;
}

function _coerceAutomationPayloadNumber(value, fallback) {
  if (value == null) return fallback;
  const parsed = typeof value === "number" ? value : Number(value);
  if (Number.isFinite(parsed)) return parsed;
  return fallback;
}

function _resolveAutomationCanvasMode(value, actionName = "canvas_action") {
  const mode = String(value || "").trim().toLowerCase();
  if (!mode) return { ok: true, mode: "multi" };
  if (mode === "multi") return { ok: true, mode };
  if (mode === "single") {
    return {
      ok: false,
      detail: `${actionName} mode=single is no longer supported; use mode=multi`,
    };
  }
  return {
    ok: false,
    detail: `${actionName} unsupported mode=${mode}; use mode=multi`,
  };
}

function _clampCanvasScale(value, fallback) {
  if (!Number.isFinite(value) || value <= 0) return fallback;
  return Math.max(0.05, Math.min(40, value));
}

function _normalizeAutomationMotherPhaseList(rawList = []) {
  const out = [];
  for (const raw of Array.isArray(rawList) ? rawList : []) {
    const phase = String(raw || "").trim().toLowerCase();
    if (!phase) continue;
    if (!out.includes(phase)) out.push(phase);
  }
  return out;
}

function _waitForAutomationMotherPhases(targetPhases = [], timeoutMs = 12000) {
  const targets = _normalizeAutomationMotherPhaseList(targetPhases);
  if (!targets.length) {
    const phase = String(state.motherIdle?.phase || "").toLowerCase().trim() || "";
    return Promise.resolve({ ok: true, phase });
  }
  const timeout = Math.max(500, Math.min(45000, Math.round(Number(timeoutMs) || 0)));
  const startedAt = Date.now();
  return new Promise((resolve) => {
    const tick = () => {
      const phase = String(state.motherIdle?.phase || "").toLowerCase().trim() || "";
      if (phase && targets.includes(phase)) {
        resolve({ ok: true, phase, elapsed_ms: Date.now() - startedAt });
        return;
      }
      if (Date.now() - startedAt >= timeout) {
        resolve({ ok: false, phase, elapsed_ms: Date.now() - startedAt });
        return;
      }
      setTimeout(tick, 120);
    };
    tick();
  });
}

function _appendCanvasStateEvent() {
  return {
    type: "canvas_state",
    marker: "canvas_state",
    state: _automationStateEnvelope(),
  };
}

function _applyCanvasPanFromPayload(payload = {}) {
  const modeResult = _resolveAutomationCanvasMode(payload.mode, "canvas_pan");
  if (!modeResult.ok) {
    return { ok: false, detail: modeResult.detail };
  }
  const mode = modeResult.mode;
  if (mode !== state.canvasMode) setCanvasMode(mode);
  const view = mode === "multi" ? state.multiView : state.view;
  if (!view) {
    return { ok: false, detail: "canvas view is not initialized" };
  }

  const dx = _coerceAutomationPayloadNumber(payload.dx, 0);
  const dy = _coerceAutomationPayloadNumber(payload.dy, 0);
  if (!Number.isFinite(dx) || !Number.isFinite(dy)) {
    return { ok: false, detail: "invalid pan payload" };
  }

  if (dx === 0 && dy === 0) {
    return { ok: false, detail: "canvas_pan requires non-zero dx or dy" };
  }

  view.offsetX = (Number(view.offsetX) || 0) + dx;
  view.offsetY = (Number(view.offsetY) || 0) + dy;
  renderHudReadout();
  requestRender();

  return {
    ok: true,
    detail: `pan dx=${Math.round(dx * 1000) / 1000}, dy=${Math.round(dy * 1000) / 1000} mode=${mode}`,
    event: {
      type: "canvas_view_updated",
      marker: "canvas_view_updated",
      mode,
      dx,
      dy,
      scale: Number(view.scale) || 1,
      offset_x: Number(view.offsetX) || 0,
      offset_y: Number(view.offsetY) || 0,
    },
  };
}

function _applyCanvasZoomFromPayload(payload = {}) {
  const modeResult = _resolveAutomationCanvasMode(payload.mode, "canvas_zoom");
  if (!modeResult.ok) {
    return { ok: false, detail: modeResult.detail };
  }
  const mode = modeResult.mode;
  if (mode !== state.canvasMode) setCanvasMode(mode);
  const view = mode === "multi" ? state.multiView : state.view;
  if (!view) {
    return { ok: false, detail: "canvas view is not initialized" };
  }

  const baseScale = _coerceAutomationPayloadNumber(payload.scale, Number.NaN);
  const factor = _coerceAutomationPayloadNumber(payload.factor, Number.NaN);
  const current = _coerceAutomationPayloadNumber(view.scale, 1);
  const requestedScale = Number.isFinite(baseScale)
    ? baseScale
    : Number.isFinite(factor)
      ? current * factor
      : Number.NaN;
  if (!Number.isFinite(requestedScale)) {
    return { ok: false, detail: "invalid scale/factor for canvas_zoom" };
  }

  const nextScale = _clampCanvasScale(requestedScale, current);
  if (nextScale === current) {
    return { ok: true, detail: `zoom unchanged at ${nextScale}` };
  }

  const canvas = els.workCanvas;
  const cx = Number(canvas?.width || 0) / 2;
  const cy = Number(canvas?.height || 0) / 2;
  const inv = Math.max(0.0001, Number(view.scale) || 1);
  const wx = (cx - (Number(view.offsetX) || 0)) / inv;
  const wy = (cy - (Number(view.offsetY) || 0)) / inv;

  view.scale = nextScale;
  view.offsetX = cx - wx * nextScale;
  view.offsetY = cy - wy * nextScale;

  renderHudReadout();
  requestRender();

  return {
    ok: true,
    detail: `zoom scale=${Math.round(nextScale * 1000) / 1000} mode=${mode}`,
    event: {
      type: "canvas_view_updated",
      marker: "canvas_view_updated",
      mode,
      scale: nextScale,
      offset_x: Number(view.offsetX) || 0,
      offset_y: Number(view.offsetY) || 0,
    },
  };
}

function _applyCanvasFitAllFromPayload(payload = {}) {
  const modeResult = _resolveAutomationCanvasMode(payload.mode, "canvas_fit_all");
  if (!modeResult.ok) {
    return { ok: false, detail: modeResult.detail };
  }
  const mode = modeResult.mode;
  if (mode !== state.canvasMode) setCanvasMode(mode);
  const view = mode === "multi" ? state.multiView : state.view;
  const canvas = els.workCanvas;
  if (!view || !canvas) {
    return { ok: false, detail: "canvas view is not initialized" };
  }

  if (!state.multiRects || state.multiRects.size === 0) {
    state.multiRects = computeFreeformRectsPx(canvas.width, canvas.height);
  }
  const orderedIds = Array.isArray(state.freeformZOrder) && state.freeformZOrder.length
    ? state.freeformZOrder
    : Array.from(state.multiRects.keys());
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  let count = 0;
  for (const rawId of orderedIds) {
    const imageId = String(rawId || "").trim();
    if (!imageId) continue;
    if (!isVisibleCanvasImageId(imageId)) continue;
    if (isImageEffectTokenized(imageId)) continue;
    const rect = state.multiRects.get(imageId) || null;
    if (!rect) continue;
    const x = Number(rect.x) || 0;
    const y = Number(rect.y) || 0;
    const w = Math.max(1, Number(rect.w) || 1);
    const h = Math.max(1, Number(rect.h) || 1);
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
    count += 1;
  }
  if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY) || count <= 0) {
    return { ok: false, detail: "no visible image bounds available for canvas_fit_all" };
  }

  const worldW = Math.max(1, maxX - minX);
  const worldH = Math.max(1, maxY - minY);
  const dpr = getDpr();
  const paddingRatio = clamp(_coerceAutomationPayloadNumber(payload.padding_ratio, 0.07), 0, 0.4);
  const padX = Math.max(Math.round(14 * dpr), Math.round(worldW * paddingRatio));
  const padY = Math.max(Math.round(14 * dpr), Math.round(worldH * paddingRatio));
  const maxWidthFrac = clamp(_coerceAutomationPayloadNumber(payload.max_width_frac, 0.94), 0.35, 1);
  const maxHeightFrac = clamp(_coerceAutomationPayloadNumber(payload.max_height_frac, 0.82), 0.35, 1);
  const availW = Math.max(1, Number(canvas.width || 0) * maxWidthFrac);
  const availH = Math.max(1, Number(canvas.height || 0) * maxHeightFrac);
  const targetW = Math.max(1, worldW + padX * 2);
  const targetH = Math.max(1, worldH + padY * 2);
  const fitScaleRaw = Math.min(availW / targetW, availH / targetH);
  const minScale = clamp(_coerceAutomationPayloadNumber(payload.min_scale, 0.05), 0.05, 40);
  const maxScale = clamp(_coerceAutomationPayloadNumber(payload.max_scale, 20), minScale, 40);
  const nextScale = clamp(fitScaleRaw, minScale, maxScale);
  const centerX = minX + worldW / 2;
  const centerY = minY + worldH / 2;

  view.scale = nextScale;
  view.offsetX = Number(canvas.width || 0) / 2 - centerX * nextScale;
  view.offsetY = Number(canvas.height || 0) / 2 - centerY * nextScale;
  renderHudReadout();
  requestRender();

  return {
    ok: true,
    detail: `fit ${count} images into view mode=${mode}`,
    event: {
      type: "canvas_view_fitted",
      marker: "canvas_view_fitted",
      mode,
      image_count: count,
      scale: Number(view.scale) || nextScale,
      offset_x: Number(view.offsetX) || 0,
      offset_y: Number(view.offsetY) || 0,
      bounds: {
        min_x: minX,
        min_y: minY,
        max_x: maxX,
        max_y: maxY,
      },
    },
  };
}

function _resolveCanvasImageIdFromPayload(payload = {}) {
  if (!payload || typeof payload !== "object") return null;
  const byId = String(payload.image_id || payload.imageId || "").trim();
  if (byId) {
    if (state.imagesById.has(byId)) return byId;
  }
  const imageIndex = _coerceAutomationCanvasNumber(payload.image_index, NaN);
  if (Number.isFinite(imageIndex)) {
    const index = Math.floor(imageIndex);
    const images = getVisibleCanvasImages();
    if (index >= 0 && index < images.length) {
      return String(images[index]?.id || "").trim() || null;
    }
  }
  const targetPath = String(payload.path || "").trim();
  if (!targetPath) return null;
  const matched = (state.images || []).find((item) => String(item?.path || "") === targetPath) || null;
  return matched ? String(matched.id || "") : null;
}

async function _runActionGridAutomation(action = {}) {
  const key = String(action.key || "").trim().toLowerCase();
  const hotkey = String(action.hotkey || "").trim();
  const shift = Boolean(action.shift);
  let targetKey = key;
  if (!targetKey && hotkey) {
    const btn = document.querySelector(`.action-grid .tool[data-hotkey="${CSS.escape(hotkey)}"]`);
    targetKey = String(btn?.dataset?.key || "").trim().toLowerCase();
  }
  if (!targetKey) {
    return { ok: false, detail: "missing action_grid key/hotkey" };
  }

  if (["annotate", "pan", "lasso"].includes(targetKey)) {
    setTool(targetKey);
    return { ok: true, detail: `tool=${targetKey}` };
  }
  if (targetKey === "bg") {
    const style = shift ? "sweep" : "white";
    applyBackground(style).catch(() => {});
    return { ok: true, detail: `apply_background=${style}` };
  }
  if (targetKey === "extract_dna") {
    runExtractDnaFromSelection().catch(() => {});
    return { ok: true, detail: "extract_dna started" };
  }
  if (targetKey === "soul_leech") {
    runSoulLeechFromSelection().catch(() => {});
    return { ok: true, detail: "soul_leech started" };
  }
  if (targetKey === "create_layers") {
    runCreateLayersFromSelection().catch(() => {});
    return { ok: true, detail: "create_layers started" };
  }
  if (targetKey === "prompt_generate") {
    const prompt = String(action.prompt || action.text || "").trim();
    const model = String(action.model || "").trim();
    if (!prompt) {
      return { ok: false, detail: "prompt_generate requires action.prompt" };
    }
    runPromptGenerate({ prompt, model }).catch(() => {});
    return { ok: true, detail: "prompt_generate started" };
  }
  if (targetKey === "remove_people") {
    aiRemovePeople().catch(() => {});
    return { ok: true, detail: "remove_people started" };
  }
  if (targetKey === "variations") {
    runVariations().catch(() => {});
    return { ok: true, detail: "variations started" };
  }
  if (targetKey === "recast") {
    runRecast().catch(() => {});
    return { ok: true, detail: "recast started" };
  }
  if (targetKey === "crop_square") {
    cropSquare().catch(() => {});
    return { ok: true, detail: "crop_square started" };
  }
  if (targetKey === "combine") {
    runBlendPair().catch(() => {});
    return { ok: true, detail: "combine started" };
  }
  if (targetKey === "bridge") {
    runBridgePair().catch(() => {});
    return { ok: true, detail: "bridge started" };
  }
  if (targetKey === "swap_dna") {
    runSwapDnaPair({ invert: shift }).catch(() => {});
    return { ok: true, detail: "swap_dna started" };
  }
  if (targetKey === "extract_rule") {
    runExtractRuleTriplet().catch(() => {});
    return { ok: true, detail: "extract_rule started" };
  }
  if (targetKey === "odd_one_out") {
    runOddOneOutTriplet().catch(() => {});
    return { ok: true, detail: "odd_one_out started" };
  }
  if (targetKey === "triforce") {
    runTriforceTriplet().catch(() => {});
    return { ok: true, detail: "triforce started" };
  }
  const fallback = document.querySelector(`.action-grid .tool[data-key="${CSS.escape(targetKey)}"]`);
  if (fallback && !fallback.disabled) {
    fallback.click();
    return { ok: true, detail: `action_grid button click key=${targetKey}` };
  }
  return { ok: false, detail: `unsupported action_grid key: ${targetKey}` };
}

async function handleDesktopAutomation(event = {}) {
  console.log("[desktop-automation] raw event", event);
  const eventPayload = (() => {
    let candidate = event;
    if (typeof candidate === "string") {
      try {
        candidate = JSON.parse(candidate);
      } catch {
        candidate = null;
      }
    }
    if (!candidate || typeof candidate !== "object") {
      return null;
    }
    if (!("request_id" in candidate) && !("action" in candidate) && candidate.payload !== undefined) {
      const nested = candidate.payload;
      if (typeof nested === "string") {
        try {
          return JSON.parse(nested);
        } catch {
          return null;
        }
      }
      if (nested && typeof nested === "object") {
        return nested;
      }
    }
    return candidate;
  })();
  if (!eventPayload) {
    console.warn("desktop automation event missing payload envelope");
    return;
  }
  const payload = eventPayload.payload && typeof eventPayload.payload === "object" ? eventPayload.payload : {};
  const requestId = String(
    eventPayload.request_id || eventPayload.payload?.request_id || eventPayload.id || ""
  ).trim();
  if (!requestId) return;
  const action = String(eventPayload.action || "").trim().toLowerCase();
  console.log(`[desktop-automation] processing request_id=${requestId} action=${action}`);
  const actionPayload = payload && typeof payload === "object" ? payload : {};
  const events = [];
  const markers = new Set();
  let ok = false;
  let detail = `unsupported automation action: ${action || "<empty>"}`;

  try {
    if (action === "mother_next_proposal") {
      const idle = state.motherIdle;
      if (!idle) {
        detail = "mother state unavailable";
      } else {
        const before = String(idle.phase || "").toLowerCase();
        let primed = false;
        if (
          (before === MOTHER_IDLE_STATES.OBSERVING || before === MOTHER_IDLE_STATES.WATCHING) &&
          motherIdleHasArmedCanvas()
        ) {
          primed = await motherV2StartFollowupProposal({ reason: "automation_next_proposal" });
        }
        const cycled = motherV2CycleProposal(1);
        const after = String(state.motherIdle?.phase || "").toLowerCase() || before;
        ok = Boolean(cycled || primed || before !== after);
        detail = ok
          ? `mother_next_proposal executed (${before || "unknown"} -> ${after || "unknown"})`
          : `mother_next_proposal made no visible change (${before || "unknown"} -> ${after || "unknown"})`;
        if (cycled) {
          events.push({ type: "mother_next_proposal", marker: "mother_next_proposal_completed", before, after });
        } else if (primed || before !== after) {
          events.push({
            type: "mother_next_proposal",
            marker: "mother_next_proposal_completed",
            before,
            after,
            note: "primed_intent_hypothesis",
          });
        } else {
          events.push({
            type: "mother_next_proposal",
            marker: "mother_next_proposal_completed",
            before,
            after,
            note: "already_at_boundary",
          });
        }
        events.push(_appendCanvasStateEvent());
        events.push({ type: "mother_state", marker: "mother_state", state: _automationStateEnvelope() });
      }
    } else if (action === "mother_confirm_suggestion") {
      const before = String(state.motherIdle?.phase || "").toLowerCase();
      if (!state.motherIdle) {
        detail = "mother state unavailable";
      } else {
        if (
          (before === MOTHER_IDLE_STATES.OBSERVING || before === MOTHER_IDLE_STATES.WATCHING) &&
          motherIdleHasArmedCanvas()
        ) {
          await motherV2StartFollowupProposal({ reason: "automation_confirm_prime" });
        }
        await startMotherTakeover();
        const requestedPhases = _normalizeAutomationMotherPhaseList(actionPayload.expect_mother_phases);
        const targetPhases = requestedPhases.length
          ? requestedPhases
          : [String(MOTHER_IDLE_STATES.OFFERING).toLowerCase()];
        if (targetPhases.includes(String(MOTHER_IDLE_STATES.OFFERING).toLowerCase())) {
          const waitingForUser = String(MOTHER_IDLE_STATES.WAITING_FOR_USER).toLowerCase();
          if (!targetPhases.includes(waitingForUser)) targetPhases.push(waitingForUser);
        }
        const timeoutMs = Math.max(
          500,
          Math.min(
            45000,
            Math.round(
              _coerceAutomationPayloadNumber(
                actionPayload.wait_timeout_ms,
                _coerceAutomationPayloadNumber(eventPayload.timeout_ms, 16000)
              )
            )
          )
        );
        const waitResult = await _waitForAutomationMotherPhases(targetPhases, timeoutMs);
        const after = String(state.motherIdle?.phase || "").toLowerCase() || before;
        ok = Boolean(waitResult.ok);
        detail = waitResult.ok
          ? `mother_confirm_suggestion executed (${before || "unknown"} -> ${after || "unknown"})`
          : `mother_confirm_suggestion timed out waiting for phases=${targetPhases.join(",")} (current=${waitResult.phase || after || "unknown"})`;
        events.push({
          type: "mother_confirm",
          marker: "mother_confirm_suggestion_completed",
          before,
          after,
          target_phases: targetPhases,
          timeout_ms: timeoutMs,
          reached_phase: waitResult.phase || after || null,
          timed_out: !waitResult.ok,
        });
        events.push({ type: "mother_state", marker: "mother_state", state: _automationStateEnvelope() });
      }
    } else if (action === "mother_reject_suggestion") {
      if (!state.motherIdle) {
        detail = "mother state unavailable";
      } else {
        const before = String(state.motherIdle?.phase || "").toLowerCase();
        stopMotherTakeover();
        const after = String(state.motherIdle?.phase || "").toLowerCase() || before;
        ok = true;
        detail = `mother_reject_suggestion executed (${before || "unknown"} -> ${after || "unknown"})`;
        events.push({ type: "mother_reject", marker: "mother_reject_suggestion_completed", before, after });
        events.push({ type: "mother_state", marker: "mother_state", state: _automationStateEnvelope() });
      }
    } else if (action === "select_canvas_image") {
      const imageId = _resolveCanvasImageIdFromPayload(actionPayload);
      if (!imageId) {
        detail = "select_canvas_image missing image_id/image_index/path";
      } else {
        const toggle = Boolean(actionPayload.toggle);
        await selectCanvasImage(imageId, { toggle });
        const selectedIds = getSelectedIds().slice(0, 3);
        ok = true;
        detail = `select_canvas_image id=${imageId}`;
        events.push({
          type: "selection_change",
          marker: "canvas_selection_updated",
          active_id: state.activeId || null,
          selected_ids: selectedIds,
          image_id: imageId,
          toggle,
        });
        events.push({ type: "canvas_state", marker: "canvas_state", state: _automationStateEnvelope() });
      }
    } else if (action === "set_canvas_mode") {
      const modeResult = _resolveAutomationCanvasMode(actionPayload.mode, "set_canvas_mode");
      if (!modeResult.ok) {
        detail = modeResult.detail;
      } else {
        const before = state.canvasMode;
        setCanvasMode(modeResult.mode);
        const after = state.canvasMode;
        ok = true;
        detail = `set_canvas_mode ${before || "unknown"} -> ${after || "unknown"}`;
        events.push({
          type: "canvas_mode_set",
          marker: "canvas_mode_changed",
          prev: before || null,
          next: after || modeResult.mode,
        });
        events.push({ type: "canvas_state", marker: "canvas_state", state: _automationStateEnvelope() });
      }
    } else if (action === "canvas_pan") {
      const result = _applyCanvasPanFromPayload({ ...actionPayload, mode: actionPayload.mode });
      if (!result.ok) {
        detail = result.detail;
      } else {
        ok = true;
        detail = result.detail;
        if (result.event) events.push(result.event);
        events.push({ type: "canvas_state", marker: "canvas_state", state: _automationStateEnvelope() });
      }
    } else if (action === "canvas_zoom") {
      const result = _applyCanvasZoomFromPayload({ ...actionPayload, mode: actionPayload.mode });
      if (!result.ok) {
        detail = result.detail;
      } else {
        ok = true;
        detail = result.detail;
        if (result.event) events.push(result.event);
        events.push({ type: "canvas_state", marker: "canvas_state", state: _automationStateEnvelope() });
      }
    } else if (action === "canvas_fit_all") {
      const result = _applyCanvasFitAllFromPayload({ ...actionPayload, mode: actionPayload.mode });
      if (!result.ok) {
        detail = result.detail;
      } else {
        ok = true;
        detail = result.detail;
        if (result.event) events.push(result.event);
        events.push({ type: "canvas_state", marker: "canvas_state", state: _automationStateEnvelope() });
      }
    } else if (action === "action_grid") {
      const out = await _runActionGridAutomation(actionPayload);
      if (out?.ok) {
        ok = true;
        detail = out.detail || "action_grid completed";
        events.push({
          type: "action_grid_press",
          marker: "action_grid_invoked",
          key: String(actionPayload.key || "").trim().toLowerCase() || null,
          hotkey: String(actionPayload.hotkey || "").trim() || null,
        });
        events.push({ type: "canvas_state", marker: "canvas_state", state: _automationStateEnvelope() });
      } else {
        detail = out?.detail || "action_grid failed";
      }
    }
  } catch (err) {
    ok = false;
    detail = err?.message || String(err || "automation action failed");
  }

  for (const event of events) {
    const marker = String(event?.marker || "").trim();
    if (marker) markers.add(marker);
  }

  if (!events.length) {
    events.push({ type: "automation_fallback", marker: "automation_fallback", detail: detail || "no event emitted", request_id: requestId });
    markers.add("automation_fallback");
  }

  console.log(`[desktop-automation] event_count=${events.length} for request_id=${requestId}`);
  console.log(`[desktop-automation] before append events request_id=${requestId}`);
  await _appendAutomationEvents(events, { requestId });
  console.log(`[desktop-automation] append complete request_id=${requestId}`);
  const reply = {
    request_id: requestId,
    ok,
    detail,
    state: _automationStateEnvelope(),
    events,
    markers: Array.from(markers),
  };
  console.log(`[desktop-automation] reporting result request_id=${requestId} ok=${ok} markers=${JSON.stringify(reply.markers)}`);
  try {
    await invoke("report_automation_result", { result: reply });
    console.log(`[desktop-automation] report_automation_result success request_id=${requestId}`);
  } catch (err) {
    console.log(`[desktop-automation] report_automation_result failed request_id=${requestId} detail=${String(err)}`);
    console.error(
      "[desktop-automation] report_automation_result failed",
      String(requestId),
      err
    );
    const failEvent = {
      type: "automation_result_invoke_failed",
      marker: "automation_result_invoke_failed",
      request_id: requestId,
      error: String(err),
      source: "desktop_ui_automation",
      detail: String(err),
    };
    await _appendAutomationEvents([failEvent], { requestId });
  }
}

function motherV2RoleMapClone() {
  const normalize = (list) =>
    Array.from(
      new Set(
        (Array.isArray(list) ? list : [])
          .map((v) => String(v || "").trim())
          .filter((id) => Boolean(id) && isVisibleCanvasImageId(id))
      )
    );
  const base = state.motherIdle?.roles || {};
  return {
    subject: normalize(base.subject),
    model: normalize(base.model),
    mediator: normalize(base.mediator),
    object: normalize(base.object),
  };
}

function motherV2NormalizeRoles(nextRoles = null) {
  const idle = state.motherIdle;
  if (!idle) return;
  const source = nextRoles && typeof nextRoles === "object" ? nextRoles : idle.roles || {};
  const out = { subject: [], model: [], mediator: [], object: [] };
  for (const key of MOTHER_V2_ROLE_KEYS) {
    const list = Array.isArray(source[key]) ? source[key] : [];
    out[key] = Array.from(new Set(list.map((v) => String(v || "").trim()).filter((id) => Boolean(id) && isVisibleCanvasImageId(id))));
  }
  idle.roles = out;
}

function motherV2InInteractivePhase() {
  const phase = state.motherIdle?.phase || motherIdleInitialState();
  return phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING || phase === MOTHER_IDLE_STATES.OFFERING;
}

function motherV2InCooldown() {
  const idle = state.motherIdle;
  if (!idle) return false;
  const now = Date.now();
  return idle.phase === MOTHER_IDLE_STATES.COOLDOWN && now < (Number(idle.cooldownUntil) || 0);
}

function motherV2CurrentIntentMode(intentPayload = null) {
  const intent = intentPayload && typeof intentPayload === "object"
    ? intentPayload
    : state.motherIdle?.intent && typeof state.motherIdle.intent === "object"
      ? state.motherIdle.intent
      : null;
  return motherV2NormalizeTransformationMode(intent?.transformation_mode);
}

function motherV2CurrentDraft() {
  const idle = state.motherIdle;
  if (!idle) return null;
  const drafts = Array.isArray(idle.drafts) ? idle.drafts : [];
  if (!drafts.length) return null;
  const selected = String(idle.selectedDraftId || "").trim();
  if (selected) {
    const match = drafts.find((d) => String(d?.id || "") === selected) || null;
    if (match) return match;
  }
  return drafts[0] || null;
}

function motherV2CurrentDraftMode(draft = null) {
  const entry = draft && typeof draft === "object" ? draft : motherV2CurrentDraft();
  if (!entry) return null;
  const rawMode = entry.proposalMode || entry.transformation_mode || null;
  return rawMode ? motherV2NormalizeTransformationMode(rawMode) : null;
}

function motherV2DispatchInFlight(idle = state.motherIdle) {
  if (!idle) return false;
  if (!idle.pendingDispatchToken) return false;
  if (idle.phase === MOTHER_IDLE_STATES.DRAFTING) return true;
  if (idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING && idle.pendingDispatchSpeculative) return true;
  return false;
}

function motherV2QueueIntentReplay(reason = "pending_intent") {
  const idle = state.motherIdle;
  if (!idle) return false;
  const queuedBefore = Boolean(idle.intentReplayQueued);
  idle.intentReplayQueued = true;
  idle.intentReplayReason = String(reason || idle.intentReplayReason || "pending_intent");
  if (!queuedBefore) {
    appendMotherTraceLog({
      kind: "intent_replay_queued",
      traceId: idle.telemetry?.traceId || null,
      actionVersion: Number(idle.actionVersion) || 0,
      reason: idle.intentReplayReason,
    }).catch(() => {});
  }
  return !queuedBefore;
}

function motherV2MaybeArmIntentReplay(reason = "busy_cleared") {
  const idle = state.motherIdle;
  if (!idle || !idle.intentReplayQueued) return false;
  if (!motherIdleHasArmedCanvas()) return false;
  if (motherV2InCooldown()) return false;
  if (state.pointer.active) return false;
  if (idle.pendingIntent || idle.pendingPromptCompile || idle.pendingGeneration) return false;
  const replayReason = String(idle.intentReplayReason || reason || "busy_cleared");
  if (String(idle.phase || "") === MOTHER_IDLE_STATES.OBSERVING) {
    idle.intentReplayQueued = false;
    idle.intentReplayReason = null;
    appendMotherTraceLog({
      kind: "intent_replay_armed",
      traceId: idle.telemetry?.traceId || null,
      actionVersion: Number(idle.actionVersion) || 0,
      reason: replayReason,
      phase: MOTHER_IDLE_STATES.OBSERVING,
    }).catch(() => {});
    motherIdleArmFirstTimer();
    return true;
  }
  if (
    String(idle.phase || "") === MOTHER_IDLE_STATES.WATCHING ||
    String(idle.phase || "") === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING
  ) {
    idle.intentReplayQueued = false;
    idle.intentReplayReason = null;
    appendMotherTraceLog({
      kind: "intent_replay_armed",
      traceId: idle.telemetry?.traceId || null,
      actionVersion: Number(idle.actionVersion) || 0,
      reason: replayReason,
      phase: String(idle.phase || ""),
    }).catch(() => {});
    motherIdleArmIntentTimer();
    return true;
  }
  return false;
}

function motherV2SetIntentRealtimeBusy({ path = "", requestId = null } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const normalizedPath = String(path || "").trim();
  if (!normalizedPath) return;
  idle.intentRealtimeBusyPath = normalizedPath;
  idle.intentRealtimeBusyRequestId = requestId ? String(requestId || "").trim() || null : null;
  idle.intentRealtimeBusyUntil = Date.now() + MOTHER_V2_INTENT_RT_BUSY_TTL_MS;
}

function motherV2IntentRealtimeBusy(nowMs = Date.now()) {
  const idle = state.motherIdle;
  if (!idle) return false;
  const busyPath = String(idle.intentRealtimeBusyPath || "").trim();
  const busyUntil = Number(idle.intentRealtimeBusyUntil) || 0;
  if (!busyPath || busyUntil <= 0) return false;
  if (busyUntil > (Number(nowMs) || Date.now())) return true;
  idle.intentRealtimeBusyPath = null;
  idle.intentRealtimeBusyRequestId = null;
  idle.intentRealtimeBusyUntil = 0;
  motherV2MaybeArmIntentReplay("busy_ttl_expired");
  return false;
}

function motherV2ClearIntentRealtimeBusy({ path = "", requestId = null, force = false, reason = "completed" } = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  const busyPath = String(idle.intentRealtimeBusyPath || "").trim();
  if (!busyPath) return false;
  const busyRequestId = String(idle.intentRealtimeBusyRequestId || "").trim();
  const normalizedPath = String(path || "").trim();
  const normalizedRequestId = String(requestId || "").trim();
  const matchesPath = Boolean(normalizedPath && normalizedPath === busyPath);
  const matchesRequest = Boolean(normalizedRequestId && busyRequestId && normalizedRequestId === busyRequestId);
  if (!force && !matchesPath && !matchesRequest) return false;
  idle.intentRealtimeBusyPath = null;
  idle.intentRealtimeBusyRequestId = null;
  idle.intentRealtimeBusyUntil = 0;
  motherV2MaybeArmIntentReplay(reason);
  return true;
}

function motherV2UploadSettleDueAtMs() {
  const idle = state.motherIdle;
  if (!idle) return 0;
  const lastUploadAt = Number(idle.lastUploadCompletedAt) || 0;
  if (!lastUploadAt) return 0;
  return lastUploadAt + MOTHER_V2_UPLOAD_SETTLE_MS;
}

function motherV2UploadSettleRemainingMs(nowMs = Date.now()) {
  const dueAt = motherV2UploadSettleDueAtMs();
  if (!dueAt) return 0;
  return Math.max(0, dueAt - (Number(nowMs) || Date.now()));
}

function motherV2CurrentProposalHasPrefetchedDraft() {
  if (!MOTHER_V2_ENABLE_SPECULATIVE_PREFETCH) return false;
  const idle = state.motherIdle;
  if (!idle) return false;
  const draft = motherV2CurrentDraft();
  if (!draft) return false;
  const currentMode = motherV2CurrentIntentMode(idle.intent);
  const draftMode = motherV2CurrentDraftMode(draft);
  if (!draftMode || draftMode !== currentMode) return false;
  if ((Number(draft.actionVersion) || 0) !== (Number(idle.actionVersion) || 0)) return false;
  return true;
}

function motherV2InFlightSpeculativeMatchesCurrentProposal() {
  if (!MOTHER_V2_ENABLE_SPECULATIVE_PREFETCH) return false;
  const idle = state.motherIdle;
  if (!idle) return false;
  if (!idle.pendingDispatchSpeculative) return false;
  if (!motherV2DispatchInFlight(idle)) return false;
  if ((Number(idle.pendingActionVersion) || 0) !== (Number(idle.actionVersion) || 0)) return false;
  const pendingMode = motherV2NormalizeTransformationMode(idle.pendingDispatchProposalMode);
  const currentMode = motherV2CurrentIntentMode(idle.intent);
  return Boolean(pendingMode && currentMode && pendingMode === currentMode);
}

function motherV2ClearSpeculativePrefetchTimer() {
  const idle = state.motherIdle;
  if (!idle) return;
  clearTimeout(idle.speculativePrefetchTimer);
  idle.speculativePrefetchTimer = null;
}

function motherV2ClearLiveProposalRefreshTimer() {
  const idle = state.motherIdle;
  if (!idle) return;
  clearTimeout(idle.liveProposalRefreshTimer);
  idle.liveProposalRefreshTimer = null;
}

function motherV2CanUseLiveProposalRefresh(idle = state.motherIdle) {
  if (!idle) return false;
  if (!motherV2HasProposalImageSet()) return false;
  if (!idle.intent || !motherV2HasRealProposalPayload(idle.intent)) return false;
  return true;
}

function motherV2ScheduleLiveProposalRefresh({
  reason = "interaction",
  delayMs = MOTHER_V2_LIVE_PROPOSAL_REFRESH_DEBOUNCE_MS,
} = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  if (!motherV2CanUseLiveProposalRefresh(idle)) return false;
  motherV2ClearLiveProposalRefreshTimer();
  if (!idle.liveProposalUpdating) {
    idle.liveProposalUpdating = true;
    renderMotherReadout();
  }
  const delay = Math.max(80, Number(delayMs) || MOTHER_V2_LIVE_PROPOSAL_REFRESH_DEBOUNCE_MS);
  idle.liveProposalRefreshTimer = setTimeout(() => {
    const current = state.motherIdle;
    if (!current) return;
    current.liveProposalRefreshTimer = null;
    if (!motherV2CanUseLiveProposalRefresh(current)) {
      current.liveProposalUpdating = false;
      renderMotherReadout();
      return;
    }
    if (motherV2InCooldown()) {
      current.liveProposalUpdating = false;
      renderMotherReadout();
      return;
    }
    if (state.pointer.active) {
      motherV2ScheduleLiveProposalRefresh({
        reason: "pointer_active",
        delayMs: MOTHER_V2_LIVE_PROPOSAL_REFRESH_DEBOUNCE_MS,
      });
      return;
    }
    if (current.pendingIntent || current.pendingPromptCompile || current.pendingGeneration || current.pendingDispatchToken) {
      return;
    }
    const now = Date.now();
    const lastRefreshAt = Number(current.lastLiveProposalRefreshAt) || 0;
    if (lastRefreshAt > 0) {
      const sinceMs = Math.max(0, now - lastRefreshAt);
      if (sinceMs < MOTHER_V2_LIVE_PROPOSAL_REFRESH_MIN_INTERVAL_MS) {
        motherV2ScheduleLiveProposalRefresh({
          reason: "rate_limited",
          delayMs: MOTHER_V2_LIVE_PROPOSAL_REFRESH_MIN_INTERVAL_MS - sinceMs,
        });
        return;
      }
    }
    if (current.phase === MOTHER_IDLE_STATES.OBSERVING) {
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
    }
    if (current.phase === MOTHER_IDLE_STATES.WATCHING) {
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
    }
    if (current.phase !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
      current.liveProposalUpdating = false;
      renderMotherReadout();
      return;
    }
    current.lastLiveProposalRefreshAt = now;
    appendMotherTraceLog({
      kind: "live_proposal_refresh_started",
      traceId: current.telemetry?.traceId || null,
      actionVersion: Number(current.actionVersion) || 0,
      reason: String(reason || "interaction"),
      proposal_mode: motherV2CurrentIntentMode(current.intent),
    }).catch(() => {});
    motherV2RequestIntentInference()
      .then((started) => {
        if (started) return;
        const latest = state.motherIdle;
        if (!latest) return;
        latest.liveProposalUpdating = false;
        appendMotherTraceLog({
          kind: "live_proposal_refresh_skipped",
          traceId: latest.telemetry?.traceId || null,
          actionVersion: Number(latest.actionVersion) || 0,
          reason: "request_not_started",
        }).catch(() => {});
        renderMotherReadout();
      })
      .catch(() => {
        const latest = state.motherIdle;
        if (!latest) return;
        latest.liveProposalUpdating = false;
        renderMotherReadout();
      });
  }, delay);
  return true;
}

function motherV2SpeculativePrefetchGate(nowMs = Date.now()) {
  if (!MOTHER_V2_ENABLE_SPECULATIVE_PREFETCH) {
    return { ok: false, reason: "feature_disabled", retryAfterMs: 0 };
  }
  const idle = state.motherIdle;
  if (!idle) return { ok: false, reason: "no_idle", retryAfterMs: 0 };
  if (idle.phase !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
    return { ok: false, reason: "phase_not_intent", retryAfterMs: 0 };
  }
  if (!idle.intent || !motherV2HasRealProposalPayload(idle.intent)) {
    return { ok: false, reason: "missing_proposal_payload", retryAfterMs: 0 };
  }
  if (state.pointer.active) return { ok: false, reason: "pointer_active", retryAfterMs: 200 };
  if (motherV2InCooldown()) return { ok: false, reason: "cooldown", retryAfterMs: 0 };
  if (idle.liveProposalUpdating || idle.liveProposalRefreshTimer) {
    return { ok: false, reason: "live_refresh_active", retryAfterMs: 220 };
  }
  if (idle.pendingIntent || idle.pendingPromptCompile || idle.pendingGeneration || idle.pendingDispatchToken) {
    return { ok: false, reason: "dispatch_busy", retryAfterMs: 180 };
  }
  const lastUploadAt = Number(idle.lastUploadCompletedAt) || 0;
  if (!lastUploadAt) return { ok: false, reason: "no_upload_signal", retryAfterMs: 0 };
  if (lastUploadAt <= (Number(idle.lastSpeculativePrefetchUploadAt) || 0)) {
    return { ok: false, reason: "upload_already_prefetched", retryAfterMs: 0 };
  }
  const now = Number(nowMs) || Date.now();
  const settledAt = lastUploadAt + MOTHER_V2_UPLOAD_SETTLE_MS;
  if (now < settledAt) {
    return { ok: false, reason: "upload_not_settled", retryAfterMs: Math.max(25, settledAt - now) };
  }
  if (now > lastUploadAt + MOTHER_V2_UPLOAD_PREFETCH_WINDOW_MS) {
    return { ok: false, reason: "upload_window_elapsed", retryAfterMs: 0 };
  }
  if (motherV2CurrentProposalHasPrefetchedDraft()) {
    return { ok: false, reason: "prefetched_draft_already_ready", retryAfterMs: 0 };
  }
  return { ok: true, reason: null, retryAfterMs: 0 };
}

function motherV2CanRunSpeculativePrefetch(nowMs = Date.now()) {
  return motherV2SpeculativePrefetchGate(nowMs).ok;
}

function motherV2LogSpeculativePrefetchSkipped(reason = "unknown", { trigger = "intent_inferred" } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  appendMotherTraceLog({
    kind: "speculative_prefetch_skipped",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    trigger: String(trigger || "intent_inferred"),
    reason: String(reason || "unknown"),
    proposal_mode: motherV2CurrentIntentMode(idle.intent),
    upload_age_ms: Math.max(0, Date.now() - (Number(idle.lastUploadCompletedAt) || 0)),
  }).catch(() => {});
}

function motherV2ScheduleSpeculativePrefetch({ reason = "intent_inferred", delayMs = MOTHER_V2_SPECULATIVE_PREFETCH_DELAY_MS } = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  motherV2ClearSpeculativePrefetchTimer();
  const gate = motherV2SpeculativePrefetchGate();
  if (!gate.ok) {
    if (gate.reason === "upload_not_settled") {
      const retryDelay = Math.max(25, Number(gate.retryAfterMs) || 25);
      idle.speculativePrefetchTimer = setTimeout(() => {
        const current = state.motherIdle;
        if (!current) return;
        current.speculativePrefetchTimer = null;
        motherV2ScheduleSpeculativePrefetch({ reason: "upload_settle_retry", delayMs: 0 });
      }, retryDelay);
      return true;
    }
    motherV2LogSpeculativePrefetchSkipped(gate.reason, { trigger: reason });
    return false;
  }
  const delay = Math.max(0, Number(delayMs) || 0);
  idle.speculativePrefetchTimer = setTimeout(() => {
    const current = state.motherIdle;
    if (!current) return;
    current.speculativePrefetchTimer = null;
    const callbackGate = motherV2SpeculativePrefetchGate();
    if (!callbackGate.ok) {
      motherV2LogSpeculativePrefetchSkipped(callbackGate.reason, { trigger: `${reason}:timer` });
      return;
    }
    motherIdleDispatchGeneration()
      .then((started) => {
        if (!started) {
          motherV2LogSpeculativePrefetchSkipped("dispatch_not_started", { trigger: reason });
          return;
        }
        current.lastSpeculativePrefetchUploadAt = Number(current.lastUploadCompletedAt) || 0;
        appendMotherTraceLog({
          kind: "speculative_prefetch_started",
          traceId: current.telemetry?.traceId || null,
          actionVersion: Number(current.actionVersion) || 0,
          reason: String(reason || "intent_inferred"),
          proposal_mode: motherV2CurrentIntentMode(current.intent),
        }).catch(() => {});
      })
      .catch(() => {});
  }, delay);
  return true;
}

function motherV2RoleIds(roleKey) {
  const idle = state.motherIdle;
  if (!idle) return [];
  const list = Array.isArray(idle.roles?.[roleKey]) ? idle.roles[roleKey] : [];
  return list.map((v) => String(v || "").trim()).filter((id) => Boolean(id) && isVisibleCanvasImageId(id));
}

function motherV2SetRoleIds(roleKey, imageIds) {
  const idle = state.motherIdle;
  if (!idle) return;
  if (!MOTHER_V2_ROLE_KEYS.includes(roleKey)) return;
  idle.roles[roleKey] = Array.from(
    new Set(
      (Array.isArray(imageIds) ? imageIds : [])
        .map((v) => String(v || "").trim())
        .filter((id) => Boolean(id) && isVisibleCanvasImageId(id))
    )
  );
}

function motherV2ResetInteractionState() {
  const idle = state.motherIdle;
  if (!idle) return;
  idle.pendingIntent = false;
  idle.pendingPromptCompile = false;
  idle.pendingGeneration = false;
  idle.pendingFollowupAfterCooldown = false;
  idle.pendingFollowupReason = null;
  idle.pendingVisionImageIds = [];
  idle.pendingActionVersion = 0;
  idle.pendingIntentRequestId = null;
  idle.pendingIntentTransportRetryCount = 0;
  idle.pendingIntentStartedAt = 0;
  idle.pendingIntentUpgradeUntil = 0;
  idle.pendingIntentRealtimePath = null;
  idle.intentRealtimeBusyPath = null;
  idle.intentRealtimeBusyRequestId = null;
  idle.intentRealtimeBusyUntil = 0;
  idle.intentReplayQueued = false;
  idle.intentReplayReason = null;
  idle.pendingIntentPath = null;
  idle.pendingIntentPayload = null;
  idle.pendingDispatchSpeculative = false;
  idle.pendingDispatchProposalMode = null;
  idle.pendingPromptCompilePath = null;
  idle.pendingPromptCompileSpeculative = false;
  clearTimeout(idle.pendingIntentTimeout);
  idle.pendingIntentTimeout = null;
  clearTimeout(idle.pendingPromptCompileTimeout);
  idle.pendingPromptCompileTimeout = null;
  motherV2ClearSpeculativePrefetchTimer();
  motherV2ClearLiveProposalRefreshTimer();
  idle.liveProposalUpdating = false;
  idle.speculativePrefetchInFlight = false;
  idle.speculativePrefetchReadyMode = null;
  clearTimeout(idle.pendingVisionRetryTimer);
  idle.pendingVisionRetryTimer = null;
  clearMotherIdleDispatchTimeout();
  idle.pendingDispatchToken = 0;
  idle.dispatchTimeoutExtensions = 0;
  motherIdleResetDispatchCorrelation({ rememberPendingVersion: false });
}

function motherV2ClearGlyphs() {
  const idle = state.motherIdle;
  if (!idle) return;
  idle.roleGlyphHits = [];
  idle.roleGlyphDrag = null;
}

function motherV2ClearDraftsOnly({ removeFiles = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const drafts = Array.isArray(idle.drafts) ? idle.drafts.slice() : [];
  if (removeFiles) {
    for (const draft of drafts) {
      if (draft?.path) removeFile(String(draft.path)).catch(() => {});
      if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
    }
  }
  idle.drafts = [];
  idle.selectedDraftId = null;
  idle.hoverDraftId = null;
  idle.speculativePrefetchReadyMode = null;
}

function motherV2ClearIntentAndDrafts({ removeFiles = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  motherV2ClearDraftsOnly({ removeFiles });
  motherV2ClearLiveProposalRefreshTimer();
  idle.liveProposalUpdating = false;
  idle.lastLiveProposalRefreshAt = 0;
  idle.intent = null;
  idle.roles = { subject: [], model: [], mediator: [], object: [] };
  idle.offerDetailsOpen = false;
  idle.pendingVisionImageIds = [];
  clearTimeout(idle.pendingVisionRetryTimer);
  idle.pendingVisionRetryTimer = null;
  idle.pendingIntentRequestId = null;
  idle.pendingIntentTransportRetryCount = 0;
  idle.pendingIntentStartedAt = 0;
  idle.pendingIntentUpgradeUntil = 0;
  idle.pendingIntentRealtimePath = null;
  idle.intentRealtimeBusyPath = null;
  idle.intentRealtimeBusyRequestId = null;
  idle.intentRealtimeBusyUntil = 0;
  idle.intentReplayQueued = false;
  idle.intentReplayReason = null;
  idle.pendingIntentPath = null;
  idle.pendingDispatchSpeculative = false;
  idle.pendingDispatchProposalMode = null;
  idle.pendingPromptCompileSpeculative = false;
  motherV2ClearSpeculativePrefetchTimer();
  idle.speculativePrefetchInFlight = false;
  idle.speculativePrefetchReadyMode = null;
  idle.promptMotionProfile = null;
  state.pendingMotherDraft = null;
  idle.hintVisibleUntil = 0;
  idle.hintLevel = 0;
  clearTimeout(idle.hintFadeTimer);
  idle.hintFadeTimer = null;
  motherV2ClearGlyphs();
}

function motherV2CooldownMs({ rejected = false } = {}) {
  return rejected ? MOTHER_V2_COOLDOWN_AFTER_REJECT_MS : MOTHER_V2_COOLDOWN_AFTER_COMMIT_MS;
}

async function motherV2StartFollowupProposal({ reason = "manual_reject" } = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  if (idle.phase !== MOTHER_IDLE_STATES.OBSERVING) return false;
  if (!motherIdleHasArmedCanvas()) return false;
  if (state.pointer.active) return false;
  if (motherV2InCooldown()) return false;
  if (idle.pendingIntent || idle.pendingPromptCompile || idle.pendingGeneration) return false;
  idle.pendingFollowupReason = String(reason || "manual_reject");

  clearMotherIdleTimers({ first: true, takeover: false });
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED); // observing -> watching
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED); // watching -> intent_hypothesizing
  appendMotherTraceLog({
    kind: "followup_rehypothesis",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    reason: String(reason || "manual_reject"),
  }).catch(() => {});
  renderMotherReadout();
  const started = await motherV2RequestIntentInference();
  if (!started) {
    idle.pendingFollowupReason = null;
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.DISQUALIFY);
    return false;
  }
  return true;
}

function motherV2ArmCooldown({ rejected = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const ms = motherV2CooldownMs({ rejected });
  idle.cooldownUntil = Date.now() + ms;
  clearTimeout(idle.cooldownTimer);
  idle.cooldownTimer = setTimeout(() => {
    idle.cooldownTimer = null;
    const queueFollowupAfterCooldown = rejected && Boolean(idle.pendingFollowupAfterCooldown);
    idle.pendingFollowupAfterCooldown = false;
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.COOLDOWN_DONE);
    if (queueFollowupAfterCooldown) {
      motherV2StartFollowupProposal({ reason: "reject_followup" })
        .then((started) => {
          if (!started) motherIdleArmFirstTimer();
          renderMotherReadout();
        })
        .catch(() => {
          motherIdleArmFirstTimer();
          renderMotherReadout();
        });
      return;
    }
    motherIdleArmFirstTimer();
    renderMotherReadout();
  }, ms + 8);
}

function motherV2MarkStale(extra = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  idle.telemetry.stale = (Number(idle.telemetry?.stale) || 0) + 1;
  appendMotherTraceLog({
    kind: "stale",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    stale: Number(idle.telemetry?.stale) || 0,
    ...extra,
  }).catch(() => {});
}

function motherV2ForcePhase(nextState, eventName = "force") {
  const idle = state.motherIdle;
  if (!idle) return;
  const prev = idle.phase || motherIdleInitialState();
  const next = String(nextState || "").trim();
  if (!next || prev === next) return;
  idle.phase = next;
  const transitions = Array.isArray(idle.telemetry?.stateTransitions) ? idle.telemetry.stateTransitions : [];
  transitions.push({
    at_ms: Date.now(),
    from: String(prev || ""),
    to: next,
    event: String(eventName || "force"),
  });
  if (transitions.length > 96) transitions.splice(0, transitions.length - 96);
  if (idle.telemetry && typeof idle.telemetry === "object") idle.telemetry.stateTransitions = transitions;
  appendMotherTraceLog({
    kind: "state_transition",
    traceId: idle.telemetry?.traceId || null,
    from: String(prev || ""),
    to: next,
    event: String(eventName || "force"),
    actionVersion: Number(idle.actionVersion) || 0,
  }).catch(() => {});
  syncMotherPortrait();
}

function motherIdleHasArmedCanvas() {
  const base = motherIdleBaseImageItems();
  if (!motherV2HasProposalImageSet()) return false;
  if (state.canvasMode === "single") {
    const activeId = String(getVisibleActiveId() || "").trim();
    if (!activeId) return false;
    const active = state.imagesById.get(activeId) || getActiveImage() || null;
    const iw = Number(active?.img?.naturalWidth || active?.width) || 0;
    const ih = Number(active?.img?.naturalHeight || active?.height) || 0;
    return iw > 0 && ih > 0;
  }
  if (state.canvasMode !== "multi") return false;
  const required = base.slice(0, Math.min(2, base.length));
  for (const item of required) {
    const rect = state.freeformRects.get(item.id) || null;
    if (!rect) return false;
    if ((Number(rect.w) || 0) <= 0 || (Number(rect.h) || 0) <= 0) return false;
  }
  return true;
}

function motherV2HasProposalImageSet() {
  return motherIdleBaseImageItems().length >= MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL;
}

function motherPreferredGenerationModel() {
  const preferred = String(settings.imageModel || "").trim();
  return preferred || MOTHER_GENERATION_MODEL;
}

function motherIdleGenerationModelCandidates() {
  const out = [];
  const seen = new Set();
  const push = (raw) => {
    const model = String(raw || "").trim();
    if (!model) return;
    if (providerFromModel(model) !== "gemini") return;
    if (seen.has(model)) return;
    seen.add(model);
    out.push(model);
  };
  push(MOTHER_GENERATION_MODEL);
  push(pickGeminiImageModel());
  if (providerFromModel(settings.imageModel) === "gemini") push(settings.imageModel);
  return out.length ? out : [MOTHER_GENERATION_MODEL];
}

function motherIdlePickRetryModel(lastModel = null) {
  const current = String(lastModel || "").trim();
  const candidates = motherIdleGenerationModelCandidates();
  for (const model of candidates) {
    if (model !== current) return model;
  }
  return null;
}

function motherIdlePromptLineForPty(prompt) {
  return String(prompt || "")
    .replace(/\r?\n+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function motherEventVersionId(event) {
  const versionId = String(event?.version_id || "").trim();
  return versionId || null;
}

function motherIdleRememberIgnoredVersion(versionId) {
  const idle = state.motherIdle;
  const normalized = String(versionId || "").trim();
  if (!idle || !normalized) return;
  if (!(idle.ignoredVersionIds instanceof Set)) idle.ignoredVersionIds = new Set();
  idle.ignoredVersionIds.add(normalized);
  while (idle.ignoredVersionIds.size > 96) {
    const first = idle.ignoredVersionIds.values().next();
    if (first.done) break;
    idle.ignoredVersionIds.delete(first.value);
  }
}

function motherIdleIsIgnoredVersion(versionId) {
  const idle = state.motherIdle;
  const normalized = String(versionId || "").trim();
  if (!idle || !normalized) return false;
  return idle.ignoredVersionIds instanceof Set && idle.ignoredVersionIds.has(normalized);
}

function motherIdleResetDispatchCorrelation({ rememberPendingVersion = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const pendingVersionId = String(idle.pendingVersionId || "").trim();
  if (rememberPendingVersion && pendingVersionId) {
    motherIdleRememberIgnoredVersion(pendingVersionId);
  }
  idle.pendingVersionId = null;
  idle.pendingPromptLine = null;
}

function motherIdleDispatchVersionMatches(versionId) {
  const idle = state.motherIdle;
  if (!idle) return false;
  const expected = String(idle.pendingVersionId || "").trim();
  if (!expected) return true;
  const incoming = String(versionId || "").trim();
  if (!incoming) return true;
  return incoming === expected;
}

function motherIdleTrackVersionCreated(event = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  if (!motherV2DispatchInFlight(idle)) return;
  const versionId = motherEventVersionId(event);
  if (!versionId) return;
  if (!idle.pendingVersionId) {
    idle.pendingVersionId = versionId;
    motherIdleArmDispatchTimeout(
      MOTHER_GENERATION_POST_VERSION_TIMEOUT_MS,
      `Mother draft timed out after ${Math.round(MOTHER_GENERATION_POST_VERSION_TIMEOUT_MS / 1000)}s while image generation was in progress.`,
      { allowExtension: false }
    );
    appendMotherSuggestionLog({
      stage: "version_bound",
      request_id: idle.pendingSuggestionLog?.request_id || null,
      model: idle.lastDispatchModel || idle.pendingSuggestionLog?.model || null,
      version_id: versionId,
    }).catch(() => {});
    return;
  }
  if (idle.pendingVersionId === versionId) return;
  motherIdleRememberIgnoredVersion(versionId);
  appendMotherSuggestionLog({
    stage: "extra_version_ignored",
    request_id: idle.pendingSuggestionLog?.request_id || null,
    model: idle.lastDispatchModel || idle.pendingSuggestionLog?.model || null,
    expected_version_id: idle.pendingVersionId,
    ignored_version_id: versionId,
    ignored_prompt: event?.prompt ? String(event.prompt) : null,
  }).catch(() => {});
  console.warn("[mother_suggestion] ignored extra version", {
    expected_version_id: idle.pendingVersionId,
    ignored_version_id: versionId,
  });
}

function motherIdleTransitionTo(eventName) {
  if (!state.motherIdle) return motherIdleInitialState();
  const prev = state.motherIdle.phase;
  const next = motherIdleTransition(prev, eventName);
  state.motherIdle.phase = next;
  if (next !== prev) {
    const idle = state.motherIdle;
    const transitions = Array.isArray(idle.telemetry?.stateTransitions) ? idle.telemetry.stateTransitions : [];
    transitions.push({
      at_ms: Date.now(),
      from: String(prev || ""),
      to: String(next || ""),
      event: String(eventName || ""),
    });
    if (transitions.length > 96) transitions.splice(0, transitions.length - 96);
    if (idle.telemetry && typeof idle.telemetry === "object") idle.telemetry.stateTransitions = transitions;
    appendMotherTraceLog({
      kind: "state_transition",
      traceId: idle.telemetry?.traceId || null,
      from: String(prev || ""),
      to: String(next || ""),
      event: String(eventName || ""),
      actionVersion: Number(idle.actionVersion) || 0,
      accepted: Number(idle.telemetry?.accepted) || 0,
      rejected: Number(idle.telemetry?.rejected) || 0,
      deployed: Number(idle.telemetry?.deployed) || 0,
      stale: Number(idle.telemetry?.stale) || 0,
    }).catch(() => {});
    if (next === MOTHER_IDLE_STATES.OBSERVING) {
      motherV2ClearGlyphs();
    }
    syncMotherPortrait();
  }
  return next;
}

function clearMotherIdleTimers({ first = true, takeover = true } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  if (first) {
    clearTimeout(idle.firstIdleTimer);
    idle.firstIdleTimer = null;
    clearTimeout(idle.intentIdleTimer);
    idle.intentIdleTimer = null;
  }
  if (takeover) {
    clearTimeout(idle.takeoverTimer);
    idle.takeoverTimer = null;
  }
}

function clearMotherIdleDispatchTimeout() {
  const idle = state.motherIdle;
  if (!idle) return;
  clearTimeout(idle.dispatchTimeoutTimer);
  idle.dispatchTimeoutTimer = null;
}

function motherIdleArmDispatchTimeout(timeoutMs, message, { allowExtension = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  clearMotherIdleDispatchTimeout();
  const dispatchToken = Number(idle.pendingDispatchToken) || 0;
  if (!dispatchToken) return;
  const ms = Math.max(1_000, Number(timeoutMs) || MOTHER_GENERATION_TIMEOUT_MS);
  const fallbackMessage = message || `Mother draft timed out after ${Math.round(ms / 1000)}s.`;
  const extendable = Boolean(allowExtension);
  idle.dispatchTimeoutTimer = setTimeout(() => {
    const current = state.motherIdle;
    if (!current) return;
    if (Number(current.pendingDispatchToken) !== dispatchToken) return;
    if (extendable) {
      const hasBoundVersion = Boolean(String(current.pendingVersionId || "").trim());
      const extensionCount = Number(current.dispatchTimeoutExtensions) || 0;
      if (!hasBoundVersion && extensionCount < 1) {
        current.dispatchTimeoutExtensions = extensionCount + 1;
        const extensionMs = Math.max(1_000, Number(MOTHER_GENERATION_TIMEOUT_EXTENSION_MS) || 1_000);
        appendMotherSuggestionLog({
          stage: "dispatch_timeout_extended",
          request_id: current.pendingSuggestionLog?.request_id || null,
          model: current.lastDispatchModel || current.pendingSuggestionLog?.model || null,
          extension_count: current.dispatchTimeoutExtensions,
          extension_ms: extensionMs,
        }).catch(() => {});
        motherIdleArmDispatchTimeout(extensionMs, fallbackMessage, { allowExtension: false });
        return;
      }
    }
    motherIdleHandleGenerationFailed(fallbackMessage);
  }, ms);
}

function resetMotherIdleAndWheelState() {
  clearMotherIdleTimers({ first: true, takeover: true });
  clearMotherIdleDispatchTimeout();
  if (state.motherIdle) {
    state.motherIdle.hasGeneratedSinceInteraction = false;
    state.motherIdle.generatedImageId = null;
    state.motherIdle.generatedVersionId = null;
    state.motherIdle.pendingDispatchToken = 0;
    state.motherIdle.dispatchTimeoutExtensions = 0;
    motherIdleResetDispatchCorrelation({ rememberPendingVersion: false });
    state.motherIdle.promptMotionProfile = null;
    if (state.motherIdle.ignoredVersionIds instanceof Set) state.motherIdle.ignoredVersionIds.clear();
    state.motherIdle.waitingSince = 0;
    state.motherIdle.pendingSuggestionLog = null;
    state.motherIdle.lastSuggestionAt = 0;
    state.motherIdle.suppressFailureUntil = 0;
    state.motherIdle.retryAttempted = false;
    state.motherIdle.lastDispatchModel = null;
    state.motherIdle.blockedUntilUserInteraction = false;
    clearTimeout(state.motherIdle.cooldownTimer);
    state.motherIdle.cooldownTimer = null;
    clearTimeout(state.motherIdle.pendingIntentTimeout);
    state.motherIdle.pendingIntentTimeout = null;
    clearTimeout(state.motherIdle.pendingPromptCompileTimeout);
    state.motherIdle.pendingPromptCompileTimeout = null;
    state.motherIdle.actionVersion = 0;
    state.motherIdle.pendingActionVersion = 0;
    state.motherIdle.cooldownUntil = 0;
    state.motherIdle.multiUploadIdleBoostUntil = 0;
    state.motherIdle.lastUploadCompletedAt = 0;
    state.motherIdle.lastSpeculativePrefetchUploadAt = 0;
    clearTimeout(state.motherIdle.speculativePrefetchTimer);
    state.motherIdle.speculativePrefetchTimer = null;
    state.motherIdle.speculativePrefetchInFlight = false;
    state.motherIdle.speculativePrefetchReadyMode = null;
    clearTimeout(state.motherIdle.liveProposalRefreshTimer);
    state.motherIdle.liveProposalRefreshTimer = null;
    state.motherIdle.liveProposalUpdating = false;
    state.motherIdle.lastLiveProposalRefreshAt = 0;
    state.motherIdle.pendingIntent = false;
    state.motherIdle.pendingIntentRequestId = null;
    state.motherIdle.pendingIntentTransportRetryCount = 0;
    state.motherIdle.pendingIntentStartedAt = 0;
    state.motherIdle.pendingIntentUpgradeUntil = 0;
    state.motherIdle.pendingIntentRealtimePath = null;
    state.motherIdle.intentRealtimeBusyPath = null;
    state.motherIdle.intentRealtimeBusyRequestId = null;
    state.motherIdle.intentRealtimeBusyUntil = 0;
    state.motherIdle.intentReplayQueued = false;
    state.motherIdle.intentReplayReason = null;
    state.motherIdle.pendingIntentPath = null;
    state.motherIdle.pendingIntentPayload = null;
    state.motherIdle.pendingPromptCompile = false;
    state.motherIdle.pendingPromptCompileSpeculative = false;
    state.motherIdle.pendingPromptCompilePath = null;
    state.motherIdle.pendingVisionImageIds = [];
    clearTimeout(state.motherIdle.pendingVisionRetryTimer);
    state.motherIdle.pendingVisionRetryTimer = null;
    state.motherIdle.pendingGeneration = false;
    state.motherIdle.pendingDispatchSpeculative = false;
    state.motherIdle.pendingDispatchProposalMode = null;
    state.motherIdle.pendingFollowupAfterCooldown = false;
    state.motherIdle.pendingFollowupReason = null;
    state.motherIdle.lastRejectedProposal = null;
    state.motherIdle.rejectedModeHistoryByContext = {};
    state.motherIdle.cancelArtifactUntil = 0;
    state.motherIdle.cancelArtifactReason = null;
    state.motherIdle.currentOperationSpec = null;
    state.motherIdle.intent = null;
    state.motherIdle.roles = { subject: [], model: [], mediator: [], object: [] };
    state.motherIdle.drafts = [];
    state.motherIdle.selectedDraftId = null;
    state.motherIdle.hoverDraftId = null;
    state.motherIdle.commitMutationInFlight = false;
    state.motherIdle.roleGlyphHits = [];
    state.motherIdle.roleGlyphDrag = null;
    state.motherIdle.advancedOpen = false;
    state.motherIdle.optionReveal = false;
    state.motherIdle.hintLevel = 0;
    state.motherIdle.hintVisibleUntil = 0;
    clearTimeout(state.motherIdle.hintFadeTimer);
    state.motherIdle.hintFadeTimer = null;
    state.motherIdle.intensity = 62;
    state.motherIdle.commitUndo = null;
    state.motherIdle.telemetry = {
      traceId: `mother-${Date.now().toString(36)}-${Math.random().toString(16).slice(2, 8)}`,
      stateTransitions: [],
      accepted: 0,
      rejected: 0,
      deployed: 0,
      stale: 0,
    };
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.RESET);
  }
  closeMotherWheelMenu({ immediate: true });
  if (state.wheelMenu) {
    state.wheelMenu.anchorCss = null;
    state.wheelMenu.anchorWorld = null;
    clearTimeout(state.wheelMenu.hideTimer);
    state.wheelMenu.hideTimer = null;
    state.wheelMenu.open = false;
  }
  syncMotherPortrait();
}

function isMotherWheelOpen() {
  return Boolean(state.wheelMenu?.open);
}

function closeMotherWheelMenu({ immediate = false } = {}) {
  const menu = els.motherWheelMenu;
  const wheel = state.wheelMenu;
  if (!menu || !wheel) return;
  clearTimeout(wheel.hideTimer);
  wheel.hideTimer = null;
  wheel.open = false;
  menu.classList.remove("is-open");
  if (immediate) {
    menu.classList.add("hidden");
    return;
  }
  wheel.hideTimer = setTimeout(() => {
    if (state.wheelMenu?.open) return;
    menu.classList.add("hidden");
  }, 220);
}

function openMotherWheelMenuAt(ptCss) {
  const menu = els.motherWheelMenu;
  const wrap = els.canvasWrap;
  if (!menu || !wrap || !ptCss) return false;
  if (state.mother?.running) return false;

  const xRaw = Number(ptCss.x) || 0;
  const yRaw = Number(ptCss.y) || 0;
  const x = clamp(xRaw, 18, Math.max(18, wrap.clientWidth - 18));
  const y = clamp(yRaw, 18, Math.max(18, wrap.clientHeight - 18));

  clearTimeout(state.wheelMenu.hideTimer);
  state.wheelMenu.hideTimer = null;
  state.wheelMenu.open = true;
  state.wheelMenu.anchorCss = { x, y };
  state.wheelMenu.anchorWorld = canvasScreenCssToWorldCss({ x, y });

  menu.style.left = `${x}px`;
  menu.style.top = `${y}px`;
  menu.classList.remove("hidden");
  requestAnimationFrame(() => {
    if (!state.wheelMenu?.open) return;
    menu.classList.add("is-open");
  });
  return true;
}

async function dispatchMotherWheelAction(action) {
  const raw = String(action || "").trim();
  closeMotherWheelMenu({ immediate: false });
  if (raw) recordUserEvent("mother_wheel_action", { action: raw });
  if (raw === "add_photo") {
    const world = state.wheelMenu?.anchorWorld || canvasScreenCssToWorldCss(_defaultImportPointCss());
    await importPhotosAtCanvasPoint(world);
    return;
  }
}

function motherIdleUseCasePromptMeta(useCaseKey) {
  const key = _intentUseCaseKeyFromBranchId(useCaseKey) || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
  const title = _intentUseCaseTitle(key);
  return {
    key,
    title,
    goal: `direction anchored to ${String(title || "the active branch").toLowerCase()} while preserving active-image continuity`,
    cue: "keep the active image as the anchor and let secondary references support composition and atmosphere",
  };
}

function motherIdleInferUseCaseFromVisionLines(lines = []) {
  const haystack = (Array.isArray(lines) ? lines : [])
    .map((v) => String(v || "").trim())
    .filter(Boolean)
    .join(" ")
    .toLowerCase()
    .trim();
  if (!haystack) return null;
  const branches = Array.isArray(state.intent?.iconState?.branches) ? state.intent.iconState.branches : [];
  if (!branches.length) return null;
  let bestKey = null;
  let bestScore = 0;
  for (const branch of branches) {
    const key = String(branch?.branch_id || "").trim();
    if (!key) continue;
    let s = _intentBranchTokenScore(haystack, branch);
    if (typeof branch?.confidence === "number" && Number.isFinite(branch.confidence)) {
      s += clamp(Number(branch.confidence), 0, 1) * 0.75;
    }
    if (s > bestScore) {
      bestScore = s;
      bestKey = key;
    }
  }
  if (!bestKey || bestScore < 1.5) return null;
  return bestKey;
}

function motherIdlePickIntentHypotheses(visionLines = []) {
  const candidates = [];
  const seen = new Set();
  const push = (key, reason) => {
    const normalized = String(key || "").trim();
    if (!normalized) return;
    if (seen.has(normalized)) return;
    seen.add(normalized);
    candidates.push({
      key: normalized,
      reason: String(reason || "").trim() || "signal",
    });
  };

  const visionHint = motherIdleInferUseCaseFromVisionLines(visionLines);
  if (visionHint) push(visionHint, "vision_descriptions");

  const iconState = state.intent?.iconState || null;
  const availableBranchIds = (Array.isArray(iconState?.branches) ? iconState.branches : [])
    .map((branch) => String(branch?.branch_id || "").trim())
    .filter(Boolean);
  const suggested = pickSuggestedIntentBranch(iconState);
  const suggestedKey = _intentUseCaseKeyFromBranchId(suggested?.branch_id) || String(suggested?.branch_id || "").trim();
  if (suggestedKey) push(suggestedKey, suggested?.reason ? `intent_${suggested.reason}` : "intent_branch");

  const focusKey = _intentUseCaseKeyFromBranchId(state.intent?.focusBranchId || state.intent?.lockedBranchId || "");
  if (focusKey) push(focusKey, "intent_focus");

  if (!candidates.length) {
    push(availableBranchIds[0] || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE, "default_fallback");
  }

  const primary = candidates[0]?.key || availableBranchIds[0] || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE;
  const alternate =
    candidates.find((entry) => entry.key !== primary)?.key ||
    availableBranchIds.find((key) => key !== primary) ||
    MOTHER_V2_TRANSFORMATION_MODES.find((key) => key !== primary) ||
    primary;

  const whyParts = [];
  const primaryReason = candidates[0]?.reason || "signal";
  whyParts.push(`primary ${_intentUseCaseTitle(primary)} via ${primaryReason}`);
  if (alternate && alternate !== primary) {
    const altReason = candidates.find((entry) => entry.key === alternate)?.reason || "coverage";
    whyParts.push(`alternate ${_intentUseCaseTitle(alternate)} via ${altReason}`);
  }

  return {
    primary,
    alternate,
    reasonText: whyParts.join("; "),
    signals: candidates.map((entry) => ({
      use_case: entry.key,
      branch_id: entry.key,
      title: _intentUseCaseTitle(entry.key),
      reason: entry.reason,
    })),
  };
}

function motherIdleComputePlacementCss({ policy = "adjacent", targetId = null, draftIndex = 0 } = {}) {
  const wrap = els.canvasWrap;
  const canvasCssW = wrap?.clientWidth || 0;
  const canvasCssH = wrap?.clientHeight || 0;
  if (!canvasCssW || !canvasCssH) return null;
  const targetRect = targetId ? state.freeformRects.get(targetId) || null : null;
  const activeRect = state.activeId ? state.freeformRects.get(state.activeId) || null : null;
  const baseRect = targetRect || activeRect;

  const intersects = (a, b) => {
    if (!a || !b) return false;
    return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
  };
  const collidesWithExisting = (rect, ignoreIds = []) => {
    const ignore = new Set((Array.isArray(ignoreIds) ? ignoreIds : []).map((v) => String(v || "").trim()).filter(Boolean));
    for (const item of state.images || []) {
      const imageId = String(item?.id || "").trim();
      if (!imageId || ignore.has(imageId)) continue;
      const r = state.freeformRects.get(imageId) || null;
      if (!r) continue;
      if (intersects(rect, r)) return true;
    }
    return false;
  };

  if (policy === "replace" && baseRect) {
    return clampFreeformRectCss(
      { x: Number(baseRect.x) || 0, y: Number(baseRect.y) || 0, w: Number(baseRect.w) || 1, h: Number(baseRect.h) || 1, autoAspect: false },
      canvasCssW,
      canvasCssH
    );
  }

  const tile = Math.round(
    freeformDefaultTileCss(canvasCssW, canvasCssH, { count: Math.max(3, (state.images?.length || 0) + 1) }) * 0.88
  );
  const w = clamp(tile, 170, Math.round(canvasCssW * 0.46));
  const h = clamp(Math.round(w * 1.06), 170, Math.round(canvasCssH * 0.58));

  if (policy === "grid") {
    const gap = 24;
    const colCount = 2;
    const slot = Math.max(0, Number(draftIndex) || 0);
    const col = slot % colCount;
    const row = Math.floor(slot / colCount);
    const startX = baseRect ? (Number(baseRect.x) || 0) : Math.round((canvasCssW - (w * colCount + gap)) / 2);
    const startY = baseRect ? (Number(baseRect.y) || 0) : Math.round((canvasCssH - h) / 2);
    return clampFreeformRectCss(
      {
        x: Math.round(startX + col * (w + gap)),
        y: Math.round(startY + row * (h + gap)),
        w,
        h,
        autoAspect: true,
      },
      canvasCssW,
      canvasCssH
    );
  }

  // Adjacent placement (default): place to the right with 24px offset and avoid overlap.
  const gap = 24;
  let baseX = 0;
  let baseY = 0;
  if (baseRect) {
    baseX = (Number(baseRect.x) || 0) + (Number(baseRect.w) || 0) + gap;
    baseY = Number(baseRect.y) || 0;
  } else {
    let rightmost = 0;
    let topMost = 0;
    let seeded = false;
    for (const item of state.images || []) {
      const r = state.freeformRects.get(String(item?.id || "")) || null;
      if (!r) continue;
      const rx = Number(r.x) || 0;
      const rw = Number(r.w) || 0;
      const ry = Number(r.y) || 0;
      if (!seeded) {
        rightmost = rx + rw;
        topMost = ry;
        seeded = true;
      } else {
        rightmost = Math.max(rightmost, rx + rw);
        topMost = Math.min(topMost, ry);
      }
    }
    baseX = seeded ? rightmost + gap : gap;
    baseY = seeded ? topMost : gap;
  }
  let candidate = clampFreeformRectCss({ x: Math.round(baseX), y: Math.round(baseY), w, h, autoAspect: true }, canvasCssW, canvasCssH);
  const ignore = targetId ? [targetId] : [];
  for (let i = 0; i < 10 && collidesWithExisting(candidate, ignore); i += 1) {
    const nx = Number(candidate.x) + w + gap;
    const ny = Number(candidate.y) + (i % 2 === 0 ? 0 : h + gap);
    candidate = clampFreeformRectCss({ x: nx, y: ny, w, h, autoAspect: true }, canvasCssW, canvasCssH);
  }
  return candidate;
}

function motherV2OfferPreviewRectCss({ policy = "adjacent", targetId = null, draftIndex = 0 } = {}) {
  const wrap = els.canvasWrap;
  const canvasCssW = wrap?.clientWidth || 0;
  const canvasCssH = wrap?.clientHeight || 0;
  if (!canvasCssW || !canvasCssH) return null;
  const baseRect = motherIdleComputePlacementCss({ policy, targetId, draftIndex });
  if (!baseRect) return null;
  if (String(policy || "") === "replace") return baseRect;

  const ms = Math.max(0.0001, Number(state.multiView?.scale) || 1);
  const dpr = Math.max(0.0001, getDpr());
  const offsetCssX = (Number(state.multiView?.offsetX) || 0) / dpr;
  const offsetCssY = (Number(state.multiView?.offsetY) || 0) / dpr;
  const viewportX0 = (0 - offsetCssX) / ms;
  const viewportY0 = (0 - offsetCssY) / ms;
  const viewportW = Math.max(1, canvasCssW / ms);
  const viewportH = Math.max(1, canvasCssH / ms);

  const viewportMinCss = Math.max(1, Math.min(canvasCssW, canvasCssH));
  const minPreviewWorld = (viewportMinCss * MOTHER_OFFER_PREVIEW_MIN_VIEWPORT_COVER) / ms;
  const maxPreviewWorld = (viewportMinCss * MOTHER_OFFER_PREVIEW_MAX_VIEWPORT_COVER) / ms;

  const baseW = Math.max(1, Number(baseRect.w) || 1);
  const baseH = Math.max(1, Number(baseRect.h) || 1);
  let w = baseW * MOTHER_OFFER_PREVIEW_SCALE;
  let h = baseH * MOTHER_OFFER_PREVIEW_SCALE;
  let longest = Math.max(w, h);
  if (longest < minPreviewWorld) {
    const up = minPreviewWorld / Math.max(1, longest);
    w *= up;
    h *= up;
  }
  longest = Math.max(w, h);
  if (longest > maxPreviewWorld) {
    const down = maxPreviewWorld / Math.max(1, longest);
    w *= down;
    h *= down;
  }

  const cx = (Number(baseRect.x) || 0) + baseW * 0.5;
  const cy = (Number(baseRect.y) || 0) + baseH * 0.5;
  const edgePadWorld = Math.max(8, 10) / ms;
  let x = cx - w * 0.5;
  let y = cy - h * 0.5;
  const minX = viewportX0 + edgePadWorld;
  const minY = viewportY0 + edgePadWorld;
  const maxX = viewportX0 + viewportW - w - edgePadWorld;
  const maxY = viewportY0 + viewportH - h - edgePadWorld;
  x = clamp(x, minX, Math.max(minX, maxX));
  y = clamp(y, minY, Math.max(minY, maxY));
  return clampFreeformRectCss({ x, y, w, h, autoAspect: false }, canvasCssW, canvasCssH);
}

function motherV2ImageHints(images = []) {
  const hints = [];
  for (const img of Array.isArray(images) ? images : []) {
    hints.push(String(img?.vision_desc || "").trim());
    hints.push(String(img?.file || "").trim());
  }
  return hints.filter(Boolean);
}

function motherV2HasHumanSignal(hints = []) {
  const text = (Array.isArray(hints) ? hints : []).join(" ").toLowerCase();
  return /(person|people|human|face|portrait|selfie|woman|man|child)/i.test(text);
}

function motherV2HasPhotorealSignal(hints = []) {
  const text = (Array.isArray(hints) ? hints : []).join(" ").toLowerCase();
  return /\b(photo|photoreal|photorealistic|realistic|dslr|35mm|cinematic|film\s+still|bokeh|natural\s+light)\b/i.test(text);
}

function motherV2RankImageIdsByProminence(images = []) {
  const ranked = [];
  for (let idx = 0; idx < (Array.isArray(images) ? images.length : 0); idx += 1) {
    const img = images[idx];
    const id = String(img?.id || "").trim();
    if (!id) continue;
    const rect = img?.rect && typeof img.rect === "object" ? img.rect : null;
    const w = Math.max(0, Number(rect?.w) || 0);
    const h = Math.max(0, Number(rect?.h) || 0);
    const area = Math.max(0, w * h);
    ranked.push({ id, idx, area });
  }
  if (!ranked.length) return [];
  const hasArea = ranked.some((entry) => Number(entry.area) > 0);
  ranked.sort((a, b) => {
    if (hasArea && Number(b.area) !== Number(a.area)) return Number(b.area) - Number(a.area);
    return Number(a.idx) - Number(b.idx);
  });
  return ranked.map((entry) => String(entry.id));
}

function motherV2IntentFromRealtimeIcons(iconState = null, payload = {}) {
  const icons = iconState && typeof iconState === "object" ? iconState : {};
  const images = Array.isArray(payload.images) ? payload.images : [];
  const imageIds = images.map((img) => String(img?.id || "").trim()).filter(Boolean);
  const imageIdSet = new Set(imageIds);
  const selectedIds = motherV2NormalizeImageIdList(payload.selected_ids || []).filter((id) => imageIdSet.has(id));
  const rankedIds = motherV2RankImageIdsByProminence(images).filter((id) => imageIdSet.has(id));
  const activeIdRaw = String(payload.active_id || "").trim();
  const activeId = imageIdSet.has(activeIdRaw) ? activeIdRaw : null;
  const branches = Array.isArray(icons.branches) ? icons.branches : [];
  const checkpointBranchId = String(icons?.checkpoint?.applies_to || "").trim();
  const preferredBranch = checkpointBranchId
    ? branches.find((branch) => String(branch?.branch_id || "").trim() === checkpointBranchId) || null
    : null;
  const topBranch = preferredBranch || branches[0] || null;
  const evidenceIds = Array.isArray(topBranch?.evidence_image_ids)
    ? topBranch.evidence_image_ids.map((v) => String(v || "").trim()).filter((id) => imageIdSet.has(id))
    : [];

  const targetIds = [];
  const pushTarget = (rawId) => {
    const id = String(rawId || "").trim();
    if (!id || !imageIdSet.has(id)) return;
    if (targetIds.includes(id)) return;
    targetIds.push(id);
  };
  if (selectedIds.length) {
    for (const id of selectedIds) pushTarget(id);
  } else if (evidenceIds.length) {
    pushTarget(evidenceIds[0]);
  } else if (activeId) {
    pushTarget(activeId);
  } else {
    pushTarget(rankedIds[0] || imageIds[0] || "");
  }

  const referenceIds = [];
  const pushRef = (rawId) => {
    const id = String(rawId || "").trim();
    if (!id || !imageIdSet.has(id)) return;
    if (targetIds.includes(id)) return;
    if (referenceIds.includes(id)) return;
    referenceIds.push(id);
  };
  for (const id of evidenceIds) pushRef(id);
  for (const id of rankedIds) pushRef(id);
  for (const id of imageIds) pushRef(id);

  const transformationModeCandidates = [];
  const pushModeCandidate = (rawMode, rawConfidence = null, rawAweJoyScore = null, { idx = null } = {}) => {
    const normalized = motherV2NormalizeModeCandidate(
      {
        mode: rawMode,
        confidence: rawConfidence,
        awe_joy_score: rawAweJoyScore,
      },
      { idx: idx === null ? transformationModeCandidates.length : idx }
    );
    if (!normalized) return;
    const existing = transformationModeCandidates.find((entry) => entry.mode === normalized.mode) || null;
    if (!existing) {
      transformationModeCandidates.push(normalized);
      return;
    }
    if (typeof normalized.confidence === "number") {
      const prior = typeof existing.confidence === "number" ? existing.confidence : -1;
      if (normalized.confidence > prior) existing.confidence = normalized.confidence;
    }
    if (typeof normalized.awe_joy_score === "number") {
      const prior = typeof existing.awe_joy_score === "number" ? existing.awe_joy_score : -1;
      if (normalized.awe_joy_score > prior) existing.awe_joy_score = normalized.awe_joy_score;
    }
    const priorIdx = Number.isFinite(Number(existing._idx)) ? Number(existing._idx) : Number.MAX_SAFE_INTEGER;
    const nextIdx = Number.isFinite(Number(normalized._idx)) ? Number(normalized._idx) : Number.MAX_SAFE_INTEGER;
    existing._idx = Math.min(priorIdx, nextIdx);
  };
  const explicitRealtimeModeHint = motherV2MaybeTransformationMode(icons?.transformation_mode);
  if (explicitRealtimeModeHint) pushModeCandidate(explicitRealtimeModeHint, null, null, { idx: 0 });
  let modeCandidateIdx = explicitRealtimeModeHint ? 1 : 0;
  for (const candidate of Array.isArray(icons?.transformation_mode_candidates) ? icons.transformation_mode_candidates : []) {
    pushModeCandidate(candidate?.mode || candidate?.transformation_mode, candidate?.confidence, candidate?.awe_joy_score, {
      idx: modeCandidateIdx,
    });
    modeCandidateIdx += 1;
  }
  transformationModeCandidates.sort(motherV2CompareModeCandidates);
  const transformationMode = motherV2MaybeTransformationMode(transformationModeCandidates[0]?.mode || explicitRealtimeModeHint);
  if (transformationMode) {
    pushModeCandidate(transformationMode, null, null, { idx: modeCandidateIdx + 1 });
    transformationModeCandidates.sort(motherV2CompareModeCandidates);
  }
  const rankedTransformationModeCandidates = transformationModeCandidates.slice(0, motherV2ProposalLimit()).map((entry) => ({
    mode: entry.mode,
    awe_joy_score: typeof entry.awe_joy_score === "number" ? entry.awe_joy_score : null,
    confidence: typeof entry.confidence === "number" ? entry.confidence : null,
  }));

  const summary = transformationMode
    ? motherV2ProposalSentence({ transformation_mode: transformationMode })
    : "Proposal pending realtime mode";
  const confidence = clamp(
    typeof topBranch?.confidence === "number" && Number.isFinite(topBranch.confidence)
      ? Number(topBranch.confidence)
      : rankedTransformationModeCandidates.length && typeof rankedTransformationModeCandidates[0].confidence === "number"
        ? Number(rankedTransformationModeCandidates[0].confidence)
        : targetIds.length
          ? 0.78
          : 0.62,
    0.2,
    0.99
  );

  const placementPolicy = imageIds.length >= 4
    ? "grid"
    : targetIds.length && referenceIds.length
      ? "adjacent"
      : targetIds.length
        ? "replace"
        : "adjacent";
  const subject = targetIds.slice(0, 1);
  const model = referenceIds.slice(0, 1);
  const mediator = referenceIds.slice(1, 2).length ? referenceIds.slice(1, 2) : referenceIds.slice(0, 1);
  const obj = targetIds.slice(0, 1);
  const actionVersion = Number(payload.action_version) || 0;
  const frameId = String(icons?.frame_id || "").trim();
  const branchId = String(topBranch?.branch_id || "").trim();
  const shotTypeHints = motherV2ShotTypeHints({
    preferredMode: transformationMode,
    candidateModes: rankedTransformationModeCandidates,
  });
  return {
    intent_id: frameId ? `intent-rt-${frameId}` : `intent-rt-${actionVersion}-${Math.random().toString(16).slice(2, 7)}`,
    summary,
    creative_directive: motherCurrentCreativeDirective(),
    transformation_mode: transformationMode || null,
    transformation_mode_candidates: rankedTransformationModeCandidates,
    shot_type: shotTypeHints.primary_shot_type,
    alternate_shot_type: shotTypeHints.alternate_shot_type,
    lighting_profile: shotTypeHints.primary_lighting_profile,
    alternate_lighting_profile: shotTypeHints.alternate_lighting_profile,
    lens_guidance: shotTypeHints.primary_lens_guidance,
    alternate_lens_guidance: shotTypeHints.alternate_lens_guidance,
    shot_type_hints: shotTypeHints,
    target_ids: targetIds.slice(0, 3),
    reference_ids: referenceIds.slice(0, 3),
    placement_policy: placementPolicy,
    confidence,
    roles: {
      subject,
      model,
      mediator,
      object: obj,
    },
    realtime_frame_id: frameId || null,
    branch_id: branchId || null,
    alternatives: [
      { placement_policy: "adjacent" },
      { placement_policy: "grid" },
    ],
  };
}

function motherV2CompilePromptLocal(payload = {}) {
  const intent = payload.intent && typeof payload.intent === "object" ? payload.intent : {};
  const summary =
    String(intent.summary || intent.label || "").trim() ||
    MOTHER_V2_PROPOSAL_BY_MODE[MOTHER_V2_DEFAULT_TRANSFORMATION_MODE];
  const creativeDirective =
    String(payload.creative_directive || intent.creative_directive || "").trim() || motherCurrentCreativeDirective();
  const transformationMode = motherV2NormalizeTransformationMode(
    payload.transformation_mode || intent.transformation_mode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE
  );
  const shotTypeHints = motherV2ShotTypeHints({
    preferredMode: transformationMode,
    candidateModes: Array.isArray(intent.transformation_mode_candidates) ? intent.transformation_mode_candidates : [],
  });
  const roles = intent.roles && typeof intent.roles === "object" ? intent.roles : {};
  const subjectIds = Array.isArray(roles.subject) ? roles.subject.map((v) => String(v || "").trim()).filter(Boolean).slice(0, 2) : [];
  const modelIds = Array.isArray(roles.model) ? roles.model.map((v) => String(v || "").trim()).filter(Boolean).slice(0, 2) : [];
  const roleText = MOTHER_V2_ROLE_KEYS.map((key) => {
    const ids = Array.isArray(roles[key]) ? roles[key].map((v) => String(v || "").trim()).filter(Boolean) : [];
    return `${MOTHER_V2_ROLE_LABEL[key] || key.toUpperCase()}: ${ids.length ? ids.join(", ") : "none"}`;
  }).join("; ");
  const targetIds = Array.isArray(intent.target_ids) ? intent.target_ids.map((v) => String(v || "").trim()).filter(Boolean) : [];
  const referenceIds = Array.isArray(intent.reference_ids) ? intent.reference_ids.map((v) => String(v || "").trim()).filter(Boolean) : [];
  const activeId = String(payload.active_id || getVisibleActiveId() || "").trim();
  const contextIds = [];
  for (const id of [...targetIds, ...referenceIds]) {
    if (id && !contextIds.includes(id)) contextIds.push(id);
  }
  const imageRows = Array.isArray(payload.images) ? payload.images : [];
  const imageById = new Map(
    imageRows
      .map((entry) => [String(entry?.id || "").trim(), entry])
      .filter(([id]) => Boolean(id))
  );
  const parseTransformLock = (rawTransform = null) => {
    if (!rawTransform || typeof rawTransform !== "object") return null;
    const rotateDeg = Number(rawTransform.rotate_deg);
    const skewXDeg = Number(rawTransform.skew_x_deg);
    const userResized = Boolean(rawTransform.user_resized);
    return {
      rotateDeg: Number.isFinite(rotateDeg) ? normalizeFreeformRotateDeg(rotateDeg) : 0,
      skewXDeg: Number.isFinite(skewXDeg) ? normalizeFreeformSkewDeg(skewXDeg) : 0,
      userResized,
    };
  };
  const transformById = new Map(
    imageRows
      .map((entry) => {
        const imageId = String(entry?.id || "").trim();
        if (!imageId) return null;
        const transform = parseTransformLock(entry?.transform);
        return transform ? [imageId, transform] : null;
      })
      .filter(Boolean)
  );
  const activeAnchorId = activeId || targetIds[0] || contextIds[0] || "";
  const activeAnchorImage = activeAnchorId ? imageById.get(activeAnchorId) || null : null;
  const activeAnchorHints = activeAnchorImage
    ? [
        String(activeAnchorImage?.vision_desc || "").trim(),
        String(activeAnchorImage?.file || "").trim(),
      ].filter(Boolean)
    : [];
  const activeAnchorPhotoreal = motherV2HasPhotorealSignal(activeAnchorHints);
  const multiImage = contextIds.length > 1;
  const imageHints = motherV2ImageHints(payload.images || []);
  const hasHumanInputs = motherV2HasHumanSignal(imageHints);
  const activeAnchorTransform = activeAnchorId ? transformById.get(activeAnchorId) || null : null;
  const transformLockedIds = contextIds
    .map((id) => ({ id, transform: transformById.get(id) || null }))
    .filter((entry) => {
      const transform = entry?.transform;
      if (!transform) return false;
      if (transform.userResized) return true;
      return Math.abs(Number(transform.rotateDeg) || 0) > 0.2 || Math.abs(Number(transform.skewXDeg) || 0) > 0.2;
    })
    .slice(0, 3);
  const allowDoubleExposure = ["destabilize", "fracture", "alienate"].includes(transformationMode);
  const constraints = [
    "No unintended ghosted human overlays.",
    allowDoubleExposure
      ? "Allow intentional double-exposure only when it clearly supports the chosen transformation mode."
      : "No accidental double-exposure artifacts.",
    "No icon-overpaint artifacts.",
    "Keep role-anchor cues readable when continuity matters.",
  ];
  if (activeAnchorId) {
    constraints.push(
      `Preserve active image ${activeAnchorId} identity, framing, and scene continuity as the primary edit anchor.`
    );
    constraints.push("Apply proposal changes as controlled edits, not a full replacement of the anchor image.");
  }
  if (activeAnchorPhotoreal) {
    constraints.push("Keep the output photorealistic with natural lighting, lens behavior, and realistic surface texture.");
  }
  if (!hasHumanInputs) {
    constraints.push("No extra humans or faces unless clearly present in the input references.");
  }
  if (transformLockedIds.length) {
    constraints.push("Respect current canvas transform locks (rotation, skew, and user-set scale) for referenced source images.");
  }
  const multiImageRules = [];
  if (multiImage) {
    multiImageRules.push("Fuse all references into one striking scene (not a split-screen collage).");
    if (subjectIds.length && modelIds.length) {
      multiImageRules.push(
        `Blend cues from ${subjectIds.join(", ")} and ${modelIds.join(", ")} into one unexpected but visually compelling scene.`
      );
    } else if (targetIds.length && referenceIds.length) {
      multiImageRules.push(
        `Remix structure from ${targetIds[0]} with visual language from ${referenceIds[0]} in a surprising way.`
      );
    }
    multiImageRules.push("Use perspective, scale, and lighting intentionally so the blend feels deliberate.");
    multiImageRules.push("Keep a clear focal hierarchy so the image reads instantly.");
  }
  const positiveLines = [
    `Transformation mode: ${transformationMode}.`,
    `Shot type guidance: ${shotTypeHints.shot_instruction}`,
    `Lighting guidance: ${shotTypeHints.lighting_instruction}`,
    shotTypeHints.lens_instruction,
    `Creative directive: ${creativeDirective}.`,
    `Intent summary: ${summary}.`,
    `Role anchors: ${roleText}.`,
  ];
  if (activeAnchorId) {
    positiveLines.push(
      `Active image anchor: ${activeAnchorId}. Preserve as much of this image as possible while integrating the proposal.`
    );
  }
  if (activeAnchorPhotoreal) {
    positiveLines.push("Style continuity: keep the anchor image photorealistic and avoid painterly/cartoon stylization.");
  }
  if (activeAnchorTransform) {
    const transformParts = [];
    if (Math.abs(Number(activeAnchorTransform.rotateDeg) || 0) > 0.2) {
      transformParts.push(`rotation ${Number(activeAnchorTransform.rotateDeg).toFixed(2)}deg`);
    }
    if (Math.abs(Number(activeAnchorTransform.skewXDeg) || 0) > 0.2) {
      transformParts.push(`skew ${Number(activeAnchorTransform.skewXDeg).toFixed(2)}deg`);
    }
    if (activeAnchorTransform.userResized) transformParts.push("user-resized scale");
    if (transformParts.length) {
      positiveLines.push(`Active anchor transform lock: preserve ${transformParts.join(", ")} unless explicitly contradicted by intent.`);
    }
  }
  if (transformLockedIds.length) {
    const lockList = transformLockedIds
      .map((entry) => {
        const transform = entry.transform || {};
        const parts = [];
        if (Math.abs(Number(transform.rotateDeg) || 0) > 0.2) parts.push(`rot ${Number(transform.rotateDeg).toFixed(2)}deg`);
        if (Math.abs(Number(transform.skewXDeg) || 0) > 0.2) parts.push(`skew ${Number(transform.skewXDeg).toFixed(2)}deg`);
        if (transform.userResized) parts.push("resized");
        if (!parts.length) return "";
        return `${entry.id}(${parts.join(", ")})`;
      })
      .filter(Boolean);
    if (lockList.length) {
      positiveLines.push(`Canvas transform guidance: ${lockList.join("; ")}.`);
    }
  }
  if (multiImageRules.length) {
    positiveLines.push(`Multi-image fusion rules: ${multiImageRules.join(" ")}`);
  }
  positiveLines.push(`Anti-overlay constraints: ${constraints.join(" ")}`);
  positiveLines.push("Produce bold composition, emotional resonance, and production-grade lighting.");
  positiveLines.push("No text overlays, words, letters, logos-as-text, or watermarks.");
  positiveLines.push("Create one production-ready concept image.");
  return {
    action_version: Number(payload.action_version) || 0,
    creative_directive: creativeDirective,
    transformation_mode: transformationMode,
    shot_type: shotTypeHints.primary_shot_type,
    alternate_shot_type: shotTypeHints.alternate_shot_type,
    lighting_profile: shotTypeHints.primary_lighting_profile,
    alternate_lighting_profile: shotTypeHints.alternate_lighting_profile,
    lens_guidance: shotTypeHints.primary_lens_guidance,
    alternate_lens_guidance: shotTypeHints.alternate_lens_guidance,
    shot_type_hints: shotTypeHints,
    positive_prompt: positiveLines.join(" "),
    negative_prompt: `No collage split-screen. No text overlays. No watermark. No ghosted human overlays. No icon-overpaint artifacts. No low-detail artifacts. ${
      hasHumanInputs ? "No unintended extra faces." : "No extra humans/faces unless present in inputs."
    }`,
    compile_constraints: constraints,
    generation_params: {
      guidance_scale: 7,
      layout_hint: String(intent.placement_policy || "adjacent"),
      seed_strategy: "random",
      transformation_mode: transformationMode,
      intensity: clamp(Number(payload.intensity) || Number(state.motherIdle?.intensity) || 62, 0, 100),
    },
  };
}

async function motherV2WritePayloadFile(prefix, payload = {}) {
  if (!state.runDir) return null;
  const stamp = `${Date.now()}-${Math.random().toString(16).slice(2, 6)}`;
  const outPath = `${state.runDir}/${prefix}-${stamp}.json`;
  try {
    await writeTextFile(outPath, JSON.stringify(payload, null, 2));
    return outPath;
  } catch {
    return null;
  }
}

function motherV2AmbientIntentHints(maxBranches = 3) {
  const iconState = state.intentAmbient?.iconState;
  const branches = Array.isArray(iconState?.branches) ? iconState.branches.slice() : [];
  if (!branches.length) return [];
  const normalized = branches
    .map((branch) => {
      if (!branch || typeof branch !== "object") return null;
      const branchId = String(branch.branch_id || "").trim();
      if (!branchId) return null;
      const confidence = typeof branch.confidence === "number" && Number.isFinite(branch.confidence)
        ? clamp(Number(branch.confidence) || 0, 0, 1)
        : null;
      const evidence = Array.isArray(branch.evidence_image_ids)
        ? branch.evidence_image_ids.map((v) => String(v || "").trim()).filter(Boolean).slice(0, 3)
        : [];
      return {
        branch_id: branchId,
        confidence,
        evidence_image_ids: evidence,
      };
    })
    .filter(Boolean);
  normalized.sort((a, b) => {
    const ac = typeof a.confidence === "number" ? a.confidence : -1;
    const bc = typeof b.confidence === "number" ? b.confidence : -1;
    return bc - ac;
  });
  return normalized.slice(0, Math.max(1, Number(maxBranches) || 3));
}

function motherV2AmbientTransformationModeHints() {
  const iconState = state.intentAmbient?.iconState;
  if (!iconState || typeof iconState !== "object") {
    return { preferredMode: null, candidates: [] };
  }
  const candidates = [];
  const pushCandidate = (rawMode, rawConfidence = null, rawAweJoyScore = null, { idx = null } = {}) => {
    const normalized = motherV2NormalizeModeCandidate(
      {
        mode: rawMode,
        confidence: rawConfidence,
        awe_joy_score: rawAweJoyScore,
      },
      { idx: idx === null ? candidates.length : idx }
    );
    if (!normalized) return;
    const exists = candidates.find((entry) => entry.mode === normalized.mode);
    if (!exists) {
      candidates.push(normalized);
      return;
    }
    if (typeof normalized.confidence === "number") {
      const prior = typeof exists.confidence === "number" ? exists.confidence : -1;
      if (normalized.confidence > prior) exists.confidence = normalized.confidence;
    }
    if (typeof normalized.awe_joy_score === "number") {
      const prior = typeof exists.awe_joy_score === "number" ? exists.awe_joy_score : -1;
      if (normalized.awe_joy_score > prior) exists.awe_joy_score = normalized.awe_joy_score;
    }
    const priorIdx = Number.isFinite(Number(exists._idx)) ? Number(exists._idx) : Number.MAX_SAFE_INTEGER;
    const nextIdx = Number.isFinite(Number(normalized._idx)) ? Number(normalized._idx) : Number.MAX_SAFE_INTEGER;
    exists._idx = Math.min(priorIdx, nextIdx);
  };

  pushCandidate(iconState.transformation_mode, null, null, { idx: 0 });
  let modeCandidateIdx = 1;
  for (const entry of Array.isArray(iconState.transformation_mode_candidates) ? iconState.transformation_mode_candidates : []) {
    if (!entry || typeof entry !== "object") continue;
    pushCandidate(entry.mode || entry.transformation_mode, entry.confidence, entry.awe_joy_score, {
      idx: modeCandidateIdx,
    });
    modeCandidateIdx += 1;
  }
  candidates.sort(motherV2CompareModeCandidates);
  const outputCandidates = candidates.slice(0, motherV2ProposalLimit()).map((entry) => ({
    mode: entry.mode,
    awe_joy_score: typeof entry.awe_joy_score === "number" ? entry.awe_joy_score : null,
    confidence: typeof entry.confidence === "number" ? entry.confidence : null,
  }));
  return {
    preferredMode: outputCandidates[0]?.mode || null,
    candidates: outputCandidates,
  };
}

function motherV2PreferredTransformationModeHint() {
  const intentMode = motherV2MaybeTransformationMode(state.motherIdle?.intent?.transformation_mode);
  if (intentMode) return intentMode;
  return motherV2AmbientTransformationModeHints().preferredMode;
}

function motherV2CanvasContextSummaryHint() {
  const raw = typeof state.alwaysOnVision?.lastText === "string" ? state.alwaysOnVision.lastText.trim() : "";
  if (!raw) return null;
  const summary = extractCanvasContextSummary(raw);
  const normalized = String(summary || "").trim();
  if (!normalized) return null;
  return clampText(normalized, 240);
}

function motherV2BuildProposalContextForIntentPayload({
  images = [],
  selectedIds = [],
  activeId = null,
  preferredTransformationMode = "",
  transformationModeCandidates = [],
} = {}) {
  const sourceImages = Array.isArray(images) ? images : [];
  if (!sourceImages.length) return null;

  const SATURATION_K = Object.freeze({
    move: 8,
    resize: 4,
    transform: 5,
    selection: 8,
    action: 4,
  });
  const INTERACTION_DECAY_TAU_MS = 90_000;
  const INTERACTION_STALE_CUTOFF_MS = 10 * 60 * 1000;
  const EPS = 1e-9;
  const nowMs = Date.now();
  const selectedIdSet = new Set(
    (Array.isArray(selectedIds) ? selectedIds : [])
      .map((v) => String(v || "").trim())
      .filter(Boolean)
  );
  const activeIdNorm = String(activeId || "").trim();
  const clamp01 = (value) => clamp(Number(value) || 0, 0, 1);
  const round4 = (value) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return 0;
    return Math.round(n * 10000) / 10000;
  };
  const round2 = (value) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return 0;
    return Math.round(n * 100) / 100;
  };
  const sat = (count, k) => {
    const c = Math.max(0, Number(count) || 0);
    const cap = Math.max(1, Number(k) || 1);
    const v = Math.log(1 + c) / Math.log(1 + cap);
    return clamp01(v);
  };
  const slotLabelForIndex = (index) => {
    const i = Math.max(0, Math.floor(Number(index) || 0));
    if (i < 26) return String.fromCharCode(65 + i);
    return `I${i + 1}`;
  };
  const sizeTierFromArea = (areaRatio) => {
    const n = Math.max(0, Number(areaRatio) || 0);
    if (n >= 0.07) return "DOMINANT";
    if (n >= 0.03) return "MEDIUM";
    return "SMALL";
  };
  const positionTierFromRect = (rectNorm) => {
    const cx = Number(rectNorm?.cx);
    const cy = Number(rectNorm?.cy);
    if (!Number.isFinite(cx) || !Number.isFinite(cy)) return "CENTER_MIDDLE";
    const xTier = cx < 0.34 ? "LEFT" : cx > 0.66 ? "RIGHT" : "CENTER";
    const yTier = cy < 0.34 ? "TOP" : cy > 0.66 ? "BOTTOM" : "MIDDLE";
    return `${xTier}_${yTier}`;
  };
  const relationFromDelta = (dx, dy, overlaps = false) => {
    if (overlaps) return "OVERLAP";
    return Math.abs(dx) >= Math.abs(dy)
      ? (dx >= 0 ? "RIGHT" : "LEFT")
      : (dy >= 0 ? "BELOW" : "ABOVE");
  };

  const rows = [];
  const imageIds = [];
  for (let i = 0; i < sourceImages.length; i += 1) {
    const image = sourceImages[i];
    const id = String(image?.id || "").trim();
    if (!id || imageIds.includes(id)) continue;
    imageIds.push(id);
    const rectNormRaw = image?.rect_norm && typeof image.rect_norm === "object" ? image.rect_norm : null;
    const rectNorm = rectNormRaw
      ? {
          x: round4(Number(rectNormRaw.x) || 0),
          y: round4(Number(rectNormRaw.y) || 0),
          w: round4(Math.max(0, Number(rectNormRaw.w) || 0)),
          h: round4(Math.max(0, Number(rectNormRaw.h) || 0)),
          cx: round4((Number(rectNormRaw.x) || 0) + (Math.max(0, Number(rectNormRaw.w) || 0) / 2)),
          cy: round4((Number(rectNormRaw.y) || 0) + (Math.max(0, Number(rectNormRaw.h) || 0) / 2)),
        }
      : null;
    const canvasAreaRatio = rectNorm ? Math.max(0, Number(rectNorm.w) * Number(rectNorm.h)) : 0;
    rows.push({
      id,
      slot: slotLabelForIndex(rows.length),
      rect_norm: rectNorm,
      canvas_area_ratio: canvasAreaRatio,
      selected: selectedIdSet.has(id),
      active: Boolean(activeIdNorm && activeIdNorm === id),
      interaction_base: 0,
      interaction_raw: 0,
      interaction_stale: true,
      focus_score_raw: 0,
      focus_score: 0,
      geometry_score_raw: 0,
      geometry_score: 0,
      relative_scale_to_largest: 0,
      score: 0,
      weight_hint: 0,
      size_tier: sizeTierFromArea(canvasAreaRatio),
      position_tier: positionTierFromRect(rectNorm),
      geometry_trace: null,
    });
  }
  if (!rows.length) return null;

  const signalsById = motherV2CollectImageInteractionSignals(imageIds);
  for (const row of rows) {
    const signal = signalsById.get(row.id) || {
      move_count: 0,
      resize_count: 0,
      transform_count: 0,
      selection_hits: 0,
      action_grid_hits: 0,
      last_event_at_ms: 0,
      last_transform_at_ms: 0,
    };
    const moveSat = sat(signal.move_count, SATURATION_K.move);
    const resizeSat = sat(signal.resize_count, SATURATION_K.resize);
    const transformSat = sat(signal.transform_count, SATURATION_K.transform);
    const selectionSat = sat(signal.selection_hits, SATURATION_K.selection);
    const actionSat = sat(signal.action_grid_hits, SATURATION_K.action);
    const interactionBase =
      0.3 * moveSat + 0.22 * resizeSat + 0.23 * transformSat + 0.2 * selectionSat + 0.05 * actionSat;
    const transformRecencyMs = Number(signal.last_transform_at_ms) || 0;
    const recencyMs = transformRecencyMs || Number(signal.last_event_at_ms) || 0;
    const ageMs = recencyMs ? Math.max(0, nowMs - recencyMs) : INTERACTION_STALE_CUTOFF_MS + 1;
    const transformAgeMs = transformRecencyMs
      ? Math.max(0, nowMs - transformRecencyMs)
      : INTERACTION_STALE_CUTOFF_MS + 1;
    const interactionStale = transformAgeMs > INTERACTION_STALE_CUTOFF_MS;
    let interactionRaw = interactionStale
      ? 0
      : interactionBase * Math.exp(-ageMs / INTERACTION_DECAY_TAU_MS);
    if (
      Number(signal.move_count) <= 1 &&
      Number(signal.resize_count) === 0 &&
      Number(signal.transform_count) === 0 &&
      Number(signal.selection_hits) <= 2 &&
      Number(signal.action_grid_hits) === 0
    ) {
      interactionRaw = 0;
    }
    row.interaction_base = interactionBase;
    row.interaction_raw = Math.max(0, Number(interactionRaw) || 0);
    row.interaction_stale = interactionStale;
  }

  const interactionBaseMax = rows.reduce(
    (maxVal, row) => Math.max(maxVal, Math.max(0, Number(row.interaction_base) || 0)),
    0
  );
  const interactionRawMax = rows.reduce(
    (maxVal, row) => Math.max(maxVal, Math.max(0, Number(row.interaction_raw) || 0)),
    0
  );
  const interactionConfidence = clamp01((interactionBaseMax - 0.15) / 0.35);
  for (const row of rows) {
    const focusRaw = interactionRawMax > 0 ? (Number(row.interaction_raw) || 0) / (interactionRawMax + EPS) : 0;
    row.focus_score_raw = clamp01(focusRaw);
    row.focus_score = clamp01(interactionConfidence * row.focus_score_raw);
  }

  const areaValues = rows
    .map((row) => Math.max(0, Number(row.canvas_area_ratio) || 0))
    .filter((value) => value > 0);
  const areaMax = areaValues.length ? Math.max(...areaValues) : 0;
  const areaMin = areaValues.length ? Math.min(...areaValues) : 0;
  const sqrtAreaMax = areaMax > 0 ? Math.sqrt(areaMax) : 0;
  const geometryConfidence =
    areaMax > 0 && areaMin > 0
      ? clamp01(Math.log((areaMax + EPS) / (areaMin + EPS)) / Math.log(2.5))
      : 0;
  let geometryRawMax = 0;
  for (const row of rows) {
    const area = Math.max(0, Number(row.canvas_area_ratio) || 0);
    const size = sqrtAreaMax > 0 ? Math.sqrt(area) / (sqrtAreaMax + EPS) : 0;
    row.relative_scale_to_largest = clamp01(size);
    const cx = Number(row.rect_norm?.cx);
    const cy = Number(row.rect_norm?.cy);
    const centerDist = Number.isFinite(cx) && Number.isFinite(cy) ? Math.hypot(cx - 0.5, cy - 0.5) : 0.7071;
    const centrality = clamp01(1 - centerDist / 0.7071);
    const geometryRaw = 0.8 * size + 0.2 * centrality;
    row.geometry_score_raw = clamp01(geometryRaw);
    geometryRawMax = Math.max(geometryRawMax, row.geometry_score_raw);
  }
  for (const row of rows) {
    const normalized = geometryRawMax > 0 ? row.geometry_score_raw / (geometryRawMax + EPS) : 0;
    row.geometry_score = clamp01(geometryConfidence * normalized);
    row.score =
      (1 + 0.8 * row.focus_score) *
      (1 + 0.5 * row.geometry_score) *
      (1 + (row.selected ? 0.25 : 0) + (row.active ? 0.15 : 0));
  }

  let scoreTotal = rows.reduce((sum, row) => sum + Math.max(0, Number(row.score) || 0), 0);
  if (!(scoreTotal > 0)) {
    for (const row of rows) row.score = 1;
    scoreTotal = rows.length;
  }
  for (const row of rows) {
    row.weight_hint = scoreTotal > 0 ? (Number(row.score) || 0) / (scoreTotal + EPS) : 0;
    row.geometry_trace = {
      cx: round4(row.rect_norm?.cx ?? 0),
      cy: round4(row.rect_norm?.cy ?? 0),
      relative_scale: round4(row.relative_scale_to_largest),
    };
  }

  const rowsByWeight = rows
    .slice()
    .sort((a, b) => Number(b.weight_hint || 0) - Number(a.weight_hint || 0));
  const tierById = new Map();
  for (let i = 0; i < rowsByWeight.length; i += 1) {
    const row = rowsByWeight[i];
    const weight = Number(row.weight_hint || 0);
    const tier = i === 0 ? "PRIMARY" : weight >= 0.25 ? "SECONDARY" : "ACCENT";
    tierById.set(row.id, tier);
  }

  const spatialRows = rows.filter((row) => row.rect_norm && typeof row.rect_norm === "object").slice(0, 8);
  const relations = [];
  const diagonalNorm = Math.sqrt(2);
  for (let i = 0; i < spatialRows.length; i += 1) {
    for (let j = i + 1; j < spatialRows.length; j += 1) {
      const a = spatialRows[i];
      const b = spatialRows[j];
      const ar = a.rect_norm || null;
      const br = b.rect_norm || null;
      if (!ar || !br) continue;
      const ax1 = Number(ar.x) || 0;
      const ay1 = Number(ar.y) || 0;
      const ax2 = ax1 + Math.max(0, Number(ar.w) || 0);
      const ay2 = ay1 + Math.max(0, Number(ar.h) || 0);
      const bx1 = Number(br.x) || 0;
      const by1 = Number(br.y) || 0;
      const bx2 = bx1 + Math.max(0, Number(br.w) || 0);
      const by2 = by1 + Math.max(0, Number(br.h) || 0);
      const acx = ax1 + (ax2 - ax1) / 2;
      const acy = ay1 + (ay2 - ay1) / 2;
      const bcx = bx1 + (bx2 - bx1) / 2;
      const bcy = by1 + (by2 - by1) / 2;
      const dx = bcx - acx;
      const dy = bcy - acy;
      const centerDistanceNorm = diagonalNorm > 0 ? Math.hypot(dx, dy) / diagonalNorm : 0;
      const gapX = Math.max(0, Math.max(ax1 - bx2, bx1 - ax2));
      const gapY = Math.max(0, Math.max(ay1 - by2, by1 - ay2));
      const edgeGapNorm = Math.hypot(gapX, gapY);
      const ix1 = Math.max(ax1, bx1);
      const iy1 = Math.max(ay1, by1);
      const ix2 = Math.min(ax2, bx2);
      const iy2 = Math.min(ay2, by2);
      const iw = Math.max(0, ix2 - ix1);
      const ih = Math.max(0, iy2 - iy1);
      const overlapArea = Math.max(0, iw * ih);
      const overlaps = overlapArea > 1e-8;
      const areaA = Math.max(0, (ax2 - ax1) * (ay2 - ay1));
      const areaB = Math.max(0, (bx2 - bx1) * (by2 - by1));
      const union = Math.max(0, areaA + areaB - overlapArea);
      const iou = union > 1e-8 ? overlapArea / union : 0;

      let confidence = 0;
      if (overlaps) {
        const overlapRatioA = areaA > 1e-8 ? overlapArea / areaA : 0;
        const overlapRatioB = areaB > 1e-8 ? overlapArea / areaB : 0;
        const areaNorm = overlapArea;
        const confIou = clamp01((iou - 0.03) / 0.12);
        const confArea = clamp01((areaNorm - 0.005) / 0.02);
        const confCov = clamp01((Math.max(overlapRatioA, overlapRatioB) - 0.25) / 0.5);
        confidence = Math.max(confIou, confArea, confCov);
      } else {
        confidence =
          clamp01((0.35 - Number(centerDistanceNorm || 0)) / 0.35) *
          clamp01((0.12 - Number(edgeGapNorm || 0)) / 0.12);
      }
      if (confidence < 0.55) continue;

      relations.push({
        id_a: a.id,
        id_b: b.id,
        slot_a: a.slot,
        slot_b: b.slot,
        relation: relationFromDelta(dx, dy, overlaps),
        confidence: round4(confidence),
        iou: round4(iou),
      });
    }
  }
  relations.sort((a, b) => Number(b.confidence || 0) - Number(a.confidence || 0));
  const relationLimit = rows.length <= 4 ? 4 : 6;

  const shotTypeHints = motherV2ShotTypeHints({
    preferredMode: preferredTransformationMode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE,
    candidateModes: transformationModeCandidates,
  });
  const overallConfidence = round4(clamp01(0.6 * interactionConfidence + 0.4 * geometryConfidence));
  return {
    schema: "brood.mother.proposal_context.v1",
    interaction_decay_tau_ms: INTERACTION_DECAY_TAU_MS,
    interaction_stale_cutoff_ms: INTERACTION_STALE_CUTOFF_MS,
    focus_rank: rows
      .slice()
      .sort((a, b) => Number(b.focus_score || 0) - Number(a.focus_score || 0))
      .map((row) => row.id)
      .slice(0, 8),
    interaction_confidence: round4(interactionConfidence),
    geometry_confidence: round4(geometryConfidence),
    overall_confidence: overallConfidence,
    images: rowsByWeight.slice(0, 8).map((row) => ({
      id: row.id,
      slot: row.slot,
      selected: row.selected,
      active: row.active,
      tier: tierById.get(row.id) || "ACCENT",
      weight_hint: round2(row.weight_hint),
      focus_score: round2(row.focus_score),
      geometry_score: round2(row.geometry_score),
      interaction_stale: row.interaction_stale,
      size_tier: row.size_tier,
      position_tier: row.position_tier,
      geometry_trace: row.geometry_trace,
    })),
    preferred_shot_type: shotTypeHints.primary_shot_type,
    alternate_shot_type: shotTypeHints.alternate_shot_type,
    preferred_lighting_profile: shotTypeHints.primary_lighting_profile,
    alternate_lighting_profile: shotTypeHints.alternate_lighting_profile,
    preferred_lens_guidance: shotTypeHints.primary_lens_guidance,
    alternate_lens_guidance: shotTypeHints.alternate_lens_guidance,
    shot_type_hints: shotTypeHints,
    relations: relations.slice(0, relationLimit),
  };
}

function motherV2IntentPayload() {
  const idle = state.motherIdle;
  const wrap = els.canvasWrap;
  const canvasCssW = Math.max(1, Number(wrap?.clientWidth) || 1);
  const canvasCssH = Math.max(1, Number(wrap?.clientHeight) || 1);
  const selectedIds = getVisibleSelectedIds().map((v) => String(v || "").trim()).filter(Boolean);
  const activeId = getVisibleActiveId();
  const ambientBranches = motherV2AmbientIntentHints(3);
  const ambientModeHints = motherV2AmbientTransformationModeHints();
  const preferredTransformationMode = motherV2PreferredTransformationModeHint();
  const canvasSummary = motherV2CanvasContextSummaryHint();
  const images = motherIdleBaseImageItems().map((item) => {
    const rect = state.freeformRects.get(item.id) || null;
    const rectTransform = readFreeformRectTransform(rect);
    const visionDesc = normalizeVisionHintForIntent(item?.visionDesc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS }) || "";
    return {
      id: String(item.id || ""),
      path: String(item.path || ""),
      file: basename(item.path || ""),
      vision_desc: visionDesc,
      rect: rect
        ? {
            x: Number(rect.x) || 0,
            y: Number(rect.y) || 0,
            w: Number(rect.w) || 0,
            h: Number(rect.h) || 0,
          }
        : null,
      rect_norm: rect
        ? {
            x: (Number(rect.x) || 0) / canvasCssW,
            y: (Number(rect.y) || 0) / canvasCssH,
            w: Math.max(0, Number(rect.w) || 0) / canvasCssW,
            h: Math.max(0, Number(rect.h) || 0) / canvasCssH,
          }
        : null,
      transform: rect
        ? {
            rotate_deg: rectTransform.rotateDeg,
            skew_x_deg: rectTransform.skewXDeg,
            user_resized: rect.autoAspect === false,
          }
        : null,
      };
  });
  const proposalModeCandidates = [
    ...(Array.isArray(idle?.intent?.transformation_mode_candidates) ? idle.intent.transformation_mode_candidates : []),
    ...(Array.isArray(ambientModeHints?.candidates) ? ambientModeHints.candidates : []),
  ];
  const proposalContext = motherV2BuildProposalContextForIntentPayload({
    images,
    selectedIds,
    activeId,
    preferredTransformationMode,
    transformationModeCandidates: proposalModeCandidates,
  });
  return {
    schema: "brood.mother.intent_infer.v1",
    action_version: Number(idle?.actionVersion) || 0,
    creative_directive: motherCurrentCreativeDirective(),
    creative_directive_instruction: motherCurrentCreativeDirectiveSentence(),
    preferred_transformation_mode: preferredTransformationMode,
    intensity: clamp(Number(idle?.intensity) || 62, 0, 100),
    active_id: activeId ? String(activeId) : null,
    selected_ids: selectedIds,
    canvas_context_summary: canvasSummary || null,
    ambient_intent: (ambientBranches.length || ambientModeHints.preferredMode)
      ? {
          source: "intent_rt",
          model: state.intentAmbient?.iconState ? realtimeProviderForScope("intent") : null,
          branches: ambientBranches,
          preferred_transformation_mode: ambientModeHints.preferredMode || null,
          transformation_mode_candidates: ambientModeHints.candidates,
        }
      : null,
    proposal_context: proposalContext,
    images,
  };
}

function motherV2BuildIntentRequestId(actionVersion = 0) {
  const stamp = Date.now().toString(36);
  const rand = Math.random().toString(16).slice(2, 8);
  return `mother-intent-a${Number(actionVersion) || 0}-${stamp}-${rand}`;
}

function motherV2ApplyIntent(
  intentPayload = {},
  { source = "local", sourceModel = null, preserveMode = false, requestId = null } = {}
) {
  const idle = state.motherIdle;
  if (!idle) return;
  if (idle.phase !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) return;
  const sourceTag = String(source || "local").trim();
  const sourceModelLabel = realtimeIntentModelLabel(sourceModel || intentPayload?._intent_source_model || "");
  const priorPendingRealtimePath = String(idle.pendingIntentRealtimePath || "").trim();
  const priorPendingIntentPath = String(idle.pendingIntentPath || "").trim();
  const priorRequestId = String(idle.pendingIntentRequestId || "").trim();
  const resolvedRequestId = String(requestId || priorRequestId || "").trim() || null;
  const wasPendingIntent = Boolean(idle.pendingIntent);
  const sourceKind = motherV2IntentSourceKind(sourceTag);
  let normalizedIntent =
    intentPayload && typeof intentPayload === "object"
      ? {
          ...intentPayload,
          creative_directive: String(intentPayload.creative_directive || "").trim() || motherCurrentCreativeDirective(),
          transformation_mode: motherV2NormalizeTransformationMode(intentPayload.transformation_mode),
          _intent_request_id: resolvedRequestId,
          _intent_source_kind: sourceKind || null,
          _intent_source_model: sourceModelLabel || null,
        }
      : null;
  normalizedIntent = motherV2DiversifyIntentForRejectFollowup(normalizedIntent);
  normalizedIntent = motherV2SanitizeIntentImageIds(normalizedIntent);
  normalizedIntent = motherV2EnsureProposalCandidates(normalizedIntent);
  idle.promptMotionProfile = null;
  if (preserveMode && normalizedIntent && idle.intent && typeof idle.intent === "object") {
    const priorMode = motherV2MaybeTransformationMode(idle.intent.transformation_mode);
    const nextModes = motherV2ProposalModes(normalizedIntent);
    if (priorMode && nextModes.includes(priorMode)) {
      normalizedIntent.transformation_mode = priorMode;
      normalizedIntent.summary = motherV2ProposalSentence({
        ...normalizedIntent,
        transformation_mode: priorMode,
      });
    }
  }
  idle.intent = normalizedIntent;
  motherV2ClearLiveProposalRefreshTimer();
  idle.liveProposalUpdating = false;
  if (Array.isArray(idle.drafts) && idle.drafts.length) {
    for (const draft of idle.drafts) {
      if (draft?.path) removeFile(String(draft.path)).catch(() => {});
      if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
    }
    idle.drafts = [];
    idle.selectedDraftId = null;
    idle.hoverDraftId = null;
  }
  idle.speculativePrefetchReadyMode = null;
  motherV2NormalizeRoles(normalizedIntent?.roles || null);
  idle.pendingIntent = false;
  motherV2ClearIntentRealtimeBusy({
    path: priorPendingRealtimePath,
    requestId: resolvedRequestId,
    reason: "intent_applied",
  });
  const canUpgradeFromLateRealtime = sourceKind !== "realtime" && priorPendingRealtimePath;
  idle.pendingIntentRealtimePath = canUpgradeFromLateRealtime ? priorPendingRealtimePath : null;
  idle.pendingIntentRequestId = canUpgradeFromLateRealtime ? (resolvedRequestId || priorRequestId || null) : null;
  idle.pendingIntentTransportRetryCount = canUpgradeFromLateRealtime
    ? (Number(idle.pendingIntentTransportRetryCount) || 0)
    : 0;
  idle.pendingIntentStartedAt = canUpgradeFromLateRealtime ? (Number(idle.pendingIntentStartedAt) || Date.now()) : 0;
  idle.pendingIntentUpgradeUntil = canUpgradeFromLateRealtime ? Date.now() + MOTHER_V2_INTENT_LATE_REALTIME_UPGRADE_MS : 0;
  idle.pendingIntentPayload = null;
  // Mother proposals are realtime-only; ignore heuristic intent payload upgrades.
  idle.pendingIntentPath = null;
  clearTimeout(idle.pendingIntentTimeout);
  idle.pendingIntentTimeout = null;
  idle.pendingVisionImageIds = [];
  clearTimeout(idle.pendingVisionRetryTimer);
  idle.pendingVisionRetryTimer = null;
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.INTENT_INFERRED);
  appendMotherTraceLog({
    kind: "intent_inferred",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    source,
    source_kind: sourceKind || null,
    request_id: resolvedRequestId,
    late_realtime_upgrade: Boolean(sourceKind === "realtime" && !wasPendingIntent),
    intent_id: intentPayload?.intent_id || null,
    placement_policy: intentPayload?.placement_policy || null,
    confidence: Number(intentPayload?.confidence) || 0,
    optimization_target: motherCurrentOptimizationTarget(),
    proposal_mode: motherV2NormalizeTransformationMode(normalizedIntent?.transformation_mode),
    proposal_candidates: motherV2ProposalCandidateSummary(normalizedIntent, { limit: MOTHER_V2_MAX_RANKED_PROPOSALS }),
    target_ids: motherV2NormalizeImageIdList(normalizedIntent?.target_ids || []).slice(0, 6),
    reference_ids: motherV2NormalizeImageIdList(normalizedIntent?.reference_ids || []).slice(0, 6),
  }).catch(() => {});
  renderMotherReadout();
  requestRender();
}

function motherV2ArmRealtimeIntentTimeout({ timeoutMs = MOTHER_V2_INTENT_RT_TIMEOUT_MS } = {}) {
  const idle = state.motherIdle;
  if (!idle || !idle.pendingIntent) return;
  const actionVersion = Number(idle.actionVersion) || 0;
  const pendingActionVersion = Number(idle.pendingActionVersion) || 0;
  if (!actionVersion || actionVersion !== pendingActionVersion) return;
  const requestId = String(idle.pendingIntentRequestId || "").trim() || null;
  const ms = Math.max(1_000, Number(timeoutMs) || MOTHER_V2_INTENT_RT_TIMEOUT_MS);

  clearTimeout(idle.pendingIntentTimeout);
  idle.pendingIntentTimeout = setTimeout(() => {
    const resolveActiveTimeoutRequest = () => {
      const latest = state.motherIdle;
      if (!latest || !latest.pendingIntent) return null;
      if ((Number(latest.actionVersion) || 0) !== actionVersion) return null;
      if ((Number(latest.pendingActionVersion) || 0) !== pendingActionVersion) return null;
      const latestRequestId = String(latest.pendingIntentRequestId || "").trim() || null;
      if (requestId && latestRequestId !== requestId) return null;
      return latest;
    };
    const emitTimeoutFailure = (activeIdle) => {
      if (!activeIdle) return;
      const activePath = String(activeIdle.pendingIntentRealtimePath || "").trim();
      appendMotherTraceLog({
        kind: "intent_realtime_failed",
        traceId: activeIdle.telemetry?.traceId || null,
        actionVersion,
        request_id: requestId,
        source: "intent_rt_timeout",
        error: message,
      }).catch(() => {});
      motherV2ClearIntentRealtimeBusy({
        path: activePath,
        requestId,
        force: true,
        reason: "intent_timeout",
      });
      motherIdleHandleGenerationFailed(message);
    };
    const current = resolveActiveTimeoutRequest();
    if (!current) return;
    const timeoutSec = Math.max(1, Math.round(ms / 1000));
    const message = `Mother realtime intent timed out after ${timeoutSec}s.`;
    const snapshotPath = String(current.pendingIntentRealtimePath || "").trim();
    const retryCount = Math.max(0, Number(current.pendingIntentTransportRetryCount) || 0);
    const startedAt = Number(current.pendingIntentStartedAt) || 0;
    const elapsedMs = startedAt > 0 ? Math.max(0, Date.now() - startedAt) : ms;
    const workerTimeoutMs = Math.max(ms, MOTHER_V2_INTENT_RT_WORKER_TIMEOUT_MS);
    if (
      snapshotPath &&
      retryCount < MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX &&
      elapsedMs + MOTHER_V2_INTENT_RT_TIMEOUT_DEFER_GRACE_MS < workerTimeoutMs
    ) {
      const deferMs = Math.max(
        1_000,
        Math.ceil(workerTimeoutMs - elapsedMs + MOTHER_V2_INTENT_RT_TIMEOUT_DEFER_GRACE_MS)
      );
      appendMotherTraceLog({
        kind: "intent_realtime_retry_deferred",
        traceId: current.telemetry?.traceId || null,
        actionVersion,
        request_id: requestId,
        retry_count: retryCount,
        max_retries: MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX,
        elapsed_ms: Math.round(elapsedMs),
        worker_timeout_ms: workerTimeoutMs,
        wait_ms: deferMs,
        reason: "awaiting_worker_timeout",
      }).catch(() => {});
      motherV2ArmRealtimeIntentTimeout({ timeoutMs: deferMs });
      return;
    }
    if (snapshotPath && retryCount < MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX) {
      motherV2RetryRealtimeIntentTransport({ path: snapshotPath, errorMessage: message })
        .then((retried) => {
          if (!retried) {
            const latest = resolveActiveTimeoutRequest();
            if (!latest) return;
            appendMotherTraceLog({
              kind: "intent_realtime_retry_exhausted",
              traceId: latest.telemetry?.traceId || null,
              actionVersion,
              request_id: requestId,
              retry_count: Number(latest.pendingIntentTransportRetryCount) || 0,
              max_retries: MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX,
              reason: "timeout_retry_dispatch_failed",
              error: message,
            }).catch(() => {});
            emitTimeoutFailure(latest);
          }
        })
        .catch(() => {
          const latest = resolveActiveTimeoutRequest();
          emitTimeoutFailure(latest);
        });
      return;
    }
    emitTimeoutFailure(current);
  }, ms);
}

async function motherV2RetryRealtimeIntentTransport({ path = "", errorMessage = null } = {}) {
  const idle = state.motherIdle;
  const snapshotPath = String(path || "").trim();
  if (!idle || !snapshotPath) return false;
  if (!idle.pendingIntent) return false;
  if (String(idle.phase || "") !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) return false;
  const actionVersion = Number(idle.actionVersion) || 0;
  const pendingActionVersion = Number(idle.pendingActionVersion) || 0;
  if (!actionVersion || actionVersion !== pendingActionVersion) return false;
  const retryCount = Math.max(0, Number(idle.pendingIntentTransportRetryCount) || 0);
  if (retryCount >= MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX) return false;

  const nextRetry = retryCount + 1;
  const requestId = motherV2BuildIntentRequestId(actionVersion);
  idle.pendingIntentTransportRetryCount = nextRetry;
  idle.pendingIntentRequestId = requestId;
  idle.pendingIntentStartedAt = Date.now();
  idle.pendingIntentUpgradeUntil = 0;
  idle.pendingIntentRealtimePath = snapshotPath;
  clearTimeout(idle.pendingIntentTimeout);
  idle.pendingIntentTimeout = null;

  appendMotherTraceLog({
    kind: "intent_realtime_retrying",
    traceId: idle.telemetry?.traceId || null,
    actionVersion,
    request_id: requestId,
    retry_count: nextRetry,
    max_retries: MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX,
    snapshot_path: snapshotPath,
    error: errorMessage ? String(errorMessage) : null,
  }).catch(() => {});

  const delayMs = Math.max(0, MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_DELAY_MS * nextRetry);
  if (delayMs > 0) await new Promise((resolve) => setTimeout(resolve, delayMs));

  const current = state.motherIdle;
  if (!current || !current.pendingIntent) return false;
  if ((Number(current.actionVersion) || 0) !== actionVersion) return false;
  if ((Number(current.pendingActionVersion) || 0) !== actionVersion) return false;
  if (String(current.pendingIntentRequestId || "") !== requestId) return false;
  if (!state.ptySpawned) return false;

  await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_MOTHER_START}\n` }).catch(() => {});
  const dispatched = await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_MOTHER} ${quoteForPtyArg(snapshotPath)}\n` })
    .then(() => true)
    .catch(() => false);
  if (!dispatched) return false;
  motherV2SetIntentRealtimeBusy({ path: snapshotPath, requestId });

  appendMotherTraceLog({
    kind: "intent_realtime_retry_dispatched",
    traceId: current.telemetry?.traceId || null,
    actionVersion,
    request_id: requestId,
    retry_count: nextRetry,
    snapshot_path: snapshotPath,
  }).catch(() => {});
  motherV2ArmRealtimeIntentTimeout({ timeoutMs: MOTHER_V2_INTENT_RT_TIMEOUT_MS });
  return true;
}

async function motherV2RequestIntentInference({
  snapshotLoadTimeoutMs = INTENT_SNAPSHOT_FAST_LOAD_TIMEOUT_MS,
  snapshotMaxDimPx = INTENT_SNAPSHOT_MAX_DIM_PX,
  scheduleVisionLabels = true,
  fastUploadPath = false,
} = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  if (motherV2IntentRealtimeBusy()) {
    motherV2QueueIntentReplay("intent_realtime_inflight");
    return false;
  }
  if (idle.pendingIntent || idle.pendingPromptCompile || idle.pendingGeneration) {
    if (idle.pendingIntent && String(idle.phase || "") === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
      motherV2QueueIntentReplay("intent_pending");
    }
    return false;
  }
  if (!motherIdleHasArmedCanvas()) return false;
  if (motherV2InCooldown()) return false;
  const visionGate = motherV2VisionReadyForIntent({ schedule: Boolean(scheduleVisionLabels) });
  idle.pendingVisionImageIds = visionGate.ready ? [] : visionGate.missingIds.slice();
  clearTimeout(idle.pendingVisionRetryTimer);
  idle.pendingVisionRetryTimer = null;
  const actionVersion = Number(idle.actionVersion) || 0;
  const requestId = motherV2BuildIntentRequestId(actionVersion);
  const requestMatchesCurrent = (current, { requirePending = true } = {}) => {
    if (!current) return false;
    if (requirePending && !current.pendingIntent) return false;
    if ((Number(current.pendingActionVersion) || 0) !== actionVersion) return false;
    if ((Number(current.actionVersion) || 0) !== actionVersion) return false;
    return String(current.pendingIntentRequestId || "") === requestId;
  };
  const clearOwnedPendingRequest = (current) => {
    if (!current) return;
    if (String(current.pendingIntentRequestId || "") !== requestId) return;
    current.pendingIntent = false;
    current.pendingIntentRequestId = null;
    current.pendingIntentTransportRetryCount = 0;
    current.pendingIntentStartedAt = 0;
    current.pendingIntentUpgradeUntil = 0;
    current.pendingIntentRealtimePath = null;
    current.pendingIntentPath = null;
    current.pendingIntentPayload = null;
    clearTimeout(current.pendingIntentTimeout);
    current.pendingIntentTimeout = null;
  };
  await ensureRun();
  const payload = motherV2IntentPayload();
  const payloadPath = await motherV2WritePayloadFile("mother_intent_infer", payload);
  const ok = await ensureEngineSpawned({ reason: "mother_intent_rt" });
  if (!ok) return false;
  const uploadFastPath = Boolean(fastUploadPath);

  const failRealtimeIntent = ({ sourceTag = "intent_rt_failed", message = null } = {}) => {
    const current = state.motherIdle;
    if (!requestMatchesCurrent(current, { requirePending: true })) {
      clearOwnedPendingRequest(current);
      return;
    }
    const failureMessage = String(message || "Mother realtime intent inference failed.").trim();
    appendMotherTraceLog({
      kind: "intent_realtime_failed",
      traceId: current.telemetry?.traceId || null,
      actionVersion,
      request_id: requestId,
      source: String(sourceTag || "intent_rt_failed"),
      error: failureMessage,
    }).catch(() => {});
    motherIdleHandleGenerationFailed(failureMessage);
  };

  let snapshotPath = null;
  if (state.runDir) {
    const stamp = Date.now();
    const suffix = `${stamp}-a${String(actionVersion).padStart(2, "0")}`;
    snapshotPath = `${state.runDir}/mother-intent-${suffix}.png`;
    const frameId = `mother-intent-a${actionVersion}-${suffix}`;
    try {
      if (!uploadFastPath) {
        await waitForIntentImagesLoaded({
          timeoutMs: Math.max(0, Number(snapshotLoadTimeoutMs) || 0),
          maxImages: MOTHER_V2_INTENT_TARGET_IMAGE_LIMIT,
        });
      }
      render();
      await writeIntentSnapshot(snapshotPath, {
        maxDimPx: Math.max(420, Number(snapshotMaxDimPx) || INTENT_SNAPSHOT_MAX_DIM_PX),
      });
      if (!uploadFastPath) {
        const ctxResult = await motherV2WriteIntentContextEnvelopeWithRefRetry(
          snapshotPath,
          frameId,
          payload,
          { requestId, actionVersion }
        );
        if (!ctxResult.ok) {
          appendMotherTraceLog({
            kind: "intent_request_context_refs_soft_missing",
            traceId: idle.telemetry?.traceId || null,
            actionVersion,
            request_id: requestId,
            snapshot_path: snapshotPath || null,
            required_refs: ctxResult.requiredRefs,
            available_refs: ctxResult.availableRefs,
          }).catch(() => {});
        }
      }
    } catch {
      snapshotPath = null;
    }
  }

  if (
    !state.motherIdle ||
    state.motherIdle !== idle ||
    (Number(idle.actionVersion) || 0) !== actionVersion ||
    idle.phase !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING ||
    state.pointer.active
  ) {
    return false;
  }

  idle.pendingIntent = true;
  idle.pendingIntentRequestId = requestId;
  idle.pendingIntentTransportRetryCount = 0;
  idle.pendingIntentStartedAt = Date.now();
  idle.pendingIntentUpgradeUntil = 0;
  idle.pendingActionVersion = actionVersion;
  idle.pendingIntentRealtimePath = snapshotPath;
  idle.pendingIntentPath = null;
  idle.pendingIntentPayload = payload;
  clearTimeout(idle.pendingIntentTimeout);
  idle.pendingIntentTimeout = null;
  appendMotherTraceLog({
    kind: "intent_request_started",
    traceId: idle.telemetry?.traceId || null,
    actionVersion,
    request_id: requestId,
    payload_path: payloadPath || null,
    snapshot_path: snapshotPath || null,
  }).catch(() => {});
  setStatus("Mother: hypothesizing intent (realtime)â€¦");
  renderMotherReadout();

  let realtimeDispatched = false;
  if (snapshotPath) {
    await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_MOTHER_START}\n` }).catch(() => {});
    realtimeDispatched = await invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_MOTHER} ${quoteForPtyArg(snapshotPath)}\n` })
      .then(() => true)
      .catch(() => false);
  }

  if (realtimeDispatched) {
    motherV2SetIntentRealtimeBusy({ path: snapshotPath, requestId });
    motherV2ArmRealtimeIntentTimeout({ timeoutMs: MOTHER_V2_INTENT_RT_TIMEOUT_MS });
  } else {
    failRealtimeIntent({
      sourceTag: snapshotPath ? "intent_rt_dispatch_failed" : "intent_rt_snapshot_unavailable",
      message: snapshotPath
        ? "Mother realtime intent dispatch failed."
        : "Mother realtime intent snapshot unavailable.",
    });
    return false;
  }
  return true;
}

async function motherV2RequestPromptCompile({ speculative = false } = {}) {
  const idle = state.motherIdle;
  if (!idle || !idle.intent) return null;
  const sanitizedIntent = motherV2SanitizeIntentImageIds(idle.intent) || idle.intent;
  const activeId = getVisibleActiveId();
  const selectedIds = getVisibleSelectedIds().map((v) => String(v || "").trim()).filter(Boolean);
  const payload = {
    schema: "brood.mother.prompt_compile.v1",
    action_version: Number(idle.actionVersion) || 0,
    intent: sanitizedIntent,
    roles: motherV2RoleMapClone(),
    creative_directive: String(sanitizedIntent?.creative_directive || "").trim() || motherCurrentCreativeDirective(),
    transformation_mode: motherV2NormalizeTransformationMode(sanitizedIntent?.transformation_mode),
    intensity: clamp(Number(idle.intensity) || 62, 0, 100),
    active_id: activeId ? String(activeId) : null,
    selected_ids: selectedIds,
    images: motherIdleBaseImageItems().map((item) => ({
      id: String(item.id || ""),
      file: basename(item.path || ""),
      vision_desc: normalizeVisionHintForIntent(item?.visionDesc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS }) || "",
    })),
  };
  const payloadPath = await motherV2WritePayloadFile("mother_prompt_compile", payload);
  idle.pendingPromptCompile = true;
  idle.pendingPromptCompileSpeculative = Boolean(speculative);
  idle.pendingPromptCompilePath = payloadPath;
  idle.pendingActionVersion = Number(idle.actionVersion) || 0;
  clearTimeout(idle.pendingPromptCompileTimeout);
  idle.pendingPromptCompileTimeout = setTimeout(() => {
    if (!state.motherIdle?.pendingPromptCompile) return;
    if (Number(state.motherIdle.pendingActionVersion) !== Number(state.motherIdle.actionVersion)) {
      state.motherIdle.pendingPromptCompile = false;
      state.motherIdle.pendingPromptCompileSpeculative = false;
      return;
    }
    const compiled = motherV2CompilePromptLocal(payload);
    motherV2DispatchCompiledPrompt(compiled).catch(() => {});
  }, MOTHER_V2_PROMPT_COMPILE_FALLBACK_MS);

  if (payloadPath) {
    await invoke("write_pty", { data: `${PTY_COMMANDS.PROMPT_COMPILE} ${quoteForPtyArg(payloadPath)}\n` }).catch(() => {});
  } else {
    const compiled = motherV2CompilePromptLocal(payload);
    await motherV2DispatchCompiledPrompt(compiled);
  }
  return payloadPath;
}

function motherV2SplitConstraints(raw = "") {
  return String(raw || "")
    .split(/\n|;|,/g)
    .map((entry) => String(entry || "").trim())
    .filter(Boolean)
    .map((entry) => entry.replace(/^[-*â€¢]\s*/, "").replace(/\s+/g, " ").trim())
    .filter(Boolean);
}

function motherV2ExtractPromptConstraints(compiled = {}) {
  const constraints = [];
  const seen = new Set();
  const push = (raw) => {
    const text = String(raw || "").trim().replace(/\s+/g, " ");
    if (!text) return;
    const key = text.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);
    constraints.push(text);
  };
  for (const item of Array.isArray(compiled?.compile_constraints) ? compiled.compile_constraints : []) {
    push(item);
  }
  const negative = String(compiled?.negative_prompt || "").trim();
  if (negative) {
    for (const item of motherV2SplitConstraints(negative)) push(item);
  }
  return constraints;
}

function motherV2BuildPromptComposerResult(compiled = {}) {
  const currentDirective = motherCurrentCreativeDirective();
  let positive = String(compiled?.positive_prompt || "").trim();
  if (positive && !positive.toLowerCase().includes(currentDirective.toLowerCase())) {
    positive = `Create one ${currentDirective} image. ${positive}`.trim();
  }
  const negative = String(compiled?.negative_prompt || "").trim();
  const constraints = motherV2ExtractPromptConstraints(compiled).slice(0, 8);
  const configuredMode = normalizePromptStrategyMode(settings.promptStrategyMode);
  const resolvedAuto =
    configuredMode === "auto"
      ? promptBenchmarkAutoStrategyForModel(state.motherIdle?.lastDispatchModel || settings.imageModel, { fallback: "tail" })
      : null;
  const strategyMode = configuredMode === "auto" ? resolvedAuto?.strategy || "tail" : configuredMode;
  const repeatFull = Boolean(settings.promptRepeatFull);
  const lines = [];
  if (positive) lines.push(positive);
  if (negative) lines.push(`Avoid: ${negative}`);
  if (strategyMode === "tail" && constraints.length) {
    lines.push(`MUST: ${constraints.join("; ")}`);
  }
  let rawPrompt = lines.join("\n");
  if (repeatFull && rawPrompt) {
    rawPrompt = `${rawPrompt}\n${rawPrompt}`;
  }
  const line = motherIdlePromptLineForPty(rawPrompt);
  return {
    line,
    strategy: repeatFull ? "repeat" : strategyMode,
    promptChars: line.length,
    constraintCount: constraints.length,
  };
}

function motherV2PromptLineFromCompiled(compiled = {}) {
  return motherV2BuildPromptComposerResult(compiled).line;
}

function motherV2CollectGenerationImagePaths() {
  const idle = state.motherIdle;
  const intent = idle?.intent && typeof idle.intent === "object" ? idle.intent : {};
  const ids = [];
  const push = (raw) => {
    const id = String(raw || "").trim();
    if (!id) return;
    if (!isVisibleCanvasImageId(id)) return;
    if (ids.includes(id)) return;
    ids.push(id);
  };
  const pushMany = (list) => {
    for (const value of Array.isArray(list) ? list : []) push(value);
  };
  const selectedIds = getVisibleSelectedIds().map((v) => String(v || "").trim()).filter(Boolean);
  const activeId = String(getVisibleActiveId() || "").trim();
  const preferredPairIds = (() => {
    const visibleItems = getVisibleCanvasImages();
    if (!visibleItems.length) return [];
    const byId = new Map(
      visibleItems
        .map((item) => [String(item?.id || "").trim(), item])
        .filter(([id]) => Boolean(id))
    );
    const findLatestId = (predicate) => {
      for (let i = (state.images?.length || 0) - 1; i >= 0; i -= 1) {
        const item = state.images[i];
        const id = String(item?.id || "").trim();
        if (!id) continue;
        const visible = byId.get(id);
        if (!visible) continue;
        if (predicate(visible)) return id;
      }
      return "";
    };
    const latestMotherId = findLatestId((item) => isMotherGeneratedImageItem(item));
    const latestUploadId = findLatestId((item) => !isMotherGeneratedImageItem(item));
    if (!latestMotherId || !latestUploadId || latestMotherId === latestUploadId) return [];

    const firstSelectedId = selectedIds[0] || activeId || "";
    if (firstSelectedId) {
      const firstItem = byId.get(firstSelectedId) || null;
      if (firstItem) {
        if (isMotherGeneratedImageItem(firstItem)) return [firstSelectedId, latestUploadId];
        return [firstSelectedId, latestMotherId];
      }
    }
    return [latestUploadId, latestMotherId];
  })();

  // Keep the active image first so proposal drafts behave like controlled edits of the active anchor.
  push(activeId);
  // Then include user-selected/supporting references.
  pushMany(selectedIds);
  pushMany(preferredPairIds);

  const roles = motherV2RoleMapClone();
  pushMany(roles.subject);
  pushMany(roles.model);
  pushMany(roles.mediator);
  pushMany(roles.object);
  pushMany(intent.target_ids);
  pushMany(intent.reference_ids);
  // Always include full canvas context so follow-ups can evolve beyond a small role subset.
  pushMany(motherIdleBaseImageItems().map((item) => String(item?.id || "").trim()));
  if (!ids.length) push(getVisibleActiveId());

  const records = [];
  for (const imageId of ids) {
    const item = state.imagesById.get(imageId) || null;
    if (!item?.path) continue;
    const path = String(item.path || "").trim();
    if (!path) continue;
    if (records.some((entry) => entry.path === path)) continue;
    const rect = state.freeformRects.get(imageId) || null;
    const transform = readFreeformRectTransform(rect);
    records.push({
      id: imageId,
      path,
      rect: rect
        ? {
            w: Math.max(1, Number(rect.w) || 1),
            h: Math.max(1, Number(rect.h) || 1),
            autoAspect: rect.autoAspect !== false,
          }
        : null,
      transform: {
        rotateDeg: transform.rotateDeg,
        skewXDeg: transform.skewXDeg,
      },
    });
  }
  const paths = records.map((entry) => entry.path);

  const initImage = paths[0] || null;
  const referenceImages = paths.slice(1);
  return {
    sourceImageIds: ids.slice(),
    sourceRecords: records,
    sourceImagesOriginal: paths.slice(),
    sourceImages: paths,
    initImage,
    referenceImages,
  };
}

function motherV2GenerationImageTransformSignature(record = null) {
  const imageId = String(record?.id || "").trim();
  const path = String(record?.path || "").trim();
  if (!imageId || !path) return "";
  const transform = record?.transform && typeof record.transform === "object" ? record.transform : {};
  const rect = record?.rect && typeof record.rect === "object" ? record.rect : {};
  const rotateDeg = normalizeFreeformRotateDeg(transform.rotateDeg);
  const skewXDeg = normalizeFreeformSkewDeg(transform.skewXDeg);
  const w = Math.max(1, Math.round(Number(rect.w) || 1));
  const h = Math.max(1, Math.round(Number(rect.h) || 1));
  const resized = rect.autoAspect === false ? 1 : 0;
  return `${imageId}|${path}|w${w}|h${h}|r${rotateDeg.toFixed(2)}|s${skewXDeg.toFixed(2)}|z${resized}`;
}

function motherV2ShouldExportGenerationImageTransform(record = null) {
  if (!record || typeof record !== "object") return false;
  const rotateDeg = normalizeFreeformRotateDeg(record?.transform?.rotateDeg);
  const skewXDeg = normalizeFreeformSkewDeg(record?.transform?.skewXDeg);
  const userResized = record?.rect?.autoAspect === false;
  if (userResized) return true;
  return Math.abs(rotateDeg) > 0.2 || Math.abs(skewXDeg) > 0.2;
}

function motherV2GenerationImageDispatchSize(record = null, img = null) {
  const rectW = Math.max(1, Number(record?.rect?.w) || Number(img?.naturalWidth) || Number(img?.width) || 1);
  const rectH = Math.max(1, Number(record?.rect?.h) || Number(img?.naturalHeight) || Number(img?.height) || 1);
  const aspect = rectW / Math.max(1, rectH);
  const targetLong = clamp(
    Math.round(Math.max(rectW, rectH) * 2),
    MOTHER_V2_DISPATCH_TRANSFORM_EXPORT_MIN_DIM_PX,
    MOTHER_V2_DISPATCH_TRANSFORM_EXPORT_MAX_DIM_PX
  );
  let baseW = aspect >= 1 ? targetLong : Math.round(targetLong * aspect);
  let baseH = aspect >= 1 ? Math.round(targetLong / Math.max(0.0001, aspect)) : targetLong;
  baseW = Math.max(1, Math.round(baseW));
  baseH = Math.max(1, Math.round(baseH));
  return { baseW, baseH };
}

async function motherV2ExportGenerationImageTransform(record = null) {
  if (!state.runDir || !record?.path || !record?.id) return null;
  if (!motherV2ShouldExportGenerationImageTransform(record)) return null;
  const signature = motherV2GenerationImageTransformSignature(record);
  if (!signature) return null;

  const cachedPath = String(motherDispatchTransformExportCache.get(signature) || "").trim();
  if (cachedPath && (await exists(cachedPath).catch(() => false))) return cachedPath;

  const cacheKey = Math.abs(hash32(signature)).toString(16);
  const outPath = `${state.runDir}/mother-src-${cacheKey}.png`;
  if (await exists(outPath).catch(() => false)) {
    motherDispatchTransformExportCache.set(signature, outPath);
    return outPath;
  }

  const imageId = String(record.id || "").trim();
  const item = state.imagesById.get(imageId) || null;
  let img = item?.img || null;
  if (!img) {
    img = await loadImage(record.path).catch(() => null);
  }
  if (!img) return null;
  const transform = readFreeformRectTransform(record.transform || null);
  const { baseW, baseH } = motherV2GenerationImageDispatchSize(record, img);
  const points = transformedRectPolygonPoints({
    x: 0,
    y: 0,
    w: baseW,
    h: baseH,
    rotateDeg: transform.rotateDeg,
    skewXDeg: transform.skewXDeg,
  });
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (const pt of points) {
    minX = Math.min(minX, Number(pt?.x) || 0);
    minY = Math.min(minY, Number(pt?.y) || 0);
    maxX = Math.max(maxX, Number(pt?.x) || 0);
    maxY = Math.max(maxY, Number(pt?.y) || 0);
  }
  const outW = Math.max(1, Math.min(4096, Math.ceil(maxX - minX)));
  const outH = Math.max(1, Math.min(4096, Math.ceil(maxY - minY)));
  const canvas = document.createElement("canvas");
  canvas.width = outW;
  canvas.height = outH;
  const ctx = canvas.getContext("2d");
  if (!ctx) return null;
  ctx.clearRect(0, 0, outW, outH);
  drawImageRectWithTransform(ctx, img, {
    x: -minX,
    y: -minY,
    w: baseW,
    h: baseH,
    rotateDeg: transform.rotateDeg,
    skewXDeg: transform.skewXDeg,
  });
  await writeCanvasPngToPath(canvas, outPath);
  motherDispatchTransformExportCache.set(signature, outPath);
  if (motherDispatchTransformExportCache.size > 96) {
    const oldestKey = motherDispatchTransformExportCache.keys().next().value;
    if (oldestKey) motherDispatchTransformExportCache.delete(oldestKey);
  }
  return outPath;
}

async function motherV2ResolveGenerationImagePayload(imagePayload = null) {
  const payload = imagePayload && typeof imagePayload === "object" ? imagePayload : {};
  const records = Array.isArray(payload.sourceRecords) ? payload.sourceRecords : [];
  if (!records.length) return payload;

  const manifest = [];
  const resolvedPaths = [];
  for (let i = 0; i < records.length; i += 1) {
    const record = records[i];
    const sourcePath = String(record?.path || "").trim();
    if (!sourcePath) continue;
    const rotateDeg = normalizeFreeformRotateDeg(record?.transform?.rotateDeg);
    const skewXDeg = normalizeFreeformSkewDeg(record?.transform?.skewXDeg);
    const userResized = record?.rect?.autoAspect === false;
    const canTransform = i < MOTHER_V2_DISPATCH_TRANSFORM_EXPORT_LIMIT;
    let dispatchPath = sourcePath;
    let transformed = false;
    if (canTransform) {
      const exportedPath = await motherV2ExportGenerationImageTransform(record).catch(() => null);
      if (exportedPath) {
        dispatchPath = exportedPath;
        transformed = true;
      }
    }
    manifest.push({
      id: String(record?.id || "").trim() || null,
      source_path: sourcePath,
      dispatch_path: dispatchPath,
      transformed,
      rotate_deg: rotateDeg,
      skew_x_deg: skewXDeg,
      user_resized: userResized,
      canvas_rect:
        record?.rect && typeof record.rect === "object"
          ? {
              w: Math.max(1, Math.round(Number(record.rect.w) || 1)),
              h: Math.max(1, Math.round(Number(record.rect.h) || 1)),
            }
          : null,
    });
    if (!resolvedPaths.includes(dispatchPath)) resolvedPaths.push(dispatchPath);
  }
  return {
    ...payload,
    sourceImagesOriginal: Array.isArray(payload.sourceImagesOriginal) ? payload.sourceImagesOriginal.slice() : [],
    sourceImages: resolvedPaths,
    initImage: resolvedPaths[0] || null,
    referenceImages: resolvedPaths.slice(1),
    dispatchImageManifest: manifest,
  };
}

function motherV2BuildOperationSpec({ intent = null, imagePayload = null, actionVersion = 0, triggerSource = "auto" } = {}) {
  const parsedIntent = intent && typeof intent === "object" ? intent : {};
  const sourceImageIds = motherV2NormalizeImageIdList(imagePayload?.sourceImageIds || []).slice(0, 10);
  const targetIds = motherV2NormalizeImageIdList(parsedIntent.target_ids || []);
  const referenceIds = motherV2NormalizeImageIdList(parsedIntent.reference_ids || []);
  const activeId = String(getVisibleActiveId() || "").trim();
  const targetId = activeId || targetIds[0] || sourceImageIds[0] || null;
  if (!targetId) return null;
  const refs = [];
  const refSet = new Set([targetId]);
  const pushRef = (raw) => {
    const id = String(raw || "").trim();
    if (!id || refSet.has(id)) return;
    refSet.add(id);
    refs.push(id);
  };
  for (const id of referenceIds) pushRef(id);
  for (const id of sourceImageIds) pushRef(id);
  const mode = motherV2NormalizeTransformationMode(parsedIntent.transformation_mode);
  const opType = MOTHER_V2_OPERATION_TYPE_BY_MODE[mode] || mode;
  const actionVersionNum = Math.max(0, Math.trunc(Number(actionVersion) || 0));
  const opId = [
    "op",
    String(parsedIntent.intent_id || "mother"),
    String(actionVersionNum),
    Date.now().toString(36),
  ].join("-");
  return {
    op_id: opId,
    op_type: String(opType || mode || "operation"),
    target_id: targetId,
    reference_ids: refs.slice(0, 8),
    dna_token_id: null,
    mode,
    trigger_source: String(triggerSource || "auto") === "user" ? "user" : "auto",
  };
}

function motherV2InferOperationTriggerSource(nowMs = Date.now()) {
  const events =
    Array.isArray(state.userTelemetryEvents) && state.userTelemetryEvents.length
      ? state.userTelemetryEvents
      : Array.isArray(state.userEvents)
      ? state.userEvents
      : [];
  const isUserAuthoredTrigger = (entry, type) => {
    const actor = String(entry?.actor || "").trim().toLowerCase();
    if (actor && actor !== "user") return false;
    if (type === "dna_apply" || type === "dna_extract") {
      const phase = String(entry?.phase || "").trim().toLowerCase();
      // Only request-phase DNA interactions should imply user-triggered operations.
      if (phase && phase !== "request") return false;
    }
    return true;
  };
  for (let idx = events.length - 1; idx >= 0; idx -= 1) {
    const entry = events[idx];
    if (!entry || typeof entry !== "object") continue;
    const atMs = Number(entry.at_ms) || 0;
    if (atMs > 0 && nowMs - atMs > 3000) break;
    const type = String(entry.type || "").trim();
    if (!type) continue;
    if (type === "mother_accept" || type === "action_grid_press" || type === "dna_apply" || type === "dna_extract") {
      if (!isUserAuthoredTrigger(entry, type)) continue;
      return "user";
    }
  }
  return "auto";
}

function motherV2CollectImageInteractionSignals(imageIds = []) {
  const ids = (Array.isArray(imageIds) ? imageIds : [])
    .map((v) => String(v || "").trim())
    .filter(Boolean);
  const idSet = new Set(ids);
  const ensure = (map, imageId) => {
    if (!idSet.has(imageId)) return null;
    if (!map.has(imageId)) {
      map.set(imageId, {
        move_count: 0,
        resize_count: 0,
        transform_count: 0,
        selection_hits: 0,
        action_grid_hits: 0,
        last_event_at_ms: 0,
        last_transform_at_ms: 0,
      });
    }
    return map.get(imageId);
  };
  const out = new Map();
  for (const id of ids) {
    ensure(out, id);
  }
  const events = Array.isArray(state.userEvents) ? state.userEvents : [];
  for (const entry of events) {
    if (!entry || typeof entry !== "object") continue;
    const type = String(entry.type || "").trim();
    const atMs = Number(entry.at_ms) || 0;
    if (type === "image_move" || type === "image_resize" || type === "image_transform") {
      const imageId = String(entry.image_id || "").trim();
      const row = ensure(out, imageId);
      if (!row) continue;
      if (type === "image_move") row.move_count += 1;
      if (type === "image_resize") row.resize_count += 1;
      if (type === "image_transform") row.transform_count += 1;
      if (atMs > row.last_transform_at_ms) row.last_transform_at_ms = atMs;
      if (atMs > row.last_event_at_ms) row.last_event_at_ms = atMs;
      continue;
    }
    if (type === "selection_change") {
      const selectedIds = Array.isArray(entry.selected_ids)
        ? entry.selected_ids.map((v) => String(v || "").trim()).filter(Boolean)
        : [];
      for (const imageId of selectedIds) {
        const row = ensure(out, imageId);
        if (!row) continue;
        row.selection_hits += 1;
        if (atMs > row.last_event_at_ms) row.last_event_at_ms = atMs;
      }
      continue;
    }
    if (type === "action_grid_press") {
      const selectedIds = Array.isArray(entry.selected_ids)
        ? entry.selected_ids.map((v) => String(v || "").trim()).filter(Boolean)
        : [];
      const activeId = String(entry.active_id || "").trim();
      for (const imageId of selectedIds) {
        const row = ensure(out, imageId);
        if (!row) continue;
        row.action_grid_hits += 1;
        if (atMs > row.last_event_at_ms) row.last_event_at_ms = atMs;
      }
      if (activeId) {
        const row = ensure(out, activeId);
        if (row) {
          row.action_grid_hits += 1;
          if (atMs > row.last_event_at_ms) row.last_event_at_ms = atMs;
        }
      }
    }
  }
  return out;
}

function motherV2EnvelopeBudgetForProvider(provider = "", model = "") {
  const providerKey = String(provider || "").trim().toLowerCase();
  const modelKey = String(model || "").trim().toLowerCase();
  if (providerKey === "openai") {
    if (modelKey.includes("mini")) return { maxImages: 3, maxRelations: 2, maxMustNot: 5, maxChars: 1300 };
    return { maxImages: 4, maxRelations: 3, maxMustNot: 6, maxChars: 1700 };
  }
  if (providerKey === "flux") {
    if (modelKey.includes("flex")) return { maxImages: 3, maxRelations: 2, maxMustNot: 4, maxChars: 1100 };
    return { maxImages: 4, maxRelations: 2, maxMustNot: 5, maxChars: 1300 };
  }
  if (providerKey === "imagen") return { maxImages: 4, maxRelations: 3, maxMustNot: 6, maxChars: 1500 };
  return { maxImages: 3, maxRelations: 2, maxMustNot: 5, maxChars: 1200 };
}

function motherV2BuildNonGeminiModelContextEnvelope({
  provider = "",
  model = "",
  compiled = {},
  promptLine = "",
  sanitizedIntent = null,
  imagePayload = null,
  geminiContextPacket = null,
} = {}) {
  const providerKey = String(provider || "").trim().toLowerCase();
  if (!providerKey || providerKey === "gemini") return null;
  const modelKey = String(model || "").trim();
  const budget = motherV2EnvelopeBudgetForProvider(providerKey, modelKey);
  const normalizeIds = (values, limit = 8) =>
    (Array.isArray(values) ? values : [])
      .map((v) => String(v || "").trim())
      .filter(Boolean)
      .slice(0, Math.max(1, Number(limit) || 1));
  const intent = sanitizedIntent && typeof sanitizedIntent === "object" ? sanitizedIntent : {};
  const packet = geminiContextPacket && typeof geminiContextPacket === "object" ? geminiContextPacket : {};
  const proposalLock = packet?.proposal_lock && typeof packet.proposal_lock === "object" ? packet.proposal_lock : {};
  const sourceImageIds = normalizeIds(imagePayload?.sourceImageIds, 10);
  const transformationMode = motherV2NormalizeTransformationMode(
    proposalLock.transformation_mode || intent.transformation_mode || compiled?.transformation_mode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE
  );
  const shotTypeHints = motherV2ShotTypeHints({
    preferredMode: transformationMode,
    candidateModes:
      proposalLock.transformation_mode_candidates ||
      intent.transformation_mode_candidates ||
      [],
  });
  const layout = String(
    proposalLock.placement_policy || intent.placement_policy || compiled?.generation_params?.layout_hint || "adjacent"
  ).trim() || "adjacent";
  const selectedIds = normalizeIds(proposalLock.selected_ids || getVisibleSelectedIds(), 6);
  const targetIds = normalizeIds(proposalLock.target_ids || intent.target_ids, 6);
  const referenceIds = normalizeIds(proposalLock.reference_ids || intent.reference_ids, 8);
  const dispatchManifestById = new Map(
    (Array.isArray(imagePayload?.dispatchImageManifest) ? imagePayload.dispatchImageManifest : [])
      .map((entry) => [String(entry?.id || "").trim(), entry])
      .filter(([id]) => Boolean(id))
  );
  const packetImages = Array.isArray(packet?.images) ? packet.images : [];
  let images = packetImages
    .map((entry) => {
      if (!entry || typeof entry !== "object") return null;
      const id = String(entry.id || "").trim();
      if (!id) return null;
      const dispatchEntry = dispatchManifestById.get(id) || null;
      return {
        slot: String(entry.slot || "").trim() || null,
        id,
        role: String(entry.role || "").trim() || "context",
        tier: String(entry.tier || "").trim() || null,
        weight: Number.isFinite(Number(entry.weight)) ? Number(entry.weight) : null,
        preserve: (Array.isArray(entry.preserve) ? entry.preserve : []).map((v) => String(v || "").trim()).filter(Boolean).slice(0, 2),
        transform: (Array.isArray(entry.transform) ? entry.transform : []).map((v) => String(v || "").trim()).filter(Boolean).slice(0, 2),
        transform_state:
          entry.transform_state && typeof entry.transform_state === "object"
            ? {
                rotate_deg: Number(entry.transform_state.rotate_deg) || 0,
                skew_x_deg: Number(entry.transform_state.skew_x_deg) || 0,
                user_resized: Boolean(entry.transform_state.user_resized),
              }
            : dispatchEntry
            ? {
                rotate_deg: Number(dispatchEntry.rotate_deg) || 0,
                skew_x_deg: Number(dispatchEntry.skew_x_deg) || 0,
                user_resized: Boolean(dispatchEntry.user_resized),
              }
            : null,
        position_tier: String(entry.position_tier || "").trim() || null,
        size_tier: String(entry.size_tier || "").trim() || null,
      };
    })
    .filter(Boolean)
    .slice(0, budget.maxImages);
  if (!images.length) {
    images = sourceImageIds.slice(0, budget.maxImages).map((id, index) => ({
      slot: null,
      id,
      role: index === 0 ? "target" : "reference",
      tier: index === 0 ? "PRIMARY" : "SECONDARY",
      weight: null,
      preserve: [],
      transform: [],
      transform_state: null,
      position_tier: null,
      size_tier: null,
    }));
  }
  const packetRelations = Array.isArray(packet?.relations) ? packet.relations : [];
  const relations = packetRelations
    .map((entry) => {
      if (!entry || typeof entry !== "object") return null;
      const refId = String(entry.ref_id || "").trim();
      if (!refId) return null;
      return {
        ref_id: refId,
        to_target: String(entry.to_target || "").trim() || "ADJACENT",
        direction: String(entry.direction || "").trim() || null,
        overlap_strength: String(entry.overlap_strength || "").trim() || null,
        region_on_target: String(entry.region_on_target || "").trim() || null,
        semantic: String(entry.semantic || "").trim() || null,
        confidence: Number.isFinite(Number(entry.confidence)) ? Number(entry.confidence) : null,
      };
    })
    .filter(Boolean)
    .slice(0, budget.maxRelations);
  const mustNotValues = [];
  const mustNotSeen = new Set();
  const pushMustNot = (raw) => {
    const text = String(raw || "")
      .trim()
      .replace(/^[-*â€¢]\s*/, "")
      .replace(/\s+/g, " ");
    if (!text) return;
    const key = text.toLowerCase();
    if (mustNotSeen.has(key)) return;
    mustNotSeen.add(key);
    mustNotValues.push(text);
  };
  const packetMustNot = Array.isArray(packet?.constraints?.must_not)
    ? packet.constraints.must_not
    : Array.isArray(packet?.must_not)
      ? packet.must_not
      : [];
  for (const item of packetMustNot) pushMustNot(item);
  for (const item of Array.isArray(compiled?.compile_constraints) ? compiled.compile_constraints : []) pushMustNot(item);
  const negativePrompt = String(compiled?.negative_prompt || "").trim();
  if (negativePrompt) {
    for (const item of negativePrompt.split(/\n|;|,/g)) pushMustNot(item);
  }
  const mustNot = mustNotValues.slice(0, budget.maxMustNot);
  const goal = clampText(
    String(packet?.goal || intent?.summary || "Create one coherent production-ready image."),
    260
  );
  const creativeDirective = clampText(
    String(compiled?.creative_directive || intent?.creative_directive || motherCurrentCreativeDirective()),
    140
  );
  const guidance =
    providerKey === "flux"
      ? [
          "Keep directives concise and concrete.",
          "Prioritize subject continuity and lighting realism.",
          "Respect canvas rotation/skew/scale intent from input geometry.",
          "Treat must_not constraints as hard requirements.",
        ]
      : [
          "Use explicit composition and subject continuity instructions.",
          "Respect canvas rotation/skew/scale intent from input geometry.",
          "Treat must_not constraints as hard requirements.",
        ];
  const transformedSourceCount = Array.isArray(imagePayload?.dispatchImageManifest)
    ? imagePayload.dispatchImageManifest.filter((entry) => Boolean(entry?.transformed)).length
    : 0;
  const envelope = {
    schema: `brood.model_context_envelope.${providerKey}.v1`,
    provider: providerKey,
    model: modelKey || null,
    profile: providerKey === "flux" ? "flux-editing-compact" : "openai-image-structured",
    prompt_budget_chars: budget.maxChars,
    goal,
    creative_directive: creativeDirective,
    transformation_mode: transformationMode,
    shot_type: shotTypeHints.primary_shot_type,
    alternate_shot_type: shotTypeHints.alternate_shot_type,
    lighting_profile: shotTypeHints.primary_lighting_profile,
    alternate_lighting_profile: shotTypeHints.alternate_lighting_profile,
    lens_guidance: shotTypeHints.primary_lens_guidance,
    alternate_lens_guidance: shotTypeHints.alternate_lens_guidance,
    layout,
    source_image_ids: sourceImageIds.slice(0, 8),
    respect_canvas_transforms: true,
    transformed_source_images: transformedSourceCount,
    target_ids: targetIds.slice(0, 4),
    reference_ids: referenceIds.slice(0, 6),
    selected_ids: selectedIds.slice(0, 4),
    images,
    relations,
    must_not: mustNot,
    guidance,
    prompt_preview: clampText(promptLine, 280),
  };
  const serializedLen = () => JSON.stringify(envelope).length;
  while (serializedLen() > budget.maxChars && envelope.relations.length > 1) envelope.relations.pop();
  while (serializedLen() > budget.maxChars && envelope.images.length > 2) envelope.images.pop();
  while (serializedLen() > budget.maxChars && envelope.must_not.length > 3) envelope.must_not.pop();
  if (serializedLen() > budget.maxChars) {
    envelope.goal = clampText(envelope.goal, 180);
    envelope.prompt_preview = clampText(envelope.prompt_preview, 180);
  }
  return envelope;
}

function motherV2BuildModelContextEnvelopes({
  selectedModel = "",
  compiled = {},
  promptLine = "",
  sanitizedIntent = null,
  imagePayload = null,
  geminiContextPacket = null,
} = {}) {
  const model = String(selectedModel || "").trim();
  if (!model) return null;
  const provider = providerFromModel(model);
  if (!provider || provider === "unknown" || provider === "gemini") return null;
  const providerKey = provider === "sdxl" ? "replicate" : provider;
  const envelope = motherV2BuildNonGeminiModelContextEnvelope({
    provider: providerKey,
    model,
    compiled,
    promptLine,
    sanitizedIntent,
    imagePayload,
    geminiContextPacket,
  });
  if (!envelope || typeof envelope !== "object") return null;
  return { [providerKey]: envelope };
}

function motherV2BuildGeminiContextPacket({ compiled = {}, promptLine = "", sanitizedIntent = null, imagePayload = null } = {}) {
  const idle = state.motherIdle;
  const intent = sanitizedIntent && typeof sanitizedIntent === "object" ? sanitizedIntent : {};
  const sourceImageIds = Array.isArray(imagePayload?.sourceImageIds)
    ? imagePayload.sourceImageIds.map((v) => String(v || "").trim()).filter(Boolean)
    : [];
  if (!sourceImageIds.length) return null;

  const SATURATION_K = Object.freeze({
    move: 8,
    resize: 4,
    transform: 5,
    selection: 8,
    action: 4,
  });
  const MUST_NOT_DEFAULTS = Object.freeze([
    "No collage or split-screen.",
    "No text, captions, or watermarks.",
    "No ghosted double-exposure overlays.",
    "No UI residue or icon-overpaint artifacts.",
    "No duplicated heads or limbs.",
    "No extra humans or faces unless present in inputs.",
  ]);
  const INTERACTION_DECAY_TAU_MS = 90_000;
  const INTERACTION_STALE_CUTOFF_MS = 10 * 60 * 1000;
  const EPS = 1e-9;
  const wrap = els.canvasWrap;
  const canvasCssW = Math.max(1, Number(wrap?.clientWidth) || 1);
  const canvasCssH = Math.max(1, Number(wrap?.clientHeight) || 1);
  const nowMs = Date.now();
  const clamp01 = (value) => clamp(Number(value) || 0, 0, 1);
  const round4 = (value) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return 0;
    return Math.round(n * 10000) / 10000;
  };
  const round2 = (value) => {
    const n = Number(value);
    if (!Number.isFinite(n)) return 0;
    return Math.round(n * 100) / 100;
  };
  const sat = (count, k) => {
    const c = Math.max(0, Number(count) || 0);
    const cap = Math.max(1, Number(k) || 1);
    const v = Math.log(1 + c) / Math.log(1 + cap);
    return clamp01(v);
  };
  const uniqueIds = (values = []) => {
    const out = [];
    for (const raw of Array.isArray(values) ? values : []) {
      const id = String(raw || "").trim();
      if (!id || out.includes(id)) continue;
      out.push(id);
    }
    return out;
  };
  const slotLabelForIndex = (index) => {
    const i = Math.max(0, Math.floor(Number(index) || 0));
    if (i < 26) return String.fromCharCode(65 + i);
    return `I${i + 1}`;
  };
  const toRectNorm = (rectRaw) => {
    if (!rectRaw || typeof rectRaw !== "object") return null;
    const x = (Number(rectRaw.x) || 0) / canvasCssW;
    const y = (Number(rectRaw.y) || 0) / canvasCssH;
    const w = Math.max(0, Number(rectRaw.w) || 0) / canvasCssW;
    const h = Math.max(0, Number(rectRaw.h) || 0) / canvasCssH;
    return {
      x: round4(x),
      y: round4(y),
      w: round4(w),
      h: round4(h),
      cx: round4(x + w / 2),
      cy: round4(y + h / 2),
    };
  };
  const positionTierFromRect = (rectNorm) => {
    const cx = Number(rectNorm?.cx);
    const cy = Number(rectNorm?.cy);
    if (!Number.isFinite(cx) || !Number.isFinite(cy)) return "CENTER_MIDDLE";
    const xTier = cx < 0.34 ? "LEFT" : cx > 0.66 ? "RIGHT" : "CENTER";
    const yTier = cy < 0.34 ? "TOP" : cy > 0.66 ? "BOTTOM" : "MIDDLE";
    return `${xTier}_${yTier}`;
  };
  const sizeTierFromArea = (areaRatio) => {
    const n = Math.max(0, Number(areaRatio) || 0);
    if (n >= 0.07) return "DOMINANT";
    if (n >= 0.03) return "MEDIUM";
    return "SMALL";
  };
  const relationFromDelta = (dx, dy, overlaps = false) => {
    if (overlaps) return "OVERLAP";
    return Math.abs(dx) >= Math.abs(dy)
      ? (dx >= 0 ? "RIGHT" : "LEFT")
      : (dy >= 0 ? "BELOW" : "ABOVE");
  };
  const overlapRegionForRect = (rectNorm, ix1, iy1, ix2, iy2) => {
    const rw = Math.max(1e-6, Number(rectNorm?.w) || 0);
    const rh = Math.max(1e-6, Number(rectNorm?.h) || 0);
    const rx = Number(rectNorm?.x) || 0;
    const ry = Number(rectNorm?.y) || 0;
    const cx = ((Number(ix1) || 0) + (Number(ix2) || 0)) / 2;
    const cy = ((Number(iy1) || 0) + (Number(iy2) || 0)) / 2;
    const localCx = clamp((cx - rx) / rw, 0, 1);
    const localCy = clamp((cy - ry) / rh, 0, 1);
    const hBucket = localCx < 0.34 ? "left" : localCx > 0.66 ? "right" : "center";
    const vBucket = localCy < 0.34 ? "top" : localCy > 0.66 ? "bottom" : "middle";
    return {
      region: `${vBucket}_${hBucket}`,
      x_norm: round4(clamp(((Number(ix1) || 0) - rx) / rw, 0, 1)),
      y_norm: round4(clamp(((Number(iy1) || 0) - ry) / rh, 0, 1)),
    };
  };
  const invertRelation = (value = "") => {
    const rel = String(value || "").trim().toUpperCase();
    if (rel === "LEFT") return "RIGHT";
    if (rel === "RIGHT") return "LEFT";
    if (rel === "ABOVE") return "BELOW";
    if (rel === "BELOW") return "ABOVE";
    return rel || "UNKNOWN";
  };
  const normalizeMustNot = (raw) => {
    const text = String(raw || "")
      .trim()
      .replace(/^[-*â€¢]\s*/, "")
      .replace(/\s+/g, " ");
    if (!text) return null;
    return text;
  };
  const splitNegativePrompt = (raw) =>
    String(raw || "")
      .split(/\n|;|,/g)
      .map((v) => v.trim())
      .filter(Boolean);
  const rolePriorForImage = (imageId, roleTags = [], targetIdSet = new Set(), referenceIdSet = new Set()) => {
    let prior = 0.3;
    if (targetIdSet.has(imageId)) prior = 1.0;
    else if (referenceIdSet.has(imageId)) prior = 0.6;
    if (roleTags.includes("subject")) prior *= 1.05;
    if (roleTags.includes("mediator")) prior *= 0.97;
    return clamp(prior, 0.25, 1.0);
  };

  const actionVersion = Number(idle?.actionVersion) || 0;
  const summary = String(intent.summary || motherV2ProposalSentence(intent) || "").trim();
  const creativeDirective = String(compiled?.creative_directive || intent.creative_directive || motherCurrentCreativeDirective() || "").trim();
  const transformationMode = motherV2NormalizeTransformationMode(
    intent.transformation_mode || compiled?.transformation_mode || MOTHER_V2_DEFAULT_TRANSFORMATION_MODE
  );
  const transformationModeCandidatesRaw = Array.isArray(intent.transformation_mode_candidates)
    ? intent.transformation_mode_candidates
    : [];
  const transformationModeCandidates = [];
  const pushModeCandidate = (rawMode, rawConfidence = null, rawAweJoyScore = null, { idx = null } = {}) => {
    const normalized = motherV2NormalizeModeCandidate(
      {
        mode: rawMode,
        confidence: rawConfidence,
        awe_joy_score: rawAweJoyScore,
      },
      { idx: idx === null ? transformationModeCandidates.length : idx }
    );
    if (!normalized) return;
    const existing = transformationModeCandidates.find((entry) => entry.mode === normalized.mode) || null;
    if (!existing) {
      transformationModeCandidates.push(normalized);
      return;
    }
    if (typeof normalized.confidence === "number") {
      const prior = typeof existing.confidence === "number" ? existing.confidence : -1;
      if (normalized.confidence > prior) existing.confidence = normalized.confidence;
    }
    if (typeof normalized.awe_joy_score === "number") {
      const prior = typeof existing.awe_joy_score === "number" ? existing.awe_joy_score : -1;
      if (normalized.awe_joy_score > prior) existing.awe_joy_score = normalized.awe_joy_score;
    }
    const priorIdx = Number.isFinite(Number(existing._idx)) ? Number(existing._idx) : Number.MAX_SAFE_INTEGER;
    const nextIdx = Number.isFinite(Number(normalized._idx)) ? Number(normalized._idx) : Number.MAX_SAFE_INTEGER;
    existing._idx = Math.min(priorIdx, nextIdx);
  };
  pushModeCandidate(transformationMode, null, null, { idx: 0 });
  let modeCandidateIdx = 1;
  for (const entry of transformationModeCandidatesRaw) {
    if (entry && typeof entry === "object") {
      pushModeCandidate(entry.mode || entry.transformation_mode, entry.confidence, entry.awe_joy_score, { idx: modeCandidateIdx });
    } else {
      pushModeCandidate(entry, null, null, { idx: modeCandidateIdx });
    }
    modeCandidateIdx += 1;
  }
  transformationModeCandidates.sort(motherV2CompareModeCandidates);
  const rankedTransformationModeCandidates = transformationModeCandidates.slice(0, motherV2ProposalLimit()).map((entry) => ({
    mode: entry.mode,
    awe_joy_score: typeof entry.awe_joy_score === "number" ? entry.awe_joy_score : null,
    confidence: typeof entry.confidence === "number" ? entry.confidence : null,
  }));
  const shotTypeHints = motherV2ShotTypeHints({
    preferredMode: transformationMode,
    candidateModes: rankedTransformationModeCandidates,
  });
  const placementPolicy = String(
    intent.placement_policy ||
      compiled?.generation_params?.layout_hint ||
      "adjacent"
  ).trim() || "adjacent";
  const selectedIds = getVisibleSelectedIds().map((v) => String(v || "").trim()).filter(Boolean).slice(0, 3);
  const activeId = String(getVisibleActiveId() || "").trim() || null;
  const targetIds = uniqueIds(motherV2NormalizeImageIdList(intent.target_ids || [])).slice(0, 3);
  const referenceIds = uniqueIds(motherV2NormalizeImageIdList(intent.reference_ids || [])).slice(0, 4);
  const targetIdSet = new Set(targetIds);
  const referenceIdSet = new Set(referenceIds);
  const roleMapRaw = intent.roles && typeof intent.roles === "object" ? intent.roles : motherV2RoleMapClone();
  const roleMap = {
    subject: uniqueIds(motherV2NormalizeImageIdList(roleMapRaw.subject || [])).slice(0, 3),
    model: uniqueIds(motherV2NormalizeImageIdList(roleMapRaw.model || [])).slice(0, 3),
    mediator: uniqueIds(motherV2NormalizeImageIdList(roleMapRaw.mediator || [])).slice(0, 3),
    object: uniqueIds(motherV2NormalizeImageIdList(roleMapRaw.object || [])).slice(0, 3),
  };
  const signalsById = motherV2CollectImageInteractionSignals(sourceImageIds);

  const draft = [];
  for (const imageId of sourceImageIds) {
    const item = state.imagesById.get(imageId) || null;
    const rectCss = state.freeformRects.get(imageId) || null;
    const rectNorm = toRectNorm(rectCss);
    const rectTransform = readFreeformRectTransform(rectCss);
    const canvasAreaRatio = rectNorm ? Math.max(0, Number(rectNorm.w) * Number(rectNorm.h)) : 0;
    const aspectRatioNorm =
      rectNorm && Number(rectNorm.h) > 1e-6 ? Number(rectNorm.w) / Number(rectNorm.h) : null;
    const signal = signalsById.get(imageId) || {
      move_count: 0,
      resize_count: 0,
      transform_count: 0,
      selection_hits: 0,
      action_grid_hits: 0,
      last_event_at_ms: 0,
      last_transform_at_ms: 0,
    };
    const roleTags = MOTHER_V2_ROLE_KEYS.filter((key) => roleMap[key]?.includes(imageId));
    const isTarget = targetIdSet.has(imageId);
    const isReference = referenceIdSet.has(imageId);
    const isSubject = roleTags.includes("subject");
    const isModel = roleTags.includes("model");
    const isMediator = roleTags.includes("mediator");
    const isObject = roleTags.includes("object");

    const preserve = [];
    if (isTarget || isSubject || isObject || imageId === sourceImageIds[0]) preserve.push("primary anchor");
    if (Number(signal.resize_count) > 0) preserve.push("user framing emphasis");
    if (Number(signal.transform_count) > 0) preserve.push("user transform intent");
    if (Number(signal.selection_hits) > 0 || Number(signal.action_grid_hits) > 0) preserve.push("user focus cues");

    const transform = [];
    if (isReference || isModel || isMediator) transform.push("material and style cues");
    if (Number(signal.move_count) > 0) transform.push("composition relationship cues");
    if (Number(signal.transform_count) > 0) transform.push("rotation/skew cues");
    if (Math.abs(Number(rectTransform.rotateDeg) || 0) > 0.2 || Math.abs(Number(rectTransform.skewXDeg) || 0) > 0.2) {
      transform.push("canvas transform lock");
    }
    if (rectCss?.autoAspect === false) transform.push("user scale lock");

    const moveSat = sat(signal.move_count, SATURATION_K.move);
    const resizeSat = sat(signal.resize_count, SATURATION_K.resize);
    const transformSat = sat(signal.transform_count, SATURATION_K.transform);
    const selectionSat = sat(signal.selection_hits, SATURATION_K.selection);
    const actionSat = sat(signal.action_grid_hits, SATURATION_K.action);
    const interactionBase =
      0.3 * moveSat + 0.22 * resizeSat + 0.23 * transformSat + 0.2 * selectionSat + 0.05 * actionSat;
    const transformRecencyMs = Number(signal.last_transform_at_ms) || 0;
    const recencyMs = transformRecencyMs || Number(signal.last_event_at_ms) || 0;
    const ageMs = recencyMs ? Math.max(0, nowMs - recencyMs) : INTERACTION_STALE_CUTOFF_MS + 1;
    const transformAgeMs = transformRecencyMs
      ? Math.max(0, nowMs - transformRecencyMs)
      : INTERACTION_STALE_CUTOFF_MS + 1;
    const interactionStale = transformAgeMs > INTERACTION_STALE_CUTOFF_MS;
    let interactionRaw = interactionStale
      ? 0
      : interactionBase * Math.exp(-ageMs / INTERACTION_DECAY_TAU_MS);
    if (
      Number(signal.move_count) <= 1 &&
      Number(signal.resize_count) === 0 &&
      Number(signal.transform_count) === 0 &&
      Number(signal.selection_hits) <= 2 &&
      Number(signal.action_grid_hits) === 0
    ) {
      interactionRaw = 0;
    }
    const rolePrior = rolePriorForImage(imageId, roleTags, targetIdSet, referenceIdSet);

    draft.push({
      id: imageId,
      file: item?.path ? basename(item.path) : null,
      origin: item && isMotherGeneratedImageItem(item) ? "mother_generated" : "uploaded",
      role_tags: roleTags,
      role: isTarget ? "target" : isReference ? "reference" : "context",
      role_prior: rolePrior,
      preserve,
      transform,
      signal,
      interaction_base: interactionBase,
      interaction_raw: Math.max(0, Number(interactionRaw) || 0),
      interaction_stale: interactionStale,
      rect_norm: rectNorm,
      transform_state: {
        rotate_deg: round2(rectTransform.rotateDeg),
        skew_x_deg: round2(rectTransform.skewXDeg),
        user_resized: rectCss?.autoAspect === false,
      },
      canvas_area_ratio: canvasAreaRatio,
      aspect_ratio_norm: aspectRatioNorm,
      focus_score_raw: 0,
      focus_score: 0,
      geometry_score_raw: 0,
      geometry_score: 0,
      relative_scale_to_largest: 0,
      centrality: 0,
      score: 0,
      weight: 0,
      position_tier: positionTierFromRect(rectNorm),
      size_tier: sizeTierFromArea(canvasAreaRatio),
    });
  }

  const interactionBaseMax = draft.reduce(
    (maxVal, entry) => Math.max(maxVal, Math.max(0, Number(entry.interaction_base) || 0)),
    0
  );
  const interactionRawMax = draft.reduce(
    (maxVal, entry) => Math.max(maxVal, Math.max(0, Number(entry.interaction_raw) || 0)),
    0
  );
  const interactionConfidence = clamp01((interactionBaseMax - 0.15) / 0.35);
  for (const entry of draft) {
    const focusRaw = interactionRawMax > 0 ? (Number(entry.interaction_raw) || 0) / (interactionRawMax + EPS) : 0;
    entry.focus_score_raw = clamp01(focusRaw);
    entry.focus_score = clamp01(interactionConfidence * entry.focus_score_raw);
  }

  const areaValues = draft
    .map((entry) => Math.max(0, Number(entry.canvas_area_ratio) || 0))
    .filter((value) => value > 0);
  const areaMax = areaValues.length ? Math.max(...areaValues) : 0;
  const areaMin = areaValues.length ? Math.min(...areaValues) : 0;
  const sqrtAreaMax = areaMax > 0 ? Math.sqrt(areaMax) : 0;
  const geometryConfidence =
    areaMax > 0 && areaMin > 0
      ? clamp01(Math.log((areaMax + EPS) / (areaMin + EPS)) / Math.log(2.5))
      : 0;
  let geometryRawMax = 0;
  for (const entry of draft) {
    const area = Math.max(0, Number(entry.canvas_area_ratio) || 0);
    const size = sqrtAreaMax > 0 ? Math.sqrt(area) / (sqrtAreaMax + EPS) : 0;
    entry.relative_scale_to_largest = clamp01(size);
    const cx = Number(entry.rect_norm?.cx);
    const cy = Number(entry.rect_norm?.cy);
    const centerDist = Number.isFinite(cx) && Number.isFinite(cy) ? Math.hypot(cx - 0.5, cy - 0.5) : 0.7071;
    const centrality = clamp01(1 - centerDist / 0.7071);
    entry.centrality = centrality;
    const geometryRaw = 0.8 * size + 0.2 * centrality;
    entry.geometry_score_raw = clamp01(geometryRaw);
    geometryRawMax = Math.max(geometryRawMax, entry.geometry_score_raw);
  }
  for (const entry of draft) {
    const normalized = geometryRawMax > 0 ? entry.geometry_score_raw / (geometryRawMax + EPS) : 0;
    entry.geometry_score = clamp01(geometryConfidence * normalized);
  }

  for (const entry of draft) {
    const selectedBonus = selectedIds.includes(entry.id) ? 0.1 : 0;
    const activeBonus = activeId && entry.id === activeId ? 0.05 : 0;
    entry.score =
      entry.role_prior *
      (1 + 0.6 * entry.focus_score) *
      (1 + 0.4 * entry.geometry_score) *
      (1 + selectedBonus + activeBonus);
  }
  let scoreTotal = draft.reduce((sum, entry) => sum + Math.max(0, Number(entry.score) || 0), 0);
  if (!(scoreTotal > 0)) {
    for (const entry of draft) entry.score = Math.max(0.001, Number(entry.role_prior) || 0.001);
    scoreTotal = draft.reduce((sum, entry) => sum + Math.max(0, Number(entry.score) || 0), 0);
  }
  for (const entry of draft) {
    entry.weight = scoreTotal > 0 ? (Number(entry.score) || 0) / (scoreTotal + EPS) : 0;
  }

  // Identity guardrails apply only for the single-target case.
  const targetIdList = targetIds.filter((id) => draft.some((entry) => entry.id === id));
  if (targetIdList.length === 1) {
    const tId = targetIdList[0];
    const targetEntry = draft.find((entry) => entry.id === tId) || null;
    if (targetEntry && Number(targetEntry.weight) < 0.55) {
      const delta = 0.55 - Number(targetEntry.weight || 0);
      const nonTargetEntries = draft.filter((entry) => entry.id !== tId);
      const nonTargetTotal = nonTargetEntries.reduce((sum, entry) => sum + Math.max(0, Number(entry.weight) || 0), 0);
      for (const entry of nonTargetEntries) {
        const share = nonTargetTotal > 0 ? (Number(entry.weight) || 0) / (nonTargetTotal + EPS) : 0;
        entry.weight = Math.max(0, (Number(entry.weight) || 0) - delta * share);
      }
      targetEntry.weight = 0.55;
    }
    for (const refId of referenceIds) {
      const refEntry = draft.find((entry) => entry.id === refId) || null;
      if (!refEntry) continue;
      if (Number(refEntry.weight) <= 0.3) continue;
      const excess = Number(refEntry.weight) - 0.3;
      refEntry.weight = 0.3;
      const targetEntryNow = draft.find((entry) => entry.id === tId) || null;
      if (targetEntryNow) targetEntryNow.weight = Number(targetEntryNow.weight || 0) + excess;
    }
    const renorm = draft.reduce((sum, entry) => sum + Math.max(0, Number(entry.weight) || 0), 0);
    for (const entry of draft) {
      entry.weight = renorm > 0 ? (Number(entry.weight) || 0) / (renorm + EPS) : entry.weight;
    }
  }

  const zIndexById = new Map();
  for (let i = 0; i < (state.freeformZOrder?.length || 0); i += 1) {
    const id = String(state.freeformZOrder[i] || "").trim();
    if (!id) continue;
    if (!zIndexById.has(id)) zIndexById.set(id, i);
  }
  const slotById = new Map();
  const orderForSlots = uniqueIds(sourceImageIds.filter((id) => draft.some((entry) => entry.id === id)));
  for (let i = 0; i < orderForSlots.length; i += 1) {
    slotById.set(orderForSlots[i], slotLabelForIndex(i));
  }

  const spatialImageEntries = draft.filter((entry) => entry.rect_norm && typeof entry.rect_norm === "object").slice(0, 8);
  const pairwise = [];
  const pairMap = new Map();
  const pairKey = (aId, bId) => {
    const a = String(aId || "").trim();
    const b = String(bId || "").trim();
    if (!a || !b) return "";
    return a < b ? `${a}::${b}` : `${b}::${a}`;
  };
  const diagonalNorm = Math.sqrt(2);
  for (let i = 0; i < spatialImageEntries.length; i += 1) {
    for (let j = i + 1; j < spatialImageEntries.length; j += 1) {
      const a = spatialImageEntries[i];
      const b = spatialImageEntries[j];
      const ar = a.rect_norm || null;
      const br = b.rect_norm || null;
      if (!ar || !br) continue;
      const ax1 = Number(ar.x) || 0;
      const ay1 = Number(ar.y) || 0;
      const ax2 = ax1 + Math.max(0, Number(ar.w) || 0);
      const ay2 = ay1 + Math.max(0, Number(ar.h) || 0);
      const bx1 = Number(br.x) || 0;
      const by1 = Number(br.y) || 0;
      const bx2 = bx1 + Math.max(0, Number(br.w) || 0);
      const by2 = by1 + Math.max(0, Number(br.h) || 0);
      const acx = ax1 + (ax2 - ax1) / 2;
      const acy = ay1 + (ay2 - ay1) / 2;
      const bcx = bx1 + (bx2 - bx1) / 2;
      const bcy = by1 + (by2 - by1) / 2;
      const dx = bcx - acx;
      const dy = bcy - acy;
      const centerDistanceNorm = diagonalNorm > 0 ? Math.hypot(dx, dy) / diagonalNorm : 0;
      const gapX = Math.max(0, Math.max(ax1 - bx2, bx1 - ax2));
      const gapY = Math.max(0, Math.max(ay1 - by2, by1 - ay2));
      const edgeGapNorm = Math.hypot(gapX, gapY);
      const ix1 = Math.max(ax1, bx1);
      const iy1 = Math.max(ay1, by1);
      const ix2 = Math.min(ax2, bx2);
      const iy2 = Math.min(ay2, by2);
      const iw = Math.max(0, ix2 - ix1);
      const ih = Math.max(0, iy2 - iy1);
      const overlapArea = Math.max(0, iw * ih);
      const overlaps = overlapArea > 1e-8;
      const areaA = Math.max(0, (ax2 - ax1) * (ay2 - ay1));
      const areaB = Math.max(0, (bx2 - bx1) * (by2 - by1));
      const union = Math.max(0, areaA + areaB - overlapArea);
      const iou = union > 1e-8 ? overlapArea / union : 0;
      const overlapRatioA = areaA > 1e-8 ? overlapArea / areaA : 0;
      const overlapRatioB = areaB > 1e-8 ? overlapArea / areaB : 0;
      const aToB = relationFromDelta(dx, dy, overlaps);
      const overlapOnA = overlaps
        ? {
            ...overlapRegionForRect(ar, ix1, iy1, ix2, iy2),
            ratio: round4(overlapRatioA),
          }
        : null;
      const overlapOnB = overlaps
        ? {
            ...overlapRegionForRect(br, ix1, iy1, ix2, iy2),
            ratio: round4(overlapRatioB),
          }
        : null;
      const zA = zIndexById.has(a.id) ? Number(zIndexById.get(a.id)) : null;
      const zB = zIndexById.has(b.id) ? Number(zIndexById.get(b.id)) : null;
      const topId = zA === null || zB === null ? null : (zA > zB ? a.id : b.id);
      const pair = {
        id_a: a.id,
        id_b: b.id,
        a_to_b: aToB,
        b_to_a: invertRelation(aToB),
        center_distance_norm: round4(centerDistanceNorm),
        edge_gap_norm: round4(edgeGapNorm),
        overlaps,
        overlap: overlaps
          ? {
              iou: round4(iou),
              area_norm: round4(overlapArea),
              on_a: overlapOnA,
              on_b: overlapOnB,
            }
          : null,
        z_order: {
          index_a: zA,
          index_b: zB,
          top_id: topId,
        },
      };
      pairwise.push(pair);
      const k = pairKey(a.id, b.id);
      if (k) pairMap.set(k, pair);
    }
  }
  pairwise.sort((a, b) => {
    if (Number(Boolean(b.overlaps)) !== Number(Boolean(a.overlaps))) {
      return Number(Boolean(b.overlaps)) - Number(Boolean(a.overlaps));
    }
    return Number(a.center_distance_norm) - Number(b.center_distance_norm);
  });

  const sortedByWeight = draft.slice().sort((a, b) => Number(b.weight) - Number(a.weight));
  const primaryTargetId =
    targetIdList[0] ||
    sortedByWeight[0]?.id ||
    null;

  const relations = [];
  for (const refId of referenceIds) {
    if (!primaryTargetId || refId === primaryTargetId) continue;
    const refEntry = draft.find((entry) => entry.id === refId) || null;
    if (!refEntry) continue;
    const key = pairKey(primaryTargetId, refId);
    const pair = key ? pairMap.get(key) : null;
    if (!pair) continue;
    const primaryIsA = String(pair.id_a || "") === String(primaryTargetId || "");
    const direction = primaryIsA ? pair.a_to_b : pair.b_to_a;
    if (direction === "OVERLAP") {
      const overlap = pair.overlap || null;
      if (!overlap) continue;
      const overlapOnTarget = primaryIsA ? overlap.on_a : overlap.on_b;
      const overlapOnRef = primaryIsA ? overlap.on_b : overlap.on_a;
      const iou = Number(overlap.iou) || 0;
      const areaNorm = Number(overlap.area_norm) || 0;
      const coverMax = Math.max(Number(overlapOnTarget?.ratio) || 0, Number(overlapOnRef?.ratio) || 0);
      const confIou = clamp01((iou - 0.03) / 0.12);
      const confArea = clamp01((areaNorm - 0.005) / 0.02);
      const confCov = clamp01((coverMax - 0.25) / 0.5);
      const confidence = round4(Math.max(confIou, confArea, confCov));
      if (confidence < 0.55) continue;
      const strength =
        iou >= 0.12 || areaNorm >= 0.015 ? "STRONG" : iou >= 0.05 || areaNorm >= 0.008 ? "MEDIUM" : "LIGHT";
      const topId = String(pair.z_order?.top_id || "").trim();
      const occlusion =
        topId && topId === primaryTargetId
          ? "TARGET_FRONT"
          : topId && topId === refId
            ? "REF_FRONT"
            : "UNKNOWN";
      let semantic = "NONE";
      if (occlusion === "TARGET_FRONT" && (Number(overlapOnRef?.ratio) || 0) >= 0.6) {
        semantic = "STYLE_TUCK";
      } else if (occlusion === "REF_FRONT" && (strength === "MEDIUM" || strength === "STRONG") && placementPolicy !== "adjacent") {
        semantic = "FOREGROUND_ACCENT";
      } else if (strength === "LIGHT" && Number(pair.edge_gap_norm || 0) === 0) {
        semantic = "TOUCH";
      }
      relations.push({
        ref_id: refId,
        ref_slot: slotById.get(refId) || null,
        to_target: "OVERLAP",
        overlap_strength: strength,
        occlusion,
        region_on_target: String(overlapOnTarget?.region || "").toUpperCase() || null,
        semantic,
        confidence,
        iou: round4(iou),
      });
      continue;
    }
    const confDir =
      clamp01((0.35 - Number(pair.center_distance_norm || 0)) / 0.35) *
      clamp01((0.12 - Number(pair.edge_gap_norm || 0)) / 0.12);
    if (confDir < 0.6) continue;
    relations.push({
      ref_id: refId,
      ref_slot: slotById.get(refId) || null,
      to_target: "ADJACENT",
      direction: direction,
      confidence: round4(confDir),
      iou: 0,
    });
  }
  relations.sort((a, b) => Number(b.confidence || 0) - Number(a.confidence || 0));
  const relationLimit = referenceIds.length <= 4 ? 2 : 4;
  const compactRelations = relations.slice(0, relationLimit);

  for (const entry of draft) {
    const key = primaryTargetId && entry.id !== primaryTargetId ? pairKey(primaryTargetId, entry.id) : "";
    const pair = key ? pairMap.get(key) : null;
    const iouToPrimary = pair?.overlap ? Number(pair.overlap.iou) || 0 : 0;
    entry.geometry_trace = {
      cx: round4(entry.rect_norm?.cx ?? 0),
      cy: round4(entry.rect_norm?.cy ?? 0),
      relative_scale: round4(entry.relative_scale_to_largest),
      iou_to_primary: round4(iouToPrimary),
    };
  }

  const imagesCompact = sortedByWeight.map((entry, idx) => {
    const weight = round2(entry.weight);
    const tier = idx === 0 || weight >= 0.5 ? "PRIMARY" : weight >= 0.2 ? "SECONDARY" : "ACCENT";
    return {
      slot: slotById.get(entry.id) || null,
      id: entry.id,
      role: entry.role,
      weight,
      tier,
      size_tier: entry.size_tier,
      position_tier: entry.position_tier,
      focus_score: round2(entry.focus_score),
      geometry_score: round2(entry.geometry_score),
      role_tags: entry.role_tags.slice(0, 3),
      preserve: Array.from(new Set(entry.preserve)).slice(0, 3),
      transform: Array.from(new Set(entry.transform)).slice(0, 3),
      transform_state: entry.transform_state,
      geometry_trace: entry.geometry_trace,
    };
  });

  const imageManifest = sortedByWeight.map((entry, idx) => ({
    slot: slotById.get(entry.id) || null,
    id: entry.id,
    file: entry.file,
    origin: entry.origin,
    role: entry.role,
    role_tags: entry.role_tags,
    tier: idx === 0 || entry.weight >= 0.5 ? "PRIMARY" : entry.weight >= 0.2 ? "SECONDARY" : "ACCENT",
    preserve: Array.from(new Set(entry.preserve)).slice(0, 3),
    transform: Array.from(new Set(entry.transform)).slice(0, 3),
    transform_state: entry.transform_state,
    weight: round4(entry.weight),
    focus_score: round4(entry.focus_score),
    geometry_score: round4(entry.geometry_score),
    rect_norm: entry.rect_norm,
    canvas_area_ratio: round4(entry.canvas_area_ratio),
    relative_scale_to_largest: round4(entry.relative_scale_to_largest),
    aspect_ratio_norm: entry.aspect_ratio_norm !== null ? round4(entry.aspect_ratio_norm) : null,
    geometry_trace: entry.geometry_trace,
  }));

  const spatialRelations = {
    primary_target_id: primaryTargetId,
    image_ids_considered: spatialImageEntries.map((entry) => String(entry.id || "")),
    compact_relations: compactRelations,
    pairwise: pairwise.slice(0, 12),
  };

  const mustNot = [];
  const mustNotSeen = new Set();
  const pushMustNot = (raw) => {
    const text = normalizeMustNot(raw);
    if (!text) return;
    const key = text.toLowerCase();
    if (mustNotSeen.has(key)) return;
    mustNotSeen.add(key);
    mustNot.push(text);
  };
  for (const constraint of Array.isArray(compiled?.compile_constraints) ? compiled.compile_constraints : []) {
    pushMustNot(constraint);
  }
  const negativePrompt = String(compiled?.negative_prompt || "").trim();
  if (negativePrompt) {
    for (const line of splitNegativePrompt(negativePrompt)) pushMustNot(line);
  }
  for (const fallback of MUST_NOT_DEFAULTS) {
    if (mustNot.length >= 6) break;
    pushMustNot(fallback);
  }
  const mustNotFinal = mustNot.slice(0, 6);
  const overallConfidence = round4(clamp01(0.6 * interactionConfidence + 0.4 * geometryConfidence));
  const dispatchManifest = Array.isArray(imagePayload?.dispatchImageManifest) ? imagePayload.dispatchImageManifest : [];
  const transformedDispatchCount = dispatchManifest.filter((entry) => Boolean(entry?.transformed)).length;

  return {
    schema: "brood.gemini.context_packet.v2",
    action_version: actionVersion,
    intent_id: String(intent.intent_id || idle?.intent?.intent_id || "").trim() || null,
    goal: `Intent summary: ${summary || MOTHER_V2_PROPOSAL_BY_MODE[transformationMode] || "Create one coherent image."}`,
    creative_directive: creativeDirective || motherCurrentCreativeDirective(),
    optimization_target: motherCurrentOptimizationTarget(),
    style: {
      creative_directive: creativeDirective || motherCurrentCreativeDirective(),
      optimization_target: motherCurrentOptimizationTarget(),
      shot_type: shotTypeHints.primary_shot_type,
      lighting_profile: shotTypeHints.primary_lighting_profile,
      lens_guidance: shotTypeHints.primary_lens_guidance,
    },
    prompt_preview: clampText(String(promptLine || ""), 320),
    shot_type_hints: shotTypeHints,
    camera: {
      shot_type: shotTypeHints.primary_shot_type,
      alternate_shot_type: shotTypeHints.alternate_shot_type,
      lens_guidance: shotTypeHints.primary_lens_guidance,
      alternate_lens_guidance: shotTypeHints.alternate_lens_guidance,
    },
    lighting: {
      profile: shotTypeHints.primary_lighting_profile,
      alternate_profile: shotTypeHints.alternate_lighting_profile,
    },
    proposal_lock: {
      transformation_mode: transformationMode,
      transformation_mode_candidates: rankedTransformationModeCandidates,
      placement_policy: placementPolicy,
      shot_type: shotTypeHints.primary_shot_type,
      alternate_shot_type: shotTypeHints.alternate_shot_type,
      lighting_profile: shotTypeHints.primary_lighting_profile,
      alternate_lighting_profile: shotTypeHints.alternate_lighting_profile,
      lens_guidance: shotTypeHints.primary_lens_guidance,
      alternate_lens_guidance: shotTypeHints.alternate_lens_guidance,
      active_id: activeId,
      selected_ids: selectedIds,
      target_ids: targetIds,
      reference_ids: referenceIds,
      respect_canvas_transforms: true,
    },
    images: imagesCompact,
    relations: compactRelations,
    image_manifest: imageManifest,
    source_image_manifest: dispatchManifest.slice(0, 10),
    canvas_transform_lock: {
      respect_canvas_transforms: true,
      transformed_source_images: transformedDispatchCount,
      active_id: activeId,
    },
    spatial_relations: spatialRelations,
    behavior_signals: {
      focus_rank: imageManifest.map((entry) => entry.id).slice(0, 5),
      interaction_confidence: round4(interactionConfidence),
      geometry_confidence: round4(geometryConfidence),
      overall_confidence: overallConfidence,
      interaction_stale_cutoff_ms: INTERACTION_STALE_CUTOFF_MS,
      focus_scores: imageManifest
        .map((entry) => ({ id: entry.id, focus_score: round4(entry.focus_score) }))
        .slice(0, 8),
    },
    constraints: {
      must_not: mustNotFinal,
    },
    must_not: mustNotFinal,
    output: {
      count: 1,
      layout: placementPolicy,
      quality: "production-ready",
    },
  };
}

async function motherV2DispatchViaImagePayload(compiled = {}, promptLine = "", { selectedModel = "" } = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  const collectedImagePayload = motherV2CollectGenerationImagePaths();
  const imagePayload = await motherV2ResolveGenerationImagePayload(collectedImagePayload).catch(() => collectedImagePayload);
  const sanitizedIntent = motherV2SanitizeIntentImageIds(idle.intent) || idle.intent || null;
  const resolvedModel = String(selectedModel || settings.imageModel || MOTHER_GENERATION_MODEL).trim() || MOTHER_GENERATION_MODEL;
  const geminiContextPacket = motherV2BuildGeminiContextPacket({
    compiled,
    promptLine,
    sanitizedIntent,
    imagePayload,
  });
  const modelContextEnvelopes = motherV2BuildModelContextEnvelopes({
    selectedModel: resolvedModel,
    compiled,
    promptLine,
    sanitizedIntent,
    imagePayload,
    geminiContextPacket,
  });
  const compiledGenerationParams =
    compiled?.generation_params && typeof compiled.generation_params === "object" ? compiled.generation_params : {};
  const generationParams = {};
  const seedStrategy = String(compiledGenerationParams.seed_strategy || "").trim().toLowerCase();
  if (seedStrategy === "random") generationParams.seed_strategy = "random";
  if (compiledGenerationParams.seed !== undefined && compiledGenerationParams.seed !== null) {
    const seedValue = Number(compiledGenerationParams.seed);
    if (Number.isFinite(seedValue)) {
      generationParams.seed = Math.trunc(seedValue);
    }
  }
  if (typeof compiledGenerationParams.aspect_ratio === "string" && compiledGenerationParams.aspect_ratio.trim()) {
    generationParams.aspect_ratio = compiledGenerationParams.aspect_ratio.trim();
  }
  if (typeof compiledGenerationParams.image_size === "string" && compiledGenerationParams.image_size.trim()) {
    generationParams.image_size = compiledGenerationParams.image_size.trim();
  }
  if (Array.isArray(compiledGenerationParams.safety_settings) && compiledGenerationParams.safety_settings.length) {
    generationParams.safety_settings = compiledGenerationParams.safety_settings.slice();
  }
  if (compiledGenerationParams.add_watermark !== undefined && compiledGenerationParams.add_watermark !== null) {
    generationParams.add_watermark = Boolean(compiledGenerationParams.add_watermark);
  }
  if (compiledGenerationParams.person_generation !== undefined && compiledGenerationParams.person_generation !== null) {
    generationParams.person_generation = compiledGenerationParams.person_generation;
  }
  if (compiledGenerationParams.transport_retries !== undefined && compiledGenerationParams.transport_retries !== null) {
    const retriesValue = Number(compiledGenerationParams.transport_retries);
    if (Number.isFinite(retriesValue)) {
      generationParams.transport_retries = Math.max(0, Math.trunc(retriesValue));
    }
  }
  if (compiledGenerationParams.request_retries !== undefined && compiledGenerationParams.request_retries !== null) {
    const requestRetriesValue = Number(compiledGenerationParams.request_retries);
    if (Number.isFinite(requestRetriesValue)) {
      generationParams.request_retries = Math.max(0, Math.trunc(requestRetriesValue));
    }
  }
  if (compiledGenerationParams.retry_backoff !== undefined && compiledGenerationParams.retry_backoff !== null) {
    const retryBackoffValue = Number(compiledGenerationParams.retry_backoff);
    if (Number.isFinite(retryBackoffValue) && retryBackoffValue > 0) {
      generationParams.retry_backoff = retryBackoffValue;
    }
  }
  const normalizedModel = String(resolvedModel || "").toLowerCase();
  const isGeminiProImagePreviewModel = normalizedModel.includes("gemini-3-pro-image-preview");
  if (isGeminiProImagePreviewModel) {
    if (typeof generationParams.image_size !== "string" || !generationParams.image_size.trim()) {
      generationParams.image_size = "1K";
    }
    if (generationParams.transport_retries === undefined && generationParams.request_retries === undefined) {
      generationParams.transport_retries = 0;
    }
    if (generationParams.retry_backoff === undefined) {
      generationParams.retry_backoff = 0.1;
    }
  }
  const payload = {
    schema: "brood.mother.generate.v2",
    action_version: Number(idle.actionVersion) || 0,
    intent_id: sanitizedIntent?.intent_id || idle.intent?.intent_id || null,
    prompt: promptLine,
    n: 1,
    generation_params: generationParams,
    init_image: imagePayload.initImage,
    reference_images: imagePayload.referenceImages,
    gemini_context_packet: geminiContextPacket,
    source_image_manifest: Array.isArray(imagePayload.dispatchImageManifest)
      ? imagePayload.dispatchImageManifest.slice(0, 10)
      : null,
    canvas_transform_lock: {
      respect_canvas_transforms: true,
    },
  };
  const operationSpec = motherV2BuildOperationSpec({
    intent: sanitizedIntent,
    imagePayload,
    actionVersion: Number(idle.actionVersion) || 0,
    triggerSource: motherV2InferOperationTriggerSource(),
  });
  idle.currentOperationSpec = operationSpec;
  if (operationSpec) {
    payload.operation_spec = operationSpec;
    recordUserEvent("operation_spec_created", {
      actor: "system",
      source: "mother_dispatch",
      op_id: operationSpec.op_id,
      op_type: operationSpec.op_type,
      target_id: operationSpec.target_id,
      reference_ids: operationSpec.reference_ids.slice(0, 8),
      mode: operationSpec.mode || null,
      trigger_source: operationSpec.trigger_source,
      intent_id: sanitizedIntent?.intent_id || idle.intent?.intent_id || null,
      action_version: Number(idle.actionVersion) || 0,
    }, { includeInScoringRing: false });
  }
  if (modelContextEnvelopes && typeof modelContextEnvelopes === "object" && Object.keys(modelContextEnvelopes).length) {
    payload.model_context_envelopes = modelContextEnvelopes;
  }
  const payloadPath = await motherV2WritePayloadFile("mother_generate", payload);
  if (!payloadPath) return false;
  appendMotherTraceLog({
    kind: "generation_payload",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    intent_id: sanitizedIntent?.intent_id || idle.intent?.intent_id || null,
    transformation_mode: motherV2NormalizeTransformationMode(sanitizedIntent?.transformation_mode),
    placement_policy: sanitizedIntent?.placement_policy || null,
    selected_ids: getVisibleSelectedIds().map((v) => String(v || "").trim()).filter(Boolean),
    source_image_ids: Array.isArray(imagePayload.sourceImageIds) ? imagePayload.sourceImageIds.slice(0, 10) : [],
    source_images_transformed: Array.isArray(imagePayload.dispatchImageManifest)
      ? imagePayload.dispatchImageManifest.filter((entry) => Boolean(entry?.transformed)).length
      : 0,
    init_image_id: Array.isArray(imagePayload.sourceImageIds) && imagePayload.sourceImageIds.length
      ? String(imagePayload.sourceImageIds[0] || "")
      : null,
    operation_spec: operationSpec || null,
  }).catch(() => {});
  await invoke("write_pty", { data: `${PTY_COMMANDS.MOTHER_GENERATE} ${quoteForPtyArg(payloadPath)}\n` });
  return true;
}

async function motherV2DispatchCompiledPrompt(compiled = {}) {
  const idle = state.motherIdle;
  if (!idle) return false;
  const inIntentPhase = idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING;
  const effectiveSpeculative = Boolean(idle.pendingPromptCompileSpeculative && inIntentPhase);
  const canDispatch =
    idle.phase === MOTHER_IDLE_STATES.DRAFTING ||
    effectiveSpeculative;
  if (!canDispatch) return false;
  if (Number(idle.pendingActionVersion) !== Number(idle.actionVersion)) {
    motherV2MarkStale({ stage: "prompt_compile", pending_action_version: Number(idle.pendingActionVersion) || 0 });
    return false;
  }
  idle.pendingPromptCompile = false;
  idle.pendingPromptCompileSpeculative = false;
  clearTimeout(idle.pendingPromptCompileTimeout);
  idle.pendingPromptCompileTimeout = null;
  idle.promptMotionProfile = motherV2PromptMotionProfileFromCompiled(compiled);
  const selectedModel = motherPreferredGenerationModel();
  const dispatchProvider = providerFromModel(selectedModel) || null;
  idle.lastDispatchModel = selectedModel;
  const promptComposer = motherV2BuildPromptComposerResult(compiled);
  const promptLine = promptComposer.line;
  if (!promptLine) {
    motherIdleHandleGenerationFailed("Mother prompt compile produced an empty prompt.", {
      speculative: effectiveSpeculative,
    });
    return false;
  }
  motherIdleResetDispatchCorrelation({ rememberPendingVersion: true });
  idle.dispatchTimeoutExtensions = 0;
  idle.cancelArtifactUntil = 0;
  idle.cancelArtifactReason = null;
  idle.hasGeneratedSinceInteraction = false;
  idle.generatedImageId = null;
  idle.generatedVersionId = null;
  idle.suppressFailureUntil = 0;
  idle.pendingGeneration = true;
  idle.pendingDispatchToken = Date.now();
  idle.pendingPromptLine = promptLine;
  idle.pendingDispatchSpeculative = effectiveSpeculative;
  idle.pendingDispatchProposalMode = motherV2CurrentIntentMode(idle.intent);
  if (effectiveSpeculative) {
    idle.speculativePrefetchInFlight = true;
    idle.speculativePrefetchReadyMode = null;
    state.lastAction = "Mother Suggestion";
    state.pendingMotherDraft = null;
    state.expectingArtifacts = false;
  } else {
    state.pendingMotherDraft = {
      sourceIds: motherV2RoleContextIds(),
      startedAt: Date.now(),
    };
    state.lastAction = "Mother Suggestion";
    state.expectingArtifacts = true;
    setImageFxActive(true, "Mother Draft");
    portraitWorking("Mother Draft", {
      providerOverride: dispatchProvider,
      forceProvider: true,
    });
    setStatus("Mother: draftingâ€¦");
  }
  await maybeOverrideEngineImageModel(selectedModel);
  motherIdleArmDispatchTimeout(
    MOTHER_GENERATION_TIMEOUT_MS,
    `Mother draft timed out after ${Math.round((MOTHER_GENERATION_TIMEOUT_MS + MOTHER_GENERATION_TIMEOUT_EXTENSION_MS) / 1000)}s.`,
    { allowExtension: true }
  );
  const benchmarkTrialId = promptBenchmarkRegisterDispatch({
    strategy: promptComposer.strategy,
    model: selectedModel,
    promptChars: promptComposer.promptChars,
    constraintCount: promptComposer.constraintCount,
  });
  const sentViaPayload = await motherV2DispatchViaImagePayload(compiled, promptLine, { selectedModel }).catch(() => false);
  if (!sentViaPayload) {
    if (benchmarkTrialId) {
      promptBenchmarkFinalizeTrial(benchmarkTrialId, {
        status: "failed",
        error: "dispatch_failed",
      });
    }
    // Mother drafts must dispatch via structured payload so source_images always includes
    // the full canvas context (uploaded + Mother-generated images).
    motherIdleHandleGenerationFailed("Mother could not start drafting payload.", {
      speculative: effectiveSpeculative,
    });
    return false;
  }
  return true;
}

async function motherIdleHandleSuggestionArtifact({ id, path, receiptPath = null, versionId = null } = {}) {
  if (!id || !path) return false;
  const idle = state.motherIdle;
  if (!idle) return false;
  const isSpeculativeIntentDispatch =
    idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
    Boolean(idle.pendingDispatchSpeculative);
  if (!(idle.phase === MOTHER_IDLE_STATES.DRAFTING || isSpeculativeIntentDispatch)) return false;
  if (!idle.pendingDispatchToken && !idle.pendingGeneration) return false;

  const dispatchWasSpeculative = Boolean(idle.pendingDispatchSpeculative);
  const dispatchMode = motherV2NormalizeTransformationMode(
    idle.pendingDispatchProposalMode || idle.intent?.transformation_mode
  );
  const incomingVersionId = String(versionId || "").trim() || null;
  if (!motherIdleDispatchVersionMatches(incomingVersionId)) {
    if (incomingVersionId) motherIdleRememberIgnoredVersion(incomingVersionId);
    return false;
  }
  if (Number(idle.pendingActionVersion) !== Number(idle.actionVersion)) {
    motherV2MarkStale({
      stage: "artifact_created",
      incoming_version_id: incomingVersionId,
      pending_action_version: Number(idle.pendingActionVersion) || 0,
    });
    removeFile(path).catch(() => {});
    if (receiptPath) removeFile(receiptPath).catch(() => {});
    idle.pendingGeneration = false;
    if (!idle.pendingVersionId && incomingVersionId) idle.pendingVersionId = incomingVersionId;
    motherIdleResetDispatchCorrelation({ rememberPendingVersion: true });
    idle.pendingDispatchToken = 0;
    idle.pendingDispatchSpeculative = false;
    idle.pendingDispatchProposalMode = null;
    idle.pendingPromptCompileSpeculative = false;
    idle.speculativePrefetchInFlight = false;
    idle.dispatchTimeoutExtensions = 0;
    state.pendingMotherDraft = null;
    state.expectingArtifacts = false;
    restoreEngineImageModelIfNeeded();
    setImageFxActive(false);
    updatePortraitIdle();
    return true;
  }

  clearMotherIdleDispatchTimeout();
  idle.pendingGeneration = false;
  if (!idle.pendingVersionId && incomingVersionId) idle.pendingVersionId = incomingVersionId;
  motherIdleResetDispatchCorrelation({ rememberPendingVersion: true });
  idle.pendingDispatchToken = 0;
  idle.pendingDispatchSpeculative = false;
  idle.pendingDispatchProposalMode = null;
  idle.pendingPromptCompileSpeculative = false;
  idle.speculativePrefetchInFlight = false;
  idle.dispatchTimeoutExtensions = 0;
  state.pendingMotherDraft = null;
  idle.generatedImageId = id;
  idle.generatedVersionId = incomingVersionId || null;
  idle.lastSuggestionAt = Date.now();
  idle.hasGeneratedSinceInteraction = true;
  idle.suppressFailureUntil = idle.lastSuggestionAt + MOTHER_V2_SINGLE_RESULT_GUARD_WINDOW_MS;
  state.expectingArtifacts = false;
  restoreEngineImageModelIfNeeded();
  setImageFxActive(false);
  updatePortraitIdle();

  // Keep reroll simple: one active draft at a time.
  for (const draft of Array.isArray(idle.drafts) ? idle.drafts : []) {
    if (String(draft?.id || "") === String(id)) continue;
    if (draft?.path) removeFile(String(draft.path)).catch(() => {});
    if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
  }
  const draft = {
    id: String(id),
    path: String(path),
    receiptPath: receiptPath ? String(receiptPath) : null,
    versionId: incomingVersionId,
    actionVersion: Number(idle.actionVersion) || 0,
    proposalMode: dispatchMode,
    speculative: dispatchWasSpeculative,
    createdAt: Date.now(),
    receiptMeta: null,
    img: null,
  };
  if (draft.receiptPath) {
    try {
      const payload = JSON.parse(await readTextFile(draft.receiptPath));
      draft.receiptMeta = extractReceiptMeta(payload);
    } catch {
      draft.receiptMeta = null;
    }
  }
  try {
    draft.img = await loadImage(draft.path);
  } catch {
    draft.img = null;
  }
  idle.drafts = [draft];
  idle.selectedDraftId = draft.id;
  idle.hoverDraftId = draft.id;
  if (dispatchWasSpeculative && idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
    const currentMode = motherV2CurrentIntentMode(idle.intent);
    if (dispatchMode !== currentMode) {
      if (draft?.path) removeFile(String(draft.path)).catch(() => {});
      if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
      idle.drafts = [];
      idle.selectedDraftId = null;
      idle.hoverDraftId = null;
      idle.speculativePrefetchReadyMode = null;
      appendMotherTraceLog({
        kind: "speculative_prefetch_discarded",
        traceId: idle.telemetry?.traceId || null,
        actionVersion: Number(idle.actionVersion) || 0,
        proposal_mode: dispatchMode,
        current_mode: currentMode,
      }).catch(() => {});
      renderMotherReadout();
      requestRender();
      return true;
    }
    idle.speculativePrefetchReadyMode = dispatchMode;
    appendMotherTraceLog({
      kind: "speculative_prefetch_ready",
      traceId: idle.telemetry?.traceId || null,
      actionVersion: Number(idle.actionVersion) || 0,
      draft_id: draft.id,
      proposal_mode: dispatchMode,
    }).catch(() => {});
    renderMotherReadout();
    requestRender();
    return true;
  }
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.DRAFT_READY);
  setStatus("Mother: proposal ready.");
  renderMotherReadout();
  appendMotherTraceLog({
    kind: "draft_ready",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    draft_id: draft.id,
    intent_id: idle.intent?.intent_id || null,
    placement_policy: idle.intent?.placement_policy || null,
    optimization_target: motherCurrentOptimizationTarget(),
    proposal_mode: motherV2NormalizeTransformationMode(idle.intent?.transformation_mode),
    proposal_candidates: motherV2ProposalCandidateSummary(idle.intent, { limit: MOTHER_V2_MAX_RANKED_PROPOSALS }),
    proposal_confidence: Number(idle.intent?.confidence) || 0,
  }).catch(() => {});
  if (!isReelSizeLocked()) {
    showToast("Mother proposal ready. âœ“ deploy, âœ• dismiss, R reroll.", "tip", 2200);
  }
  requestRender();
  return true;
}

function motherIdleHandleGenerationFailed(message = null, { speculative = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const speculativeFailure = Boolean(
    speculative ||
      (
        idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
        (idle.pendingDispatchSpeculative || idle.pendingPromptCompileSpeculative || idle.speculativePrefetchInFlight)
      )
  );
  clearMotherIdleDispatchTimeout();
  motherV2ClearLiveProposalRefreshTimer();
  idle.liveProposalUpdating = false;
  motherIdleResetDispatchCorrelation({ rememberPendingVersion: true });
  idle.dispatchTimeoutExtensions = 0;
  idle.pendingGeneration = false;
  idle.pendingPromptCompile = false;
  idle.pendingPromptCompileSpeculative = false;
  idle.pendingIntent = false;
  idle.pendingIntentRequestId = null;
  idle.pendingIntentTransportRetryCount = 0;
  idle.pendingIntentStartedAt = 0;
  idle.pendingIntentUpgradeUntil = 0;
  idle.pendingIntentRealtimePath = null;
  idle.intentRealtimeBusyPath = null;
  idle.intentRealtimeBusyRequestId = null;
  idle.intentRealtimeBusyUntil = 0;
  idle.intentReplayQueued = false;
  idle.intentReplayReason = null;
  idle.pendingIntentPath = null;
  idle.pendingIntentPayload = null;
  idle.pendingDispatchToken = 0;
  idle.pendingDispatchSpeculative = false;
  idle.pendingDispatchProposalMode = null;
  idle.speculativePrefetchInFlight = false;
  state.pendingMotherDraft = null;
  state.expectingArtifacts = false;
  restoreEngineImageModelIfNeeded();
  setImageFxActive(false);
  updatePortraitIdle();
  if (speculativeFailure) {
    idle.speculativePrefetchReadyMode = null;
    appendMotherTraceLog({
      kind: "speculative_prefetch_failed",
      traceId: idle.telemetry?.traceId || null,
      actionVersion: Number(idle.actionVersion) || 0,
      error: message || null,
    }).catch(() => {});
    renderMotherReadout();
    requestRender();
    return;
  }
  motherIdleTransitionTo(MOTHER_IDLE_EVENTS.REJECT);
  if (state.motherIdle?.phase === MOTHER_IDLE_STATES.COOLDOWN) {
    motherV2ArmCooldown({ rejected: true });
  }
  appendMotherTraceLog({
    kind: "generation_failed",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    error: message || null,
  }).catch(() => {});
  if (message) showToast(message, "error", 2600);
}

function motherIdlePrimeDraftFx() {
  const existingStartedAt = Number(state.pendingMotherDraft?.startedAt) || 0;
  state.pendingMotherDraft = {
    sourceIds: motherV2RoleContextIds(),
    startedAt: existingStartedAt > 0 ? existingStartedAt : Date.now(),
  };
  setImageFxActive(true, "Mother Draft");
}

function motherIdleRollbackDraftFxIfDispatchUnarmed() {
  const idle = state.motherIdle;
  if (!idle) return;
  if (idle.phase !== MOTHER_IDLE_STATES.DRAFTING) return;
  if (idle.pendingPromptCompile || idle.pendingGeneration || idle.pendingDispatchToken) return;
  state.pendingMotherDraft = null;
  setImageFxActive(false);
}

async function motherIdleDispatchGeneration() {
  const idle = state.motherIdle;
  if (!idle) return false;
  const allowSpeculative = idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING;
  if (!(idle.phase === MOTHER_IDLE_STATES.DRAFTING || allowSpeculative)) return false;
  if (state.pointer.active) return false;
  if (!allowSpeculative) {
    motherIdlePrimeDraftFx();
  } else {
    state.pendingMotherDraft = null;
  }
  const ok = await ensureEngineSpawned({ reason: "mother_drafting" });
  if (!ok) {
    motherIdleRollbackDraftFxIfDispatchUnarmed();
    return false;
  }
  await motherV2RequestPromptCompile({ speculative: allowSpeculative });
  const dispatchArmed = Boolean(idle.pendingPromptCompile || idle.pendingGeneration || idle.pendingDispatchToken);
  if (!dispatchArmed) {
    motherIdleRollbackDraftFxIfDispatchUnarmed();
    return false;
  }
  return true;
}

function motherV2HasMultiUploadIdleBoost(nowMs = Date.now()) {
  const idle = state.motherIdle;
  if (!idle) return false;
  return (Number(idle.multiUploadIdleBoostUntil) || 0) > nowMs;
}

function motherV2WatchIdleDelayMs(nowMs = Date.now()) {
  return motherV2HasMultiUploadIdleBoost(nowMs) ? MOTHER_V2_MULTI_UPLOAD_WATCH_IDLE_MS : MOTHER_V2_WATCH_IDLE_MS;
}

function motherV2IntentIdleDelayMs(nowMs = Date.now()) {
  return motherV2HasMultiUploadIdleBoost(nowMs) ? MOTHER_V2_MULTI_UPLOAD_INTENT_IDLE_MS : MOTHER_V2_INTENT_IDLE_MS;
}

function motherV2ArmMultiUploadIdleBoost(importCount = 0) {
  const idle = state.motherIdle;
  if (!idle) return;
  const count = Math.max(0, Number(importCount) || 0);
  if (count < 2) return;
  idle.multiUploadIdleBoostUntil = Date.now() + MOTHER_V2_MULTI_UPLOAD_IDLE_BOOST_WINDOW_MS;
  if (idle.phase === MOTHER_IDLE_STATES.OBSERVING && !state.pointer.active) {
    motherIdleArmFirstTimer();
  } else if (idle.phase === MOTHER_IDLE_STATES.WATCHING && !state.pointer.active) {
    motherIdleArmIntentTimer();
  }
}

function motherIdleArmFirstTimer() {
  const idle = state.motherIdle;
  if (!idle) return;
  clearTimeout(idle.firstIdleTimer);
  idle.firstIdleTimer = null;
  clearTimeout(idle.intentIdleTimer);
  idle.intentIdleTimer = null;
  if (idle.blockedUntilUserInteraction) return;
  if (!motherIdleHasArmedCanvas()) return;
  if (state.pointer.active) return;
  if (motherV2InCooldown()) return;
  if (idle.phase !== MOTHER_IDLE_STATES.OBSERVING) return;
  const nowMs = Date.now();
  const watchIdleMs = motherV2WatchIdleDelayMs(nowMs);
  const dueAt = (Number(state.lastInteractionAt) || nowMs) + watchIdleMs;
  const delay = Math.max(25, dueAt - Date.now());
  idle.firstIdleTimer = setTimeout(() => {
    idle.firstIdleTimer = null;
    if (state.motherIdle?.blockedUntilUserInteraction) return;
    if (!motherIdleHasArmedCanvas()) return;
    if (state.pointer.active) return;
    if (motherV2InCooldown()) return;
    const quietFor = Date.now() - (Number(state.lastInteractionAt) || 0);
    const now = Date.now();
    const watchDelayMs = motherV2WatchIdleDelayMs(now);
    if (quietFor < watchDelayMs) {
      motherIdleArmFirstTimer();
      return;
    }
    if (state.motherIdle?.phase !== MOTHER_IDLE_STATES.OBSERVING) return;
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
    renderMotherReadout();
    motherIdleArmIntentTimer();
  }, delay);
}

function motherIdleArmIntentTimer() {
  const idle = state.motherIdle;
  if (!idle) return;
  clearTimeout(idle.intentIdleTimer);
  idle.intentIdleTimer = null;
  if (idle.blockedUntilUserInteraction) return;
  if (!motherIdleHasArmedCanvas()) return;
  if (state.pointer.active) return;
  if (motherV2InCooldown()) return;
  if (idle.phase !== MOTHER_IDLE_STATES.WATCHING) return;
  const nowMs = Date.now();
  const intentIdleMs = motherV2IntentIdleDelayMs(nowMs);
  const quietDueAt = (Number(state.lastInteractionAt) || nowMs) + intentIdleMs;
  const settleDueAt = motherV2UploadSettleDueAtMs();
  const dueAt = Math.max(quietDueAt, settleDueAt || 0);
  const delay = Math.max(0, dueAt - Date.now());
  idle.intentIdleTimer = setTimeout(async () => {
    idle.intentIdleTimer = null;
    if (state.motherIdle?.blockedUntilUserInteraction) return;
    if (!motherIdleHasArmedCanvas()) return;
    if (state.pointer.active) return;
    if (motherV2InCooldown()) return;
    const quietFor = Date.now() - (Number(state.lastInteractionAt) || 0);
    const now = Date.now();
    const intentDelayMs = motherV2IntentIdleDelayMs(now);
    if (quietFor < intentDelayMs) {
      motherIdleArmIntentTimer();
      return;
    }
    if (motherV2UploadSettleRemainingMs(now) > 0) {
      motherIdleArmIntentTimer();
      return;
    }
    if (state.motherIdle?.phase !== MOTHER_IDLE_STATES.WATCHING) return;
    if (motherV2HasMultiUploadIdleBoost(now)) {
      idle.multiUploadIdleBoostUntil = 0;
    }
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
    await motherV2RequestIntentInference();
    renderMotherReadout();
  }, delay);
}

function motherV2CancelInFlight({ reason = "interaction" } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const hadPending =
    Boolean(idle.pendingIntent) ||
    Boolean(idle.pendingPromptCompile) ||
    Boolean(idle.pendingGeneration) ||
    Boolean(idle.pendingDispatchToken);
  if (!hadPending) return;
  idle.cancelArtifactUntil = Date.now() + 14_000;
  idle.cancelArtifactReason = String(reason || "interaction");
  state.pendingMotherDraft = null;
  motherV2ResetInteractionState();
  state.expectingArtifacts = false;
  restoreEngineImageModelIfNeeded();
  setImageFxActive(false);
  updatePortraitIdle();
  appendMotherTraceLog({
    kind: "cancel",
    traceId: idle.telemetry?.traceId || null,
    actionVersion: Number(idle.actionVersion) || 0,
    reason,
  }).catch(() => {});
}

function motherIdleSyncFromInteraction({ userInteraction = false, semantic = true, proposalLiveRefresh = false } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  if (idle.commitMutationInFlight) return;
  if (!motherIdleHasArmedCanvas()) {
    clearMotherIdleTimers({ first: true, takeover: true });
    motherV2ResetInteractionState();
    motherV2ClearIntentAndDrafts({ removeFiles: true });
    if (idle.phase !== MOTHER_IDLE_STATES.OBSERVING) {
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.DISQUALIFY);
    }
    renderMotherReadout();
    return;
  }
  if (userInteraction) {
    if (!semantic) {
      // Non-semantic interactions (viewport motion, focus-only selection changes) should not
      // invalidate Mother state or arm the idle-watch timers.
      return;
    }
    if (idle.blockedUntilUserInteraction) {
      idle.blockedUntilUserInteraction = false;
      appendMotherTraceLog({
        kind: "post_commit_resumed_on_user_interaction",
        traceId: idle.telemetry?.traceId || null,
        actionVersion: Number(idle.actionVersion) || 0,
      }).catch(() => {});
    }
    idle.hasGeneratedSinceInteraction = false;
    idle.generatedImageId = null;
    idle.generatedVersionId = null;
    idle.suppressFailureUntil = 0;
    idle.multiUploadIdleBoostUntil = 0;
    const shouldPreserveLiveProposal = Boolean(
      proposalLiveRefresh &&
      motherV2CanUseLiveProposalRefresh(idle) &&
      (
        idle.phase === MOTHER_IDLE_STATES.OFFERING ||
        idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING ||
        idle.phase === MOTHER_IDLE_STATES.WATCHING ||
        idle.phase === MOTHER_IDLE_STATES.OBSERVING
      )
    );
    idle.actionVersion = (Number(idle.actionVersion) || 0) + 1;
    closeMotherWheelMenu({ immediate: false });
    clearMotherIdleTimers({ first: true, takeover: true });
    motherV2CancelInFlight({ reason: "user_interaction" });
    if (shouldPreserveLiveProposal) {
      motherV2ClearDraftsOnly({ removeFiles: true });
      idle.liveProposalUpdating = true;
      const refreshDelay = state.pointer.active ? MOTHER_V2_LIVE_PROPOSAL_REFRESH_DEBOUNCE_MS : 120;
      motherV2ScheduleLiveProposalRefresh({
        reason: "canvas_structure_edit",
        delayMs: refreshDelay,
      });
    } else if (idle.phase === MOTHER_IDLE_STATES.OFFERING || idle.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
      motherV2ClearIntentAndDrafts({ removeFiles: true });
    }
    motherIdleTransitionTo(MOTHER_IDLE_EVENTS.USER_INTERACTION);
    renderMotherReadout();
  }
  if (idle.phase === MOTHER_IDLE_STATES.OBSERVING && !state.pointer.active) {
    motherIdleArmFirstTimer();
  }
}

function bumpInteraction({ motherHot = true, semantic = true, proposalLiveRefresh = false } = {}) {
  state.lastInteractionAt = Date.now();
  if (motherHot) state.lastMotherHotAt = state.lastInteractionAt;
  // Keep the Mother realtime pulse/video responsive while the user is working.
  const now = state.lastInteractionAt;
  const last = Number(state.mother?.hotSyncAt) || 0;
  if (now - last > 120) {
    state.mother.hotSyncAt = now;
    syncMotherPortrait();
  }
  motherIdleSyncFromInteraction({ userInteraction: true, semantic, proposalLiveRefresh });
}

const USER_EVENT_MAX = 72;
const USER_TELEMETRY_EVENT_MAX = 240;
function recordUserEvent(type, fields = {}, { includeInScoringRing = true } = {}) {
  const t = String(type || "").trim();
  if (!t) return;
  const entry = {
    seq: (state.userEventSeq += 1),
    at_ms: Date.now(),
    type: t,
    ...fields,
  };
  if (!Array.isArray(state.userTelemetryEvents)) state.userTelemetryEvents = [];
  state.userTelemetryEvents.push(entry);
  if (state.userTelemetryEvents.length > USER_TELEMETRY_EVENT_MAX) {
    state.userTelemetryEvents = state.userTelemetryEvents.slice(state.userTelemetryEvents.length - USER_TELEMETRY_EVENT_MAX);
  }
  if (includeInScoringRing) {
    state.userEvents.push(entry);
    if (state.userEvents.length > USER_EVENT_MAX) {
      state.userEvents = state.userEvents.slice(state.userEvents.length - USER_EVENT_MAX);
    }
  }
}

function escapeHtml(value) {
  return String(value || "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function basename(path) {
  if (!path) return "";
  const parts = String(path).split(/[\\/]/);
  return parts[parts.length - 1] || "";
}

function extname(path) {
  const name = basename(path);
  const dot = name.lastIndexOf(".");
  if (dot === -1) return "";
  return name.slice(dot).toLowerCase();
}

function mimeFromPath(path) {
  const ext = extname(path);
  if (ext === ".png") return "image/png";
  if (ext === ".jpg" || ext === ".jpeg") return "image/jpeg";
  if (ext === ".webp") return "image/webp";
  if (ext === ".heic") return "image/heic";
  if (ext === ".mp4") return "video/mp4";
  if (ext === ".mov") return "video/quicktime";
  if (ext === ".webm") return "video/webm";
  return "application/octet-stream";
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function getDpr() {
  return Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
}

function getMultiViewTransform() {
  return {
    scale: Math.max(0.0001, Number(state.multiView?.scale) || 1),
    offsetX: Number(state.multiView?.offsetX) || 0,
    offsetY: Number(state.multiView?.offsetY) || 0,
  };
}

function isFreeformTransformDragKind(kind) {
  return (
    kind === POINTER_KINDS.FREEFORM_MOVE ||
    kind === POINTER_KINDS.FREEFORM_RESIZE ||
    kind === POINTER_KINDS.FREEFORM_ROTATE ||
    kind === POINTER_KINDS.FREEFORM_SKEW
  );
}

function isFreeformTransformPointerDragActive() {
  return Boolean(state.pointer?.active && isFreeformTransformDragKind(state.pointer.kind));
}

function multiRectToScreenRect(rect, transform = getMultiViewTransform()) {
  if (!rect) return null;
  const x = Number(rect.x);
  const y = Number(rect.y);
  const w = Number(rect.w);
  const h = Number(rect.h);
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return null;
  const scale = Math.max(0.0001, Number(transform?.scale) || 1);
  const offsetX = Number(transform?.offsetX) || 0;
  const offsetY = Number(transform?.offsetY) || 0;
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY,
    w: w * scale,
    h: h * scale,
  };
}

let lastHudHeightCssPx = null;
let hudResizeObserver = null;
function syncHudHeightVar() {
  if (!els.canvasWrap || !els.hud) return;
  // "HUD" height should match the central readout shell, not the action grid.
  const hudShell = els.hud.querySelector(".hud-shell") || els.hud;
  const rect = hudShell.getBoundingClientRect();
  const h = Math.max(0, Math.round(rect.height));
  // Avoid setting 0px during early boot/layout churn; it would hide bumpers.
  if (!h) return;
  const next = `${h}px`;
  if (next !== lastHudHeightCssPx) {
    lastHudHeightCssPx = next;
    els.canvasWrap.style.setProperty("--hud-h", next);
  }
}

let lastBrandStripHeightCssPx = null;
let brandStripResizeObserver = null;
function syncBrandStripHeightVar() {
  const el = els.brandStrip;
  if (!el) return;
  const rect = el.getBoundingClientRect();
  const h = Math.max(0, Math.round(rect.height));
  if (!h) return;
  const next = `${h}px`;
  if (next !== lastBrandStripHeightCssPx) {
    lastBrandStripHeightCssPx = next;
    document.documentElement.style.setProperty("--brand-strip-h", next);
  }
}

function ensureCanvasSize() {
  if (!els.canvasWrap || !els.workCanvas || !els.overlayCanvas) return;
  const rect = els.canvasWrap.getBoundingClientRect();
  const dpr = getDpr();
  const width = Math.max(1, Math.floor(rect.width * dpr));
  const height = Math.max(1, Math.floor(rect.height * dpr));
  if (els.workCanvas.width !== width || els.workCanvas.height !== height) {
    els.workCanvas.width = width;
    els.workCanvas.height = height;
    if (els.effectsCanvas) {
      els.effectsCanvas.width = width;
      els.effectsCanvas.height = height;
    }
    els.overlayCanvas.width = width;
    els.overlayCanvas.height = height;
    if (effectsRuntime) {
      effectsRuntime.resize({ width, height, dpr });
    }
    resetViewToFit();
  } else if (effectsRuntime) {
    effectsRuntime.resize({ width, height, dpr });
  }
}

let dprWatchMql = null;
let dprWatchListener = null;
function installDprWatcher() {
  if (!("matchMedia" in window)) return;

  if (dprWatchMql && dprWatchListener) {
    try {
      if (typeof dprWatchMql.removeEventListener === "function") dprWatchMql.removeEventListener("change", dprWatchListener);
      else if (typeof dprWatchMql.removeListener === "function") dprWatchMql.removeListener(dprWatchListener);
    } catch {
      // ignore
    }
  }

  // Watch DPR changes even when layout size doesn't change (multi-monitor scaling / backing scale changes).
  const dpr = window.devicePixelRatio || 1;
  dprWatchMql = window.matchMedia(`(resolution: ${dpr}dppx)`);
  dprWatchListener = () => {
    ensureCanvasSize();
    requestRender();
    // Re-arm the watcher for the new DPR value.
    installDprWatcher();
  };
  try {
    if (typeof dprWatchMql.addEventListener === "function") dprWatchMql.addEventListener("change", dprWatchListener);
    else if (typeof dprWatchMql.addListener === "function") dprWatchMql.addListener(dprWatchListener);
  } catch {
    // ignore
  }
}

function canvasPointFromEvent(event) {
  const dpr = getDpr();
  // Prefer offsetX/Y to avoid triggering layout (getBoundingClientRect) on hot paths.
  const ox = event?.offsetX;
  const oy = event?.offsetY;
  if (typeof ox === "number" && typeof oy === "number" && Number.isFinite(ox) && Number.isFinite(oy)) {
    return { x: ox * dpr, y: oy * dpr };
  }
  const rect = els.overlayCanvas.getBoundingClientRect();
  const x = (event.clientX - rect.left) * dpr;
  const y = (event.clientY - rect.top) * dpr;
  return { x, y };
}

function canvasCssPointFromEvent(event) {
  const ox = event?.offsetX;
  const oy = event?.offsetY;
  if (typeof ox === "number" && typeof oy === "number" && Number.isFinite(ox) && Number.isFinite(oy)) {
    return { x: ox, y: oy };
  }
  const rect = els.overlayCanvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  return { x, y };
}

function clampCanvasCssPoint(ptCss) {
  const x0 = Number(ptCss?.x);
  const y0 = Number(ptCss?.y);
  const wrap = els.canvasWrap;
  const w = Number(wrap?.clientWidth) || 0;
  const h = Number(wrap?.clientHeight) || 0;
  if (!(w > 0 && h > 0)) {
    return {
      x: Number.isFinite(x0) ? x0 : 0,
      y: Number.isFinite(y0) ? y0 : 0,
    };
  }
  const x = Number.isFinite(x0) ? clamp(x0, 0, w) : Math.round(w * 0.5);
  const y = Number.isFinite(y0) ? clamp(y0, 0, h) : Math.round(h * 0.5);
  return { x, y };
}

function rememberPromptGenerateHoverCss(ptCss) {
  if (!ptCss) return;
  state.promptGenerateHoverCss = clampCanvasCssPoint(ptCss);
}

function currentPromptGenerateAnchorCss(preferred = null) {
  const base = preferred || state.promptGenerateHoverCss || _defaultImportPointCss();
  return clampCanvasCssPoint(base);
}

function canvasScreenCssToWorldCss(ptCss) {
  const p = ptCss || {};
  const x0 = Number(p.x) || 0;
  const y0 = Number(p.y) || 0;
  if (state.canvasMode !== "multi") return { x: x0, y: y0 };
  const ms = Number(state.multiView?.scale) || 1;
  const dpr = getDpr();
  const mxCss = (Number(state.multiView?.offsetX) || 0) / Math.max(dpr, 0.0001);
  const myCss = (Number(state.multiView?.offsetY) || 0) / Math.max(dpr, 0.0001);
  return {
    x: (x0 - mxCss) / Math.max(ms, 0.0001),
    y: (y0 - myCss) / Math.max(ms, 0.0001),
  };
}

function canvasWorldCssToScreenCss(ptWorldCss) {
  const p = ptWorldCss || {};
  const x0 = Number(p.x) || 0;
  const y0 = Number(p.y) || 0;
  if (state.canvasMode !== "multi") return { x: x0, y: y0 };
  const ms = Number(state.multiView?.scale) || 1;
  const dpr = getDpr();
  const mxCss = (Number(state.multiView?.offsetX) || 0) / Math.max(dpr, 0.0001);
  const myCss = (Number(state.multiView?.offsetY) || 0) / Math.max(dpr, 0.0001);
  return {
    x: mxCss + x0 * ms,
    y: myCss + y0 * ms,
  };
}

function canvasToImage(pt) {
  const img = getActiveImage();
  if (!img) return { x: 0, y: 0 };
  if (state.canvasMode === "multi") {
    const ms = state.multiView?.scale || 1;
    const mx = state.multiView?.offsetX || 0;
    const my = state.multiView?.offsetY || 0;
    const rect = img?.id ? state.multiRects.get(img.id) : null;
    if (rect) {
      const iw = img?.img?.naturalWidth || img?.width || rect.w || 1;
      const ih = img?.img?.naturalHeight || img?.height || rect.h || 1;
      const lx = (pt.x - mx) / Math.max(ms, 0.0001);
      const ly = (pt.y - my) / Math.max(ms, 0.0001);
      return {
        x: ((lx - rect.x) * iw) / Math.max(1, rect.w),
        y: ((ly - rect.y) * ih) / Math.max(1, rect.h),
      };
    }
  }
  return {
    x: (pt.x - state.view.offsetX) / state.view.scale,
    y: (pt.y - state.view.offsetY) / state.view.scale,
  };
}

function imageToCanvas(pt) {
  if (state.canvasMode === "multi") {
    const img = getActiveImage();
    const ms = state.multiView?.scale || 1;
    const mx = state.multiView?.offsetX || 0;
    const my = state.multiView?.offsetY || 0;
    const rect = img?.id ? state.multiRects.get(img.id) : null;
    if (img && rect) {
      const iw = img?.img?.naturalWidth || img?.width || rect.w || 1;
      const ih = img?.img?.naturalHeight || img?.height || rect.h || 1;
      const lx = rect.x + (pt.x * rect.w) / Math.max(1, iw);
      const ly = rect.y + (pt.y * rect.h) / Math.max(1, ih);
      return {
        x: mx + lx * ms,
        y: my + ly * ms,
      };
    }
  }
  return {
    x: state.view.offsetX + pt.x * state.view.scale,
    y: state.view.offsetY + pt.y * state.view.scale,
  };
}

function circleImageToCanvasGeom(circle) {
  if (!circle) return { cx: 0, cy: 0, r: 0 };
  const cxImg = Number(circle.cx) || 0;
  const cyImg = Number(circle.cy) || 0;
  const rImg = Math.max(0, Number(circle.r) || 0);
  const c = imageToCanvas({ x: cxImg, y: cyImg });
  const edge = imageToCanvas({ x: cxImg + rImg, y: cyImg });
  const rPx = Math.max(0, Math.hypot(edge.x - c.x, edge.y - c.y));
  return { cx: c.x, cy: c.y, r: rPx };
}

function hitTestCircleMarks(ptCanvas, circles) {
  if (!ptCanvas || !Array.isArray(circles) || circles.length === 0) return null;
  const tol = Math.max(8, Math.round(10 * getDpr()));
  for (let i = circles.length - 1; i >= 0; i -= 1) {
    const circle = circles[i];
    if (!circle) continue;
    const geom = circleImageToCanvasGeom(circle);
    if (!geom.r) continue;
    const dist = Math.hypot(ptCanvas.x - geom.cx, ptCanvas.y - geom.cy);
    if (Math.abs(dist - geom.r) <= tol) return circle;
    if (geom.r < tol && dist <= geom.r + tol) return circle;
  }
  return null;
}

function requestRender() {
  if (state.needsRender) return;
  state.needsRender = true;
  requestAnimationFrame(() => {
    state.needsRender = false;
    render();
  });
}

async function loadImage(path) {
  if (!path) return null;
  const rec = getOrCreateImageCacheRecord(path);
  if (rec.imgPromise) return await rec.imgPromise;
  rec.imgPromise = (async () => {
    // Always use a blob URL to keep the canvas untainted for local edits (toBlob, etc).
    const url = await ensureImageUrl(path);
    return await new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = (err) => reject(err);
      img.src = url;
    });
  })();
  return await rec.imgPromise;
}

function clearImageCache() {
  for (const value of state.imageCache.values()) {
    const url = value?.url;
    if (url) {
      try {
        URL.revokeObjectURL(url);
      } catch {
        // ignore
      }
    }
  }
  state.imageCache.clear();
}

function getActiveImage() {
  if (!state.activeId) return null;
  return state.imagesById.get(state.activeId) || null;
}

function getSelectedIds() {
  const raw = Array.isArray(state.selectedIds) ? state.selectedIds : [];
  const out = [];
  for (const id of raw) {
    const key = String(id || "").trim();
    if (!key) continue;
    if (!out.includes(key)) out.push(key);
  }
  const active = String(state.activeId || "").trim();
  if (active && !out.includes(active)) out.push(active);
  return out;
}

function isVisibleCanvasImageId(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return false;
  if (!state.imagesById.has(id)) return false;
  return !isImageEffectTokenized(id);
}

function getVisibleCanvasImages() {
  return (state.images || []).filter((item) => isVisibleCanvasImageId(item?.id));
}

function getVisibleSelectedIds() {
  return getSelectedIds().filter((id) => isVisibleCanvasImageId(id));
}

function getVisibleActiveId() {
  const activeId = String(state.activeId || "").trim();
  if (!activeId) return null;
  return isVisibleCanvasImageId(activeId) ? activeId : null;
}

function setSelectedIds(nextIds) {
  const out = [];
  for (const id of Array.isArray(nextIds) ? nextIds : []) {
    const key = String(id || "").trim();
    if (!key) continue;
    if (!out.includes(key)) out.push(key);
  }
  state.selectedIds = out;
}

function selectedCount() {
  return getSelectedImages().length;
}

function getSelectedImages({ requireCount = null } = {}) {
  const ids = getSelectedIds();
  const items = ids.map((id) => state.imagesById.get(id)).filter(Boolean);
  if (typeof requireCount === "number") {
    if (items.length !== requireCount) return [];
  }
  return items;
}

function getSelectedImagesActiveFirst({ requireCount = null } = {}) {
  const selected = getSelectedImages();
  const active = getActiveImage();
  if (active?.id) {
    const ordered = [active, ...selected.filter((item) => item?.id && item.id !== active.id)];
    if (typeof requireCount === "number") {
      if (ordered.length !== requireCount) return [];
    }
    return ordered;
  }
  if (typeof requireCount === "number") {
    if (selected.length !== requireCount) return [];
  }
  return selected;
}

function effectTokenForImageId(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return null;
  const tokenId = state.imageEffectTokenByImageId.get(id);
  if (!tokenId) return null;
  const token = state.effectTokensById.get(tokenId) || null;
  if (!token) {
    state.imageEffectTokenByImageId.delete(id);
    return null;
  }
  return token;
}

function isImageEffectTokenized(imageId) {
  const token = effectTokenForImageId(imageId);
  if (!token) return false;
  return String(token.lifecycle || "") !== EFFECT_TOKEN_LIFECYCLE.CONSUMED;
}

function clearEffectTokenForImageId(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return;
  const tokenId = state.imageEffectTokenByImageId.get(id);
  state.imageEffectTokenByImageId.delete(id);
  if (!tokenId) return;
  const token = state.effectTokensById.get(tokenId) || null;
  if (!token) return;
  // Keep other bindings if this token was intentionally shared.
  const stillUsed = Array.from(state.imageEffectTokenByImageId.values()).some((boundId) => String(boundId) === String(tokenId));
  if (!stillUsed) {
    state.effectTokensById.delete(tokenId);
    state.effectTokenApplyLocks.delete(String(tokenId));
  }
}

function clearAllEffectTokens() {
  state.imageEffectTokenByImageId.clear();
  state.effectTokensById.clear();
  state.effectTokenApplyLocks.clear();
  state.effectTokenDrag = null;
}

function syncSelectionForTokenizedImages() {
  const selected = getSelectedIds();
  const visibleSelected = selected.filter((id) => isVisibleCanvasImageId(id));
  if (visibleSelected.length !== selected.length) {
    setSelectedIds(visibleSelected.slice(-3));
  }

  const activeId = String(state.activeId || "").trim();
  if (activeId && isVisibleCanvasImageId(activeId)) return;
  const fallbackSelected = visibleSelected[visibleSelected.length - 1] || null;
  const fallbackAny = getVisibleCanvasImages().slice(-1)[0]?.id || null;
  state.activeId = String(fallbackSelected || fallbackAny || "").trim() || null;
}

function createOrUpdateEffectToken({
  type,
  imageId,
  imagePath,
  palette = [],
  colors = [],
  materials = [],
  emotion = "",
  summary = "",
  source = null,
  model = null,
} = {}) {
  const imageKey = String(imageId || "").trim();
  const tokenType = String(type || "").trim();
  if (!imageKey || !tokenType) return null;
  const existing = effectTokenForImageId(imageKey);
  const tokenId = existing?.id || `fx-${tokenType}-${Date.now()}-${Math.random().toString(16).slice(2, 8)}`;
  const next = createEffectTokenState({
    id: tokenId,
    type: tokenType,
    sourceImageId: imageKey,
    sourceImagePath: String(imagePath || ""),
    palette,
    colors,
    materials,
    emotion,
    summary,
    source,
    model,
    createdAt: existing?.createdAt || Date.now(),
  });
  if (!next) return null;
  state.effectTokensById.set(tokenId, next);
  state.imageEffectTokenByImageId.set(imageKey, tokenId);
  state.effectTokenApplyLocks.delete(tokenId);
  syncSelectionForTokenizedImages();
  renderQuickActions();
  renderHudReadout();
  renderSelectionMeta();
  return next;
}

function effectTokenLabel(token) {
  const type = String(token?.type || "").trim();
  if (type === "extract_dna") return "Extract DNA";
  if (type === "soul_leech") return "Soul Leech";
  return "Effect";
}

function buildEffectTokenEditPrompt(token) {
  const type = String(token?.type || "").trim();
  if (type === "extract_dna") {
    const palette = Array.isArray(token?.palette) ? token.palette.filter(Boolean).slice(0, 6) : [];
    const colors = Array.isArray(token?.colors) ? token.colors.filter(Boolean).slice(0, 6) : [];
    const materials = Array.isArray(token?.materials) ? token.materials.filter(Boolean).slice(0, 6) : [];
    const summary = String(token?.summary || "").trim();
    const parts = [];
    if (summary) parts.push(summary);
    if (palette.length) parts.push(`palette anchors: ${palette.join(", ")}`);
    if (colors.length) parts.push(`dominant colors: ${colors.join(", ")}`);
    if (materials.length) parts.push(`dominant materials/textures: ${materials.join(", ")}`);
    const transfer = parts.length ? parts.join(". ") : "transfer the extracted color and material DNA";
    return (
      "edit the image in place. keep the target subject class, silhouette, geometry, and object boundaries unchanged. " +
      `apply the extracted dna as style/material transfer only: ${transfer}. ` +
      "dna is metaphorical here, not literal content. " +
      "Do not replace the target with the source subject. Do not turn the subject into a DNA strand, helix, genome icon, or abstract ribbon. " +
      "No collage, no split-screen, no double exposure, no extra humans/faces unless already present, no text overlays."
    );
  }
  if (type === "soul_leech") {
    const emotion = String(token?.emotion || "").trim();
    const summary = String(token?.summary || "").trim();
    const essence = summary || (emotion ? `make the scene emotionally ${emotion}` : "shift the image to the extracted emotional tone");
    return (
      `edit the image: ${essence}. Keep scene geometry coherent and photorealistic. ` +
      "Preserve core subject identity and materials unless the emotional change requires subtle lighting/color shifts. " +
      "No collage, no split-screen, no double exposure, no text overlays."
    );
  }
  return "edit the image: refine the image with the selected effect token. Output one coherent image.";
}

async function applyEffectTokenToImage(tokenId, targetId, { fromQueue = false, dispatchId = null } = {}) {
  const dispatchIdOverride = Number(dispatchId) || null;
  const tokenKey = String(tokenId || "").trim();
  const targetKey = String(targetId || "").trim();
  const token = state.effectTokensById.get(tokenKey) || null;
  if (!requireIntentUnlocked()) {
    state.effectTokenApplyLocks.delete(tokenKey);
    if (token && String(token.lifecycle || "") === EFFECT_TOKEN_LIFECYCLE.APPLYING) {
      recoverEffectTokenApply(token);
      requestRender();
    }
    return false;
  }
  const target = state.imagesById.get(targetKey) || null;
  if (!token || !target?.path) {
    state.effectTokenApplyLocks.delete(tokenKey);
    if (token && String(token.lifecycle || "") === EFFECT_TOKEN_LIFECYCLE.APPLYING) {
      recoverEffectTokenApply(token);
      requestRender();
    }
    showToast("Effect apply failed: missing token or target image.", "error", 2600);
    return false;
  }
  if (!isValidEffectDrop(token.sourceImageId, target.id)) {
    state.effectTokenApplyLocks.delete(tokenKey);
    if (String(token.lifecycle || "") === EFFECT_TOKEN_LIFECYCLE.APPLYING) {
      recoverEffectTokenApply(token);
      requestRender();
    }
    showToast("Drop this token onto a different image.", "tip", 1800);
    return false;
  }

  let lock = state.effectTokenApplyLocks.get(tokenKey) || null;
  if (dispatchIdOverride && lock && Number(lock.dispatchId) !== dispatchIdOverride) {
    return false;
  }
  if (dispatchIdOverride && !lock) {
    return false;
  }
  if (!lock) {
    const dispatchId = beginEffectTokenApply(token, targetKey, Date.now());
    if (!dispatchId) return false;
    lock = {
      dispatchId,
      targetImageId: targetKey,
      queued: false,
      startedAt: Date.now(),
    };
    state.effectTokenApplyLocks.set(tokenKey, lock);
    requestRender();
  }
  if (!effectTokenCanDispatchApply(token, lock.dispatchId, targetKey)) {
    return false;
  }

  const actionLabel = effectTokenLabel(token);
  const queueKey = `effect_apply:${token.id}:${target.id}`;
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    lock.queued = true;
    enqueueAction({
      label: `${actionLabel} Apply`,
      key: queueKey,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => applyEffectTokenToImage(token.id, target.id, { fromQueue: true, dispatchId: lock.dispatchId }),
    });
    return true;
  }

  lock.queued = false;
  bumpInteraction({ semantic: false });
  await ensureRun();
  const provider = providerFromModel(
    token.type === "soul_leech" ? ACTION_IMAGE_MODEL.soul_leech_apply : ACTION_IMAGE_MODEL.extract_dna_apply
  );
  setImageFxActive(true, `${actionLabel} Apply`);
  portraitWorking(`${actionLabel} Apply`, { providerOverride: provider || "gemini" });
  beginPendingReplace(target.id, `${actionLabel} Apply`, {
    mode: "effect_token_apply",
    effect_token_id: token.id,
    effect_type: token.type,
    source_image_id: token.sourceImageId || null,
    effect_token_dispatch_id: lock.dispatchId,
  });

  try {
    const ok = await ensureEngineSpawned({ reason: `${actionLabel} apply` });
    if (!ok) throw new Error("Engine unavailable");
    await setEngineActiveImage(target.path);
    const desiredModel = token.type === "soul_leech" ? ACTION_IMAGE_MODEL.soul_leech_apply : ACTION_IMAGE_MODEL.extract_dna_apply;
    await maybeOverrideEngineImageModel(desiredModel || pickGeminiFastImageModel());
    state.expectingArtifacts = true;
    state.lastAction = `${actionLabel} Apply`;
    setStatus(`Engine: ${actionLabel.toLowerCase()} applyâ€¦`);
    showToast(`${actionLabel}: applying to ${target.label || basename(target.path)}â€¦`, "info", 2200);

    const prompt = buildEffectTokenEditPrompt(token);
    await invoke("write_pty", { data: `${prompt}\n` });
    return true;
  } catch (err) {
    state.expectingArtifacts = false;
    state.engineImageModelRestore = null;
    clearPendingReplace();
    state.effectTokenApplyLocks.delete(tokenKey);
    recoverEffectTokenApply(token);
    setImageFxActive(false);
    updatePortraitIdle();
    requestRender();
    throw err;
  }
}

function effectTokenGlyphSizeForRect(rect) {
  const w = Number(rect?.w) || 0;
  const h = Number(rect?.h) || 0;
  return clamp(Math.min(w, h) * 0.35, 40, 116);
}

function effectTokenDisplaySizeForRect(rect, effectType) {
  const normalized = effectTypeFromTokenType(effectType || "extract_dna");
  const base = effectTokenGlyphSizeForRect(rect);
  if (normalized === "extract_dna") return clamp(base * 1.75, 70, 203);
  return base;
}

function effectTokenDefaultDragSize(effectType) {
  const normalized = effectTypeFromTokenType(effectType || "extract_dna");
  return normalized === "extract_dna" ? 130 : 74;
}

async function animateThenApplyEffectToken({
  tokenId,
  targetImageId,
  dispatchId,
  fromX,
  fromY,
} = {}) {
  const token = state.effectTokensById.get(String(tokenId || "").trim()) || null;
  const targetId = String(targetImageId || "").trim();
  if (!token || !targetId) return;
  const targetRect = state.multiRects.get(targetId) || null;
  if (effectsRuntime && targetRect) {
    const transform = getMultiViewTransform();
    const targetScreenRect = multiRectToScreenRect(targetRect, transform);
    const effectType = effectTypeFromTokenType(token.type);
    await effectsRuntime.playDropIntoTarget({
      tokenId: token.id,
      effectType,
      fromX: Number(fromX) || 0,
      fromY: Number(fromY) || 0,
      targetRect: targetScreenRect,
      size: effectTokenDisplaySizeForRect(targetScreenRect, effectType),
      data: token,
    });
  }

  const current = state.effectTokensById.get(String(tokenId || "").trim()) || null;
  if (!current) return;
  if (!effectTokenCanDispatchApply(current, dispatchId, targetId)) return;
  try {
    await applyEffectTokenToImage(current.id, targetId, { dispatchId: Number(dispatchId) || 0 });
  } catch (err) {
    console.error(err);
    state.effectTokenApplyLocks.delete(String(current.id));
    recoverEffectTokenApply(current);
    showToast(err?.message || "Effect apply failed.", "error", 2600);
    requestRender();
    return;
  }
}

async function runExtractDnaFromSelection({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  const selected = getSelectedImages();
  if (!selected.length) {
    showToast("Extract DNA needs at least one selected image.", "tip", 2400);
    return;
  }
  const sources = selected.filter((item) => item?.path);
  if (!sources.length) {
    showToast("Extract DNA failed: missing image paths.", "error", 2600);
    return;
  }
  if (!fromQueue && (isEngineBusy() || isMultiActionRunning() || state.actionQueueActive || state.actionQueue.length)) {
    const sig = sources.map((item) => String(item.id || "")).join(",");
    enqueueAction({
      label: "Extract DNA",
      key: `extract_dna:${sig}`,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runExtractDnaFromSelection({ fromQueue: true }),
    });
    return;
  }

  bumpInteraction();
  if (!state.runDir) await ensureRun();
  const okEngine = await ensureEngineSpawned({ reason: "extract dna" });
  if (!okEngine) return;
  for (const src of sources) {
    if (src?.id) clearEffectTokenForImageId(src.id);
  }
  state.pendingExtractDna = createPendingEffectExtractionState(sources);
  state.lastAction = "Extract DNA";
  setStatus("Director: extracting DNAâ€¦");
  portraitWorking("Extract DNA", { providerOverride: "openai", clearDirector: false });
  if (!suppressReelDnaToasts()) {
    showToast("Extracting DNA from selected image(s)â€¦", "info", 2200);
  }
  renderQuickActions();
  requestRender();

  const args = sources.map((item) => quoteForPtyArg(item.path)).join(" ");
  try {
    await invoke("write_pty", { data: `${PTY_COMMANDS.EXTRACT_DNA} ${args}\n` });
    bumpSessionApiCalls();
  } catch (err) {
    console.error(err);
    state.pendingExtractDna = null;
    setStatus(`Director: extract dna failed (${err?.message || err})`, true);
    showToast("Extract DNA failed to start.", "error", 3200);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runSoulLeechFromSelection({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  const selected = getSelectedImages();
  if (!selected.length) {
    showToast("Soul Leech needs at least one selected image.", "tip", 2400);
    return;
  }
  const sources = selected.filter((item) => item?.path);
  if (!sources.length) {
    showToast("Soul Leech failed: missing image paths.", "error", 2600);
    return;
  }
  if (!fromQueue && (isEngineBusy() || isMultiActionRunning() || state.actionQueueActive || state.actionQueue.length)) {
    const sig = sources.map((item) => String(item.id || "")).join(",");
    enqueueAction({
      label: "Soul Leech",
      key: `soul_leech:${sig}`,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runSoulLeechFromSelection({ fromQueue: true }),
    });
    return;
  }

  bumpInteraction();
  if (!state.runDir) await ensureRun();
  const okEngine = await ensureEngineSpawned({ reason: "soul leech" });
  if (!okEngine) return;
  for (const src of sources) {
    if (src?.id) clearEffectTokenForImageId(src.id);
  }
  state.pendingSoulLeech = createPendingEffectExtractionState(sources);
  state.lastAction = "Soul Leech";
  setStatus("Director: extracting soulâ€¦");
  portraitWorking("Soul Leech", { providerOverride: "openai", clearDirector: false });
  showToast("Extracting soul from selected image(s)â€¦", "info", 2200);
  renderQuickActions();
  requestRender();

  const args = sources.map((item) => quoteForPtyArg(item.path)).join(" ");
  try {
    await invoke("write_pty", { data: `${PTY_COMMANDS.SOUL_LEECH} ${args}\n` });
    bumpSessionApiCalls();
  } catch (err) {
    console.error(err);
    state.pendingSoulLeech = null;
    setStatus(`Director: soul leech failed (${err?.message || err})`, true);
    showToast("Soul Leech failed to start.", "error", 3200);
    updatePortraitIdle();
    renderQuickActions();
  }
}

const CREATE_LAYERS_CHROMA_KEY = Object.freeze({
  r: 0,
  g: 255,
  b: 0,
  tolerance: 38,
  feather: 14,
});

function createSemanticLayerSpecs(imgItem = null) {
  const sourceLabel = String(imgItem?.label || basename(imgItem?.path || "") || "the source image").trim();
  return [
    {
      key: "background",
      label: "Layer 1/3 - Background",
      summary: "background only",
      applyChromaKey: false,
      prompt:
        `edit the image: remove all foreground subjects and handheld props, and reconstruct only the clean background from ${sourceLabel}. ` +
        "keep exact framing and dimensions. output one image. no text, no logos, no collage.",
    },
    {
      key: "subject",
      label: "Layer 2/3 - Main Subject",
      summary: "main subject",
      applyChromaKey: true,
      prompt:
        "edit the image: isolate only the main subject (usually the primary person or hero object). " +
        "exclude detachable props such as balls, tools, bags, instruments, and accessories. " +
        "replace everything else with a flat solid #00FF00 background (pure chroma green), no gradient, no texture, no shadow. " +
        "keep exact framing and dimensions. output one image with clean edges. no text or logos.",
    },
    {
      key: "props",
      label: "Layer 3/3 - Key Props",
      summary: "detachable props",
      applyChromaKey: true,
      prompt:
        "edit the image: isolate only detachable foreground props (for example balls, tools, bags, instruments, accessories). " +
        "remove the main subject. replace everything else with a flat solid #00FF00 background (pure chroma green), no gradient, no texture, no shadow. " +
        "if no detachable props exist, return a full #00FF00 image. keep exact framing and dimensions. output one image with clean edges. no text or logos.",
    },
  ];
}

function applyChromaKeyToCreateLayerCanvas(canvas, chroma = CREATE_LAYERS_CHROMA_KEY) {
  const ctx = canvas?.getContext?.("2d", { willReadFrequently: true });
  const w = Math.max(1, Number(canvas?.width) || 0);
  const h = Math.max(1, Number(canvas?.height) || 0);
  if (!ctx || !w || !h) {
    return { transparent_px: 0, softened_px: 0, total_px: 0 };
  }
  const imageData = ctx.getImageData(0, 0, w, h);
  const data = imageData.data;
  const targetR = clamp(Math.round(Number(chroma?.r) || 0), 0, 255);
  const targetG = clamp(Math.round(Number(chroma?.g) || 0), 0, 255);
  const targetB = clamp(Math.round(Number(chroma?.b) || 0), 0, 255);
  const tol = clamp(Number(chroma?.tolerance) || 38, 0, 255);
  const feather = clamp(Number(chroma?.feather) || 14, 0, 255);
  let transparentPx = 0;
  let softenedPx = 0;

  for (let i = 0; i < data.length; i += 4) {
    const alpha = data[i + 3];
    if (!alpha) continue;
    const dr = data[i] - targetR;
    const dg = data[i + 1] - targetG;
    const db = data[i + 2] - targetB;
    const dist = Math.sqrt(dr * dr + dg * dg + db * db);
    if (dist <= tol) {
      data[i + 3] = 0;
      transparentPx += 1;
      continue;
    }
    if (feather > 0 && dist <= tol + feather) {
      const keep = (dist - tol) / feather;
      const nextAlpha = Math.max(0, Math.min(255, Math.round(alpha * keep)));
      if (nextAlpha < alpha) {
        data[i + 3] = nextAlpha;
        softenedPx += 1;
        if (nextAlpha === 0) transparentPx += 1;
      }
    }
  }
  ctx.putImageData(imageData, 0, 0);
  return {
    transparent_px: transparentPx,
    softened_px: softenedPx,
    total_px: w * h,
  };
}

async function dispatchCreateLayersPass() {
  const pending = state.pendingCreateLayers;
  if (!pending) return false;
  const idx = Math.max(0, Number(pending.nextIndex) || 0);
  const specs = Array.isArray(pending.layerSpecs) ? pending.layerSpecs : [];
  const spec = specs[idx];
  if (!spec) return false;

  const okEngine = await ensureEngineSpawned({ reason: "create layers" });
  if (!okEngine) throw new Error("Engine unavailable");
  await setEngineActiveImage(pending.sourcePath);
  await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.create_layers || pickGeminiImageModel());

  state.expectingArtifacts = true;
  state.lastAction = "Create Layers";
  setStatus(`Director: creating layers (${idx + 1}/${specs.length})â€¦`);
  showToast(`Create Layers: generating ${spec.summary}â€¦`, "info", 1800);
  await invoke("write_pty", { data: `${spec.prompt}\n` });
  return true;
}

function finishCreateLayersFailure(message) {
  state.pendingCreateLayers = null;
  state.expectingArtifacts = false;
  restoreEngineImageModelIfNeeded();
  setImageFxActive(false);
  updatePortraitIdle();
  clearRunningAction("create_layers");
  setStatus(`Director: ${message}`, true);
  showToast(message, "error", 3600);
  renderQuickActions();
  renderHudReadout();
  processActionQueue().catch(() => {});
}

async function handleCreateLayersArtifact(event) {
  const pending = state.pendingCreateLayers;
  if (!pending) return false;
  const artifactId = String(event?.artifact_id || "").trim();
  const imagePath = String(event?.image_path || "").trim();
  if (!artifactId || !imagePath) return false;
  const receiptPath = event?.receipt_path ? String(event.receipt_path) : null;
  const idx = Math.max(0, Number(pending.nextIndex) || 0);
  const specs = Array.isArray(pending.layerSpecs) ? pending.layerSpecs : [];
  const spec = specs[idx] || null;
  if (!spec) return false;

  try {
    const generated = await loadImage(imagePath);
    const w = Math.max(1, Number(generated?.naturalWidth) || 0);
    const h = Math.max(1, Number(generated?.naturalHeight) || 0);
    if (!w || !h) throw new Error("layer artifact dimensions unavailable");

    const out = document.createElement("canvas");
    out.width = w;
    out.height = h;
    const outCtx = out.getContext("2d");
    outCtx.drawImage(generated, 0, 0, w, h);
    const chromaStats = spec.applyChromaKey ? applyChromaKeyToCreateLayerCanvas(out) : null;

    await saveCanvasAsArtifact(out, {
      operation: `create_layers_${String(spec.key || "layer")}`,
      label: String(spec.label || `Layer ${idx + 1}/${specs.length}`),
      meta: {
        source_image_id: String(pending.sourceId || ""),
        source_image_path: String(pending.sourcePath || ""),
        layer_index: idx + 1,
        layer_count: specs.length,
        layer_key: String(spec.key || ""),
        semantic_description: String(spec.summary || ""),
        chroma_key_hex: spec.applyChromaKey ? "#00FF00" : null,
        chroma_key_stats: chromaStats,
        engine_artifact_id: artifactId,
        engine_receipt_path: receiptPath,
        recomposition_note: "Stack in order: Background -> Main Subject -> Key Props.",
      },
      replaceActive: false,
      parentImageId: pending.sourceId,
      select: false,
    });
    const created = state.images[state.images.length - 1];
    if (created?.id) pending.createdIds.push(String(created.id));
    removeFile(imagePath).catch(() => {});
    if (receiptPath) removeFile(receiptPath).catch(() => {});

    pending.nextIndex = idx + 1;
    if (pending.nextIndex < specs.length) {
      await dispatchCreateLayersPass();
      return true;
    }

    const createdIds = Array.isArray(pending.createdIds) ? pending.createdIds.slice(0, 3) : [];
    state.pendingCreateLayers = null;
    state.expectingArtifacts = false;
    restoreEngineImageModelIfNeeded();
    setImageFxActive(false);
    updatePortraitIdle();
    clearRunningAction("create_layers");
    if (createdIds.length) {
      setSelectedIds(createdIds.slice(-3));
      await setActiveImage(createdIds[0], { preserveSelection: true }).catch(() => {});
    }
    setStatus("Director: layers ready");
    showToast(`Create Layers complete: ${createdIds.length} semantic layers generated.`, "tip", 2800);
    renderQuickActions();
    renderHudReadout();
    requestRender();
    processActionQueue().catch(() => {});
    return true;
  } catch (err) {
    console.error(err);
    finishCreateLayersFailure(`Create Layers failed (${err?.message || err}).`);
    return true;
  }
}

async function runCreateLayersFromSelection({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  const selected = getSelectedImagesActiveFirst({ requireCount: 1 });
  const imgItem = selected.length === 1 ? selected[0] : null;
  if (!imgItem?.path) {
    showToast("Create Layers needs exactly one selected image.", "tip", 2400);
    return;
  }
  if (state.pendingCreateLayers) {
    showToast("Create Layers is already running.", "tip", 2200);
    return;
  }

  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Create Layers",
      key: `create_layers:${String(imgItem.id || "")}`,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runCreateLayersFromSelection({ fromQueue: true }),
    });
    return;
  }

  bumpInteraction();
  await ensureRun();
  beginRunningAction("create_layers");
  setImageFxActive(true, "Create Layers");
  state.lastAction = "Create Layers";
  setStatus("Director: creating layersâ€¦");
  portraitWorking("Create Layers", {
    providerOverride: providerFromModel(ACTION_IMAGE_MODEL.create_layers) || "gemini",
    clearDirector: false,
  });
  showToast("Splitting image into semantic layersâ€¦", "info", 2200);
  renderQuickActions();
  requestRender();

  try {
    if (!imgItem.img) {
      imgItem.img = await loadImage(imgItem.path);
      imgItem.width = imgItem.img?.naturalWidth || imgItem.width || null;
      imgItem.height = imgItem.img?.naturalHeight || imgItem.height || null;
    }
    const specs = createSemanticLayerSpecs(imgItem);
    if (!specs.length) throw new Error("no layer specs configured");
    state.pendingCreateLayers = {
      sourceId: String(imgItem.id || ""),
      sourcePath: String(imgItem.path || ""),
      layerSpecs: specs,
      nextIndex: 0,
      createdIds: [],
      startedAt: Date.now(),
    };
    await dispatchCreateLayersPass();
  } catch (err) {
    console.error(err);
    finishCreateLayersFailure(`Create Layers failed (${err?.message || err}).`);
  }
}

function consumePendingEffectExtraction(kind, imagePath) {
  const path = String(imagePath || "").trim();
  const isSoul = String(kind || "") === "soul";
  const pending = isSoul ? state.pendingSoulLeech : state.pendingExtractDna;
  if (!pending) return null;
  if (!path) return null;
  const { matchedImageId, unresolvedCount } = consumePendingEffectSourceSlot(pending, path, Date.now());
  if (unresolvedCount === 0) {
    if (isSoul) state.pendingSoulLeech = null;
    else state.pendingExtractDna = null;
    setStatus(isSoul ? "Director: soul extraction ready" : "Director: dna extraction ready");
    updatePortraitIdle();
    renderQuickActions();
    processActionQueue().catch(() => {});
  }

  return matchedImageId;
}

function resolveExtractionEventImageIdByPath(imagePath) {
  const path = String(imagePath || "").trim();
  if (!path) return null;

  const activeId = String(state.activeId || "").trim();
  if (activeId) {
    const active = state.imagesById.get(activeId) || null;
    if (active?.path && String(active.path) === path) return activeId;
  }

  const selected = getSelectedIds().map((id) => String(id || "").trim()).filter(Boolean);
  for (const id of selected) {
    const item = state.imagesById.get(id) || null;
    if (item?.path && String(item.path) === path) return id;
  }

  const z = Array.isArray(state.freeformZOrder) ? state.freeformZOrder.slice().reverse() : [];
  for (const rawId of z) {
    const id = String(rawId || "").trim();
    if (!id) continue;
    const item = state.imagesById.get(id) || null;
    if (item?.path && String(item.path) === path) return id;
  }

  const images = Array.isArray(state.images) ? state.images.slice().reverse() : [];
  for (const item of images) {
    const id = String(item?.id || "").trim();
    if (!id) continue;
    if (item?.path && String(item.path) === path) return id;
  }
  return null;
}

function pendingEffectUnresolvedSlots(pending) {
  if (!pending || typeof pending !== "object") return [];
  const slots = Array.isArray(pending.sourceSlots) ? pending.sourceSlots : [];
  return slots.filter((slot) => slot && !slot.resolved);
}

function pendingExtractionKindForImageId(imageId) {
  const id = String(imageId || "").trim();
  if (!id) return null;
  const dnaPending = pendingEffectUnresolvedSlots(state.pendingExtractDna).some(
    (slot) => String(slot.imageId || "").trim() === id
  );
  if (dnaPending) return "extract_dna";
  const soulPending = pendingEffectUnresolvedSlots(state.pendingSoulLeech).some(
    (slot) => String(slot.imageId || "").trim() === id
  );
  if (soulPending) return "soul_leech";
  return null;
}

function shouldAnimateEffectVisuals() {
  if (state.canvasMode !== "multi") return false;
  if (pendingEffectUnresolvedSlots(state.pendingExtractDna).length) return true;
  if (pendingEffectUnresolvedSlots(state.pendingSoulLeech).length) return true;
  for (const token of state.effectTokensById.values()) {
    if (!token) continue;
    const life = String(token.lifecycle || "");
    if (life === EFFECT_TOKEN_LIFECYCLE.CONSUMED) continue;
    return true;
  }
  return false;
}

function buildEffectsRuntimeScene() {
  if (state.canvasMode !== "multi") return { extracting: [], tokens: [], drag: null };
  const transform = getMultiViewTransform();
  const extracting = [];
  const tokens = [];

  for (const [imageId, rect] of state.multiRects.entries()) {
    const screenRect = multiRectToScreenRect(rect, transform);
    if (!screenRect) continue;
    const extractionKind = pendingExtractionKindForImageId(imageId);
    if (extractionKind) {
      extracting.push({
        imageId: String(imageId || ""),
        effectType: extractionKind,
        rect: screenRect,
      });
    }
    const token = effectTokenForImageId(imageId);
    if (!token) continue;
    if (String(token.lifecycle || "") === EFFECT_TOKEN_LIFECYCLE.CONSUMED) continue;
    tokens.push({
      tokenId: String(token.id || ""),
      imageId: String(imageId || ""),
      effectType: effectTypeFromTokenType(token.type),
      lifecycle: String(token.lifecycle || EFFECT_TOKEN_LIFECYCLE.READY),
      rect: screenRect,
      palette: Array.isArray(token.palette) ? token.palette.slice(0, 8) : [],
      colors: Array.isArray(token.colors) ? token.colors.slice(0, 8) : [],
      materials: Array.isArray(token.materials) ? token.materials.slice(0, 8) : [],
      emotion: token.emotion ? String(token.emotion) : "",
      summary: token.summary ? String(token.summary) : "",
      sourceImageId: String(token.sourceImageId || ""),
    });
  }

  let drag = null;
  const dragState = state.effectTokenDrag || null;
  if (dragState) {
    const token = state.effectTokensById.get(String(dragState.tokenId || "").trim()) || null;
    const effectType = effectTypeFromTokenType(token?.type || "extract_dna");
    const targetId = String(dragState.targetImageId || "").trim();
    const targetRect = targetId ? state.multiRects.get(targetId) || null : null;
    const targetScreenRect = targetRect ? multiRectToScreenRect(targetRect, transform) : null;
    drag = {
      tokenId: String(dragState.tokenId || ""),
      effectType,
      x: Number(dragState.x) || 0,
      y: Number(dragState.y) || 0,
      size: targetScreenRect
        ? effectTokenDisplaySizeForRect(targetScreenRect, effectType)
        : effectTokenDefaultDragSize(effectType),
      targetRect: targetScreenRect,
      data: token,
    };
  }

  return { extracting, tokens, drag };
}

function syncEffectsRuntimeScene() {
  if (!effectsRuntime) return;
  const suspended = document.hidden || state.canvasMode !== "multi";
  effectsRuntime.setSuspended(suspended);
  if (suspended) {
    effectsRuntime.syncScene({ extracting: [], tokens: [], drag: null });
    return;
  }
  effectsRuntime.syncScene(buildEffectsRuntimeScene());
}

async function selectCanvasImage(imageId, { toggle = false } = {}) {
  const id = String(imageId || "").trim();
  if (!id) return;
  const item = state.imagesById.get(id) || null;
  if (!item) return;

  const current = getSelectedIds();
  const has = current.includes(id);
  let next = current.slice();

  if (!toggle) {
    next = [id];
  } else if (has) {
    // Keep at least one selected image to avoid entering a confusing "no selection" state.
    if (next.length > 1) next = next.filter((v) => v !== id);
  } else {
    next.push(id);
    // Cap multi-select to 3 images (2/3-image abilities).
    if (next.length > 3) next = next.slice(next.length - 3);
  }

  setSelectedIds(next);
  const nextActive = next.includes(id) ? id : next[next.length - 1] || null;
  recordUserEvent("selection_change", {
    canvas_mode: state.canvasMode,
    active_id: nextActive || state.activeId || null,
    selected_ids: next.slice(0, 3),
    toggle: Boolean(toggle),
  });
  if (!nextActive) {
    renderQuickActions();
    renderHudReadout();
    requestRender();
    return;
  }

  if (nextActive === state.activeId) {
    renderQuickActions();
    renderHudReadout();
    requestRender();
    return;
  }

  await setActiveImage(nextActive, { preserveSelection: true }).catch(() => {});
}

function setCanvasMode(_mode) {
  const next = "multi";
  if (state.canvasMode === next) return;
  const prevMode = state.canvasMode;
  state.canvasMode = next;
  recordUserEvent("canvas_mode_set", { prev: prevMode, next });
  const active = String(state.activeId || "").trim();
  if (active && selectedCount() === 0) setSelectedIds([active]);
  state.multiRects.clear();
  state.multiView.scale = 1;
  state.multiView.offsetX = 0;
  state.multiView.offsetY = 0;
  state.pointer.active = false;
  state.selection = null;
  state.lassoDraft = [];
  state.annotateDraft = null;
  state.annotateBox = null;
  hideAnnotatePanel();
  state.circleDraft = null;
  hideMarkPanel();
  chooseSpawnNodes();
  renderFilmstrip();
  scheduleVisionDescribeAll();
  renderSelectionMeta();
  scheduleVisualPromptWrite();
  motherIdleSyncFromInteraction({ userInteraction: false });
  if (effectsRuntime) effectsRuntime.setSuspended(document.hidden || state.canvasMode !== "multi");
  requestRender();
}

function ensureCanvasImageLoaded(item) {
  if (!item || !item.path) return;
  if (item.img) return;
  if (item.imgLoading) return;
  item.imgLoading = true;
  loadImage(item.path)
    .then((img) => {
      item.img = img;
      item.width = img?.naturalWidth || null;
      item.height = img?.naturalHeight || null;
      // One-shot: once we know the real aspect ratio, convert square placeholders into
      // aspect-correct freeform rects (keeps the click-to-place flow feeling intentional).
      if (item?.id) {
        const rect = state.freeformRects.get(item.id) || null;
        const iw = item.width;
        const ih = item.height;
        if (rect && rect.autoAspect && iw && ih) {
          const prevH = Number(rect.h) || 1;
          const nextH = Math.max(1, Math.round(rect.w * (ih / iw)));
          rect.h = nextH;
          // Keep the rect center stable as we switch from placeholder square -> real aspect.
          rect.y = (Number(rect.y) || 0) + Math.round((prevH - nextH) / 2);
          rect.autoAspect = false;
          const wrap = els.canvasWrap;
          const cw = wrap?.clientWidth || 0;
          const ch = wrap?.clientHeight || 0;
          if (cw && ch) {
            const clamped = clampFreeformRectCss(
              rect,
              cw,
              ch,
              freeformWorkspaceClampOptions(cw, ch, { minSize: 44 })
            );
            rect.x = clamped.x;
            rect.y = clamped.y;
            rect.w = clamped.w;
            rect.h = clamped.h;
            rect.autoAspect = clamped.autoAspect;
          }
          scheduleVisualPromptWrite();
          if (intentAmbientActive()) {
            scheduleAmbientIntentInference({ immediate: true, reason: "composition_change", imageIds: [item.id] });
          }
          if (intentModeActive()) {
            scheduleIntentStateWrite();
          }
        }
      }
    })
    .catch((err) => {
      console.warn("Failed to load image for canvas:", err);
    })
    .finally(() => {
      item.imgLoading = false;
      requestRender();
    });
}

function freeformDefaultTileCss(canvasCssW, canvasCssH, { count = null } = {}) {
  const isMobile =
    window.matchMedia && typeof window.matchMedia === "function"
      ? window.matchMedia("(max-width: 980px)").matches
      : false;
  const minDim = Math.max(1, Math.min(Number(canvasCssW) || 0, Number(canvasCssH) || 0));
  const n = Math.max(1, Number.isFinite(Number(count)) ? Math.round(Number(count) || 0) : 1);

  // Default import size: bias larger because most sessions start with 1-3 images.
  // Still clamp to avoid overlap in the auto-layout grid.
  let frac = isMobile ? 0.38 : 0.26;
  if (isMobile) {
    if (n <= 1) frac = 0.62;
    else if (n === 2) frac = 0.48;
    else if (n === 3) frac = 0.44;
    else if (n === 4) frac = 0.40;
  } else {
    if (n <= 1) frac = 0.54;
    else if (n === 2) frac = 0.42;
    else if (n === 3) frac = 0.38;
    else if (n === 4) frac = 0.32;
  }

  const base = Math.round(minDim * frac);
  const minPx = isMobile ? 160 : 220;
  const maxPx = isMobile ? (n <= 1 ? 520 : 420) : n <= 1 ? 680 : 560;

  // Ensure the implied grid (based on n) can fit within the canvas.
  const margin = 14;
  const gapFrac = 0.11;
  let cols = 1;
  if (n === 2) cols = 2;
  else if (n <= 4) cols = 2;
  else cols = 3;
  const rows = Math.ceil(n / cols);
  const availW = Math.max(1, (Number(canvasCssW) || 0) - margin * 2);
  const availH = Math.max(1, (Number(canvasCssH) || 0) - margin * 2);
  const denomW = cols + Math.max(0, cols - 1) * gapFrac;
  const denomH = rows + Math.max(0, rows - 1) * gapFrac;
  const fitMax = Math.floor(Math.min(availW / Math.max(denomW, 0.0001), availH / Math.max(denomH, 0.0001)));

  return clamp(base, minPx, Math.max(minPx, Math.min(maxPx, fitMax)));
}

function ensureFreeformLayoutRectsCss(items, canvasCssW, canvasCssH) {
  const list = Array.isArray(items) ? items : [];
  if (!list.length) return;
  const tile = freeformDefaultTileCss(canvasCssW, canvasCssH, { count: list.length });
  const gap = Math.round(tile * 0.11);
  const margin = 14;

  // Keep z-order stable: start with import order, allow runtime reordering via state.freeformZOrder.
  for (const item of list) {
    if (!item?.id) continue;
    if (!state.freeformZOrder.includes(item.id)) state.freeformZOrder.push(item.id);
  }

  const missing = list.some((item) => item?.id && !state.freeformRects.has(item.id));
  if (!missing) return;

  const n = list.length;
  let cols = 1;
  if (n === 2) cols = 2;
  else if (n <= 4) cols = 2;
  else cols = 3;
  const rows = Math.ceil(n / cols);

  const gridW = cols * tile + (cols - 1) * gap;
  const gridH = rows * tile + (rows - 1) * gap;
  const startX = Math.round((canvasCssW - gridW) * 0.5);
  const startY = Math.round((canvasCssH - gridH) * 0.5);

  for (let i = 0; i < list.length; i += 1) {
    const item = list[i];
    if (!item?.id) continue;
    if (state.freeformRects.has(item.id)) continue;
    const col = i % cols;
    const row = Math.floor(i / cols);
    let x = startX + col * (tile + gap);
    let y = startY + row * (tile + gap);
    x = clamp(Math.round(x), margin, Math.max(margin, Math.round(canvasCssW - tile - margin)));
    y = clamp(Math.round(y), margin, Math.max(margin, Math.round(canvasCssH - tile - margin)));
    state.freeformRects.set(item.id, { x, y, w: tile, h: tile, autoAspect: true });
  }
}

function computeFreeformRectsPx(canvasW, canvasH) {
  const dpr = getDpr();
  const canvasCssW = (Number(canvasW) || 0) / dpr;
  const canvasCssH = (Number(canvasH) || 0) / dpr;
  ensureFreeformLayoutRectsCss(state.images || [], canvasCssW, canvasCssH);

  const rects = new Map();
  for (const imageId of state.freeformZOrder || []) {
    const rectCss = state.freeformRects.get(imageId) || null;
    if (!rectCss) continue;
    rects.set(imageId, {
      x: Math.round((Number(rectCss.x) || 0) * dpr),
      y: Math.round((Number(rectCss.y) || 0) * dpr),
      w: Math.max(1, Math.round((Number(rectCss.w) || 1) * dpr)),
      h: Math.max(1, Math.round((Number(rectCss.h) || 1) * dpr)),
    });
  }
  return rects;
}

function normalizeFreeformRotateDeg(raw) {
  const value = Number(raw);
  if (!Number.isFinite(value)) return 0;
  let out = value % 360;
  if (out > 180) out -= 360;
  if (out <= -180) out += 360;
  return Number(out.toFixed(2));
}

function normalizeFreeformSkewDeg(raw) {
  const value = Number(raw);
  if (!Number.isFinite(value)) return 0;
  return Number(clamp(value, -28, 28).toFixed(2));
}

function readFreeformRectTransform(rectCss = null) {
  return {
    rotateDeg: normalizeFreeformRotateDeg(rectCss?.rotateDeg),
    skewXDeg: normalizeFreeformSkewDeg(rectCss?.skewXDeg),
  };
}

function drawImageRectWithTransform(ctx, img, { x = 0, y = 0, w = 1, h = 1, rotateDeg = 0, skewXDeg = 0 } = {}) {
  if (!ctx || !img) return;
  const rotation = normalizeFreeformRotateDeg(rotateDeg);
  const skew = normalizeFreeformSkewDeg(skewXDeg);
  const rotationRad = (rotation * Math.PI) / 180;
  const skewTan = Math.tan((skew * Math.PI) / 180);
  if (Math.abs(rotation) < 0.001 && Math.abs(skew) < 0.001) {
    ctx.drawImage(img, x, y, w, h);
    return;
  }
  ctx.save();
  ctx.translate(x + w * 0.5, y + h * 0.5);
  if (Math.abs(rotationRad) > 0.00001) ctx.rotate(rotationRad);
  if (Math.abs(skewTan) > 0.00001) ctx.transform(1, 0, skewTan, 1, 0, 0);
  ctx.beginPath();
  ctx.rect(-w * 0.5, -h * 0.5, w, h);
  ctx.clip();
  ctx.drawImage(img, -w * 0.5, -h * 0.5, w, h);
  ctx.restore();
}

function transformedRectPolygonPoints({ x = 0, y = 0, w = 1, h = 1, rotateDeg = 0, skewXDeg = 0 } = {}) {
  const width = Math.max(1, Number(w) || 1);
  const height = Math.max(1, Number(h) || 1);
  const rotation = normalizeFreeformRotateDeg(rotateDeg);
  const skew = normalizeFreeformSkewDeg(skewXDeg);
  const rotationRad = (rotation * Math.PI) / 180;
  const cos = Math.cos(rotationRad);
  const sin = Math.sin(rotationRad);
  const skewTan = Math.tan((skew * Math.PI) / 180);
  const cx = (Number(x) || 0) + width * 0.5;
  const cy = (Number(y) || 0) + height * 0.5;
  const local = [
    { x: -width * 0.5, y: -height * 0.5 },
    { x: width * 0.5, y: -height * 0.5 },
    { x: width * 0.5, y: height * 0.5 },
    { x: -width * 0.5, y: height * 0.5 },
  ];
  return local.map((pt) => {
    const sx = pt.x + skewTan * pt.y;
    const sy = pt.y;
    return {
      x: cx + sx * cos - sy * sin,
      y: cy + sx * sin + sy * cos,
    };
  });
}

function untransformPointForRect(point = null, { x = 0, y = 0, w = 1, h = 1, rotateDeg = 0, skewXDeg = 0 } = {}) {
  const px = Number(point?.x);
  const py = Number(point?.y);
  const width = Math.max(1, Number(w) || 1);
  const height = Math.max(1, Number(h) || 1);
  const cx = (Number(x) || 0) + width * 0.5;
  const cy = (Number(y) || 0) + height * 0.5;
  if (!Number.isFinite(px) || !Number.isFinite(py)) return { x: cx, y: cy };
  const rotation = normalizeFreeformRotateDeg(rotateDeg);
  const skew = normalizeFreeformSkewDeg(skewXDeg);
  if (Math.abs(rotation) < 0.001 && Math.abs(skew) < 0.001) {
    return { x: px, y: py };
  }
  const rotationRad = (rotation * Math.PI) / 180;
  const cos = Math.cos(rotationRad);
  const sin = Math.sin(rotationRad);
  const dx = px - cx;
  const dy = py - cy;
  const rx = dx * cos + dy * sin;
  const ry = -dx * sin + dy * cos;
  const skewTan = Math.tan((skew * Math.PI) / 180);
  const lx = rx - skewTan * ry;
  const ly = ry;
  return {
    x: cx + lx,
    y: cy + ly,
  };
}

function drawPolygonPath(ctx, points = []) {
  if (!ctx || !Array.isArray(points) || points.length < 2) return false;
  ctx.beginPath();
  ctx.moveTo(Number(points[0].x) || 0, Number(points[0].y) || 0);
  for (let i = 1; i < points.length; i += 1) {
    ctx.lineTo(Number(points[i].x) || 0, Number(points[i].y) || 0);
  }
  ctx.closePath();
  return true;
}

function clampFreeformRectCss(rectCss, canvasCssW, canvasCssH, { margin = 14, minSize = 44 } = {}) {
  const w = Math.max(minSize, Math.round(Number(rectCss?.w) || 0));
  const h = Math.max(minSize, Math.round(Number(rectCss?.h) || 0));
  const maxX = Math.max(margin, Math.round((Number(canvasCssW) || 0) - w - margin));
  const maxY = Math.max(margin, Math.round((Number(canvasCssH) || 0) - h - margin));
  return {
    x: clamp(Math.round(Number(rectCss?.x) || 0), margin, maxX),
    y: clamp(Math.round(Number(rectCss?.y) || 0), margin, maxY),
    w,
    h,
    autoAspect: Boolean(rectCss?.autoAspect),
    rotateDeg: normalizeFreeformRotateDeg(rectCss?.rotateDeg),
    skewXDeg: normalizeFreeformSkewDeg(rectCss?.skewXDeg),
  };
}

function freeformWorkspaceClampOptions(canvasCssW, canvasCssH, { minSize = 44 } = {}) {
  const span = Math.max(1, Math.round(Math.max(Number(canvasCssW) || 0, Number(canvasCssH) || 0)));
  // Allow drag/resize across a wide off-screen workspace; avoid a hard wall at the visible canvas edge.
  const workspaceMargin = -Math.max(2000, span * 4);
  return { margin: workspaceMargin, minSize };
}

function hitTestFreeformCornerHandleWithPad(ptCanvas, rectPx, padPx = 0, rectTransform = null) {
  if (!ptCanvas || !rectPx) return null;
  const dpr = getDpr();
  const hs = Math.max(10, Math.round(10 * dpr));
  const r = Math.round(hs / 2) + Math.max(0, Math.round(Number(padPx) || 0));
  const transform = readFreeformRectTransform(rectTransform);
  const transformedCorners = transformedRectPolygonPoints({
    x: rectPx.x,
    y: rectPx.y,
    w: rectPx.w,
    h: rectPx.h,
    rotateDeg: transform.rotateDeg,
    skewXDeg: transform.skewXDeg,
  });
  const corners = Array.isArray(transformedCorners) && transformedCorners.length === 4
    ? [
        { id: "nw", x: transformedCorners[0].x, y: transformedCorners[0].y },
        { id: "ne", x: transformedCorners[1].x, y: transformedCorners[1].y },
        { id: "se", x: transformedCorners[2].x, y: transformedCorners[2].y },
        { id: "sw", x: transformedCorners[3].x, y: transformedCorners[3].y },
      ]
    : [
        { id: "nw", x: rectPx.x, y: rectPx.y },
        { id: "ne", x: rectPx.x + rectPx.w, y: rectPx.y },
        { id: "sw", x: rectPx.x, y: rectPx.y + rectPx.h },
        { id: "se", x: rectPx.x + rectPx.w, y: rectPx.y + rectPx.h },
      ];
  for (const c of corners) {
    if (Math.abs(ptCanvas.x - c.x) <= r && Math.abs(ptCanvas.y - c.y) <= r) return c.id;
  }
  return null;
}

function hitTestAnyFreeformCornerHandle(ptCanvas, { padPx = 0 } = {}) {
  if (!ptCanvas) return null;
  const ms = state.multiView?.scale || 1;
  const mx = state.multiView?.offsetX || 0;
  const my = state.multiView?.offsetY || 0;
  const x = (ptCanvas.x - mx) / Math.max(ms, 0.0001);
  const y = (ptCanvas.y - my) / Math.max(ms, 0.0001);
  const entries = Array.from(state.multiRects.entries());
  for (let i = entries.length - 1; i >= 0; i -= 1) {
    const [id, rect] = entries[i];
    if (isImageEffectTokenized(id)) continue;
    if (!rect) continue;
    const rectTransform = state.freeformRects.get(id) || null;
    const corner = hitTestFreeformCornerHandleWithPad({ x, y }, rect, padPx, rectTransform);
    if (!corner) continue;
    return { id, corner };
  }
  return null;
}

function resizeFreeformRectFromCorner(startRectCss, corner, pointerCss, canvasCssW, canvasCssH, clampOpts = {}) {
  const start = startRectCss || {};
  const x0 = Number(start.x) || 0;
  const y0 = Number(start.y) || 0;
  const w0 = Math.max(1, Number(start.w) || 1);
  const h0 = Math.max(1, Number(start.h) || 1);
  const x1 = x0 + w0;
  const y1 = y0 + h0;

  const px = Number(pointerCss?.x) || 0;
  const py = Number(pointerCss?.y) || 0;

  let fx = x0;
  let fy = y0;
  let sx = 1;
  let sy = 1;
  if (corner === "nw") {
    fx = x1;
    fy = y1;
    sx = -1;
    sy = -1;
  } else if (corner === "ne") {
    fx = x0;
    fy = y1;
    sx = 1;
    sy = -1;
  } else if (corner === "sw") {
    fx = x1;
    fy = y0;
    sx = -1;
    sy = 1;
  } else if (corner === "se") {
    fx = x0;
    fy = y0;
    sx = 1;
    sy = 1;
  }

  const dx = px - fx;
  const dy = py - fy;
  const aspect = w0 / Math.max(1, h0);
  const absW = Math.max(1, Math.abs(dx));
  const absH = Math.max(1, Math.abs(dy));

  const nextW = Math.max(absW, absH * aspect);
  const nextH = nextW / Math.max(0.001, aspect);

  const cx = fx + sx * nextW;
  const cy = fy + sy * nextH;
  const nx0 = Math.min(fx, cx);
  const ny0 = Math.min(fy, cy);
  const nx1 = Math.max(fx, cx);
  const ny1 = Math.max(fy, cy);

  return clampFreeformRectCss(
    {
      x: nx0,
      y: ny0,
      w: nx1 - nx0,
      h: ny1 - ny0,
      autoAspect: false,
      rotateDeg: start.rotateDeg,
      skewXDeg: start.skewXDeg,
    },
    canvasCssW,
    canvasCssH,
    clampOpts
  );
}

function hitTestMulti(pt, { includeTokenized = false } = {}) {
  if (!pt) return null;
  const ms = state.multiView?.scale || 1;
  const mx = state.multiView?.offsetX || 0;
  const my = state.multiView?.offsetY || 0;
  const x = (pt.x - mx) / Math.max(ms, 0.0001);
  const y = (pt.y - my) / Math.max(ms, 0.0001);
  const entries = Array.from(state.multiRects.entries());
  for (let i = entries.length - 1; i >= 0; i -= 1) {
    const [id, rect] = entries[i];
    if (!includeTokenized && isImageEffectTokenized(id)) continue;
    if (!rect) continue;
    const rectTransform = state.freeformRects.get(id) || null;
    const localPoint = untransformPointForRect(
      { x, y },
      {
        x: rect.x,
        y: rect.y,
        w: rect.w,
        h: rect.h,
        rotateDeg: rectTransform?.rotateDeg,
        skewXDeg: rectTransform?.skewXDeg,
      }
    );
    if (localPoint.x < rect.x || localPoint.x > rect.x + rect.w) continue;
    if (localPoint.y < rect.y || localPoint.y > rect.y + rect.h) continue;
    return id;
  }
  return null;
}

function hitTestMultiWithPad(pt, padPx = 0, { includeTokenized = false } = {}) {
  const padRaw = Math.max(0, Number(padPx) || 0);
  if (!padRaw) return hitTestMulti(pt, { includeTokenized });
  if (!pt) return null;
  const ms = state.multiView?.scale || 1;
  const mx = state.multiView?.offsetX || 0;
  const my = state.multiView?.offsetY || 0;
  const x = (pt.x - mx) / Math.max(ms, 0.0001);
  const y = (pt.y - my) / Math.max(ms, 0.0001);
  // Pad is specified in screen/canvas pixels; convert to local multi-rect space.
  const pad = padRaw / Math.max(ms, 0.0001);
  const entries = Array.from(state.multiRects.entries());
  for (let i = entries.length - 1; i >= 0; i -= 1) {
    const [id, rect] = entries[i];
    if (!includeTokenized && isImageEffectTokenized(id)) continue;
    if (!rect) continue;
    const rectTransform = state.freeformRects.get(id) || null;
    const localPoint = untransformPointForRect(
      { x, y },
      {
        x: rect.x,
        y: rect.y,
        w: rect.w,
        h: rect.h,
        rotateDeg: rectTransform?.rotateDeg,
        skewXDeg: rectTransform?.skewXDeg,
      }
    );
    if (localPoint.x < rect.x - pad || localPoint.x > rect.x + rect.w + pad) continue;
    if (localPoint.y < rect.y - pad || localPoint.y > rect.y + rect.h + pad) continue;
    return id;
  }
  return null;
}

function resetViewToFit() {
  if (state.canvasMode !== "single") return;
  const img = getActiveImage();
  if (!img || !img.img) return;
  const canvas = els.workCanvas;
  if (!canvas) return;
  const cw = canvas.width;
  const ch = canvas.height;
  if (!cw || !ch) return;
  const iw = img.img.naturalWidth || img.width || 1;
  const ih = img.img.naturalHeight || img.height || 1;
  const isMobile =
    window.matchMedia && typeof window.matchMedia === "function"
      ? window.matchMedia("(max-width: 980px)").matches
      : false;
  // Keep the image smaller than full-bleed so the HUD/spawnbar have breathing room.
  const maxWidthFrac = isMobile ? 0.92 : 0.6;
  const maxHeightFrac = isMobile ? 0.9 : 0.86;
  const prevScale = Number(state.view.scale) || 1;
  const prevOffsetX = Number(state.view.offsetX) || 0;
  const prevOffsetY = Number(state.view.offsetY) || 0;
  const scale = Math.min((cw * maxWidthFrac) / iw, (ch * maxHeightFrac) / ih);
  state.view.scale = clamp(scale, 0.05, 20);
  const slackX = cw - iw * state.view.scale;
  const slackY = ch - ih * state.view.scale;
  state.view.offsetX = slackX / 2;

  // Bias images toward the top so the bottom HUD/spawnbar feels like "control surface" space.
  const desiredTop = Math.round(ch * (isMobile ? 0.04 : 0.06));
  state.view.offsetY = slackY <= desiredTop ? slackY / 2 : desiredTop;
  const nextScale = Number(state.view.scale) || 1;
  const nextOffsetX = Number(state.view.offsetX) || 0;
  const nextOffsetY = Number(state.view.offsetY) || 0;
  const fitChanged =
    Math.abs(nextScale - prevScale) > 0.0001 ||
    Math.abs(nextOffsetX - prevOffsetX) > 0.5 ||
    Math.abs(nextOffsetY - prevOffsetY) > 0.5;
  if (fitChanged) {
    recordUserEvent("canvas_fit", {
      actor: "system",
      source: "reset_view_to_fit",
      canvas_mode: state.canvasMode,
      active_id: state.activeId || null,
      scale: nextScale,
      offset_x: nextOffsetX,
      offset_y: nextOffsetY,
    }, { includeInScoringRing: false });
  }
  renderHudReadout();
  scheduleVisualPromptWrite();
  requestRender();
}

function getActiveImageRectCss() {
  const dpr = getDpr();
  if (state.canvasMode === "multi") {
    const ms = state.multiView?.scale || 1;
    const mx = state.multiView?.offsetX || 0;
    const my = state.multiView?.offsetY || 0;
    const rect = state.activeId ? state.multiRects.get(state.activeId) : null;
    if (!rect) return null;
    const rectTransform = readFreeformRectTransform(
      state.activeId ? state.freeformRects.get(state.activeId) || null : null
    );
    return {
      left: (mx + rect.x * ms) / dpr,
      top: (my + rect.y * ms) / dpr,
      width: (rect.w * ms) / dpr,
      height: (rect.h * ms) / dpr,
      rotateDeg: rectTransform.rotateDeg,
      skewXDeg: rectTransform.skewXDeg,
    };
  }
  if (state.canvasMode !== "single") return null;
  const item = getActiveImage();
  const img = item?.img;
  if (!item || !img) return null;
  const iw = img.naturalWidth || item.width || 1;
  const ih = img.naturalHeight || item.height || 1;
  return {
    left: state.view.offsetX / dpr,
    top: state.view.offsetY / dpr,
    width: (iw * state.view.scale) / dpr,
    height: (ih * state.view.scale) / dpr,
    rotateDeg: 0,
    skewXDeg: 0,
  };
}

function getImageRectCss(imageId) {
  if (!imageId) return null;
  if (state.canvasMode === "multi") {
    const dpr = getDpr();
    const ms = state.multiView?.scale || 1;
    const mx = state.multiView?.offsetX || 0;
    const my = state.multiView?.offsetY || 0;
    const rect = state.multiRects.get(imageId) || null;
    if (!rect) return null;
    const rectTransform = readFreeformRectTransform(state.freeformRects.get(imageId) || null);
    return {
      left: (mx + rect.x * ms) / dpr,
      top: (my + rect.y * ms) / dpr,
      width: (rect.w * ms) / dpr,
      height: (rect.h * ms) / dpr,
      rotateDeg: rectTransform.rotateDeg,
      skewXDeg: rectTransform.skewXDeg,
    };
  }
  if (state.canvasMode !== "single") return null;
  if (state.activeId !== imageId) return null;
  return getActiveImageRectCss();
}

function getImageFxTargets() {
  const swap = state.pendingSwapDna;
  if (swap?.structureId && swap?.surfaceId) return [swap.structureId, swap.surfaceId];

  const blend = state.pendingBlend?.sourceIds;
  if (Array.isArray(blend) && blend.length >= 2) return [blend[0], blend[1]];

  const bridge = state.pendingBridge?.sourceIds;
  if (Array.isArray(bridge) && bridge.length >= 2) return [bridge[0], bridge[1]];

  const createLayersId = state.pendingCreateLayers?.sourceId;
  if (createLayersId) return [createLayersId];

  const replaceId = state.pendingReplace?.targetId;
  if (replaceId) return [replaceId];

  const recastId = state.pendingRecast?.sourceId;
  if (recastId) return [recastId];

  const motherSourceIds = state.pendingMotherDraft?.sourceIds;
  if (Array.isArray(motherSourceIds) && motherSourceIds.length) {
    return Array.from(new Set(motherSourceIds.map((v) => String(v || "").trim()).filter(Boolean)));
  }

  const activeId = state.activeId;
  if (activeId) return [activeId];
  return [];
}

let imageFxDynamicEls = [];

function ensureImageFxOverlays(count = 0) {
  const baseEls = [];
  if (els.imageFx) baseEls.push(els.imageFx);
  if (els.imageFx2) baseEls.push(els.imageFx2);
  const minimumCount = Math.max(baseEls.length, Number(count) || 0);
  const neededDynamic = Math.max(0, minimumCount - baseEls.length);
  const wrap = els.canvasWrap;

  while (imageFxDynamicEls.length < neededDynamic) {
    if (!wrap) break;
    const fx = document.createElement("div");
    fx.className = "image-fx hidden";
    fx.setAttribute("aria-hidden", "true");
    wrap.appendChild(fx);
    imageFxDynamicEls.push(fx);
  }
  while (imageFxDynamicEls.length > neededDynamic) {
    const fx = imageFxDynamicEls.pop();
    if (fx?.parentNode) {
      fx.parentNode.removeChild(fx);
    }
  }
  return [...baseEls, ...imageFxDynamicEls];
}

function hideImageFxOverlays() {
  const overlays = ensureImageFxOverlays(0);
  for (const fx of overlays) {
    if (!fx) continue;
    fx.classList.add("hidden");
    fx.style.width = "0px";
    fx.style.height = "0px";
    fx.style.transform = "none";
  }
}

function updateImageFxRect() {
  const targets = getImageFxTargets();
  const overlays = ensureImageFxOverlays(Math.max(1, targets.length));
  if (!overlays.length) return;
  if (!state.imageFx?.active) {
    hideImageFxOverlays();
    return;
  }

  const setRect = (el, rect) => {
    if (!el) return;
    if (!rect) {
      el.style.width = "0px";
      el.style.height = "0px";
      el.style.transform = "none";
      return;
    }
    const rotateDeg = Number(rect.rotateDeg) || 0;
    const skewXDeg = Number(rect.skewXDeg) || 0;
    el.style.left = `${rect.left.toFixed(2)}px`;
    el.style.top = `${rect.top.toFixed(2)}px`;
    el.style.width = `${Math.max(0, rect.width).toFixed(2)}px`;
    el.style.height = `${Math.max(0, rect.height).toFixed(2)}px`;
    el.style.transformOrigin = "50% 50%";
    el.style.transform =
      Math.abs(rotateDeg) > 0.001 || Math.abs(skewXDeg) > 0.001
        ? `rotate(${rotateDeg.toFixed(2)}deg) skewX(${skewXDeg.toFixed(2)}deg)`
        : "none";
  };

  const fallbackRect = getActiveImageRectCss();
  overlays.forEach((fx, idx) => {
    const targetId = targets[idx] || null;
    const rect = targetId ? getImageRectCss(targetId) : idx === 0 ? fallbackRect : null;
    fx.classList.toggle("hidden", !rect);
    setRect(fx, rect);
  });
}

function setImageFxActive(active, label = null) {
  state.imageFx.active = Boolean(active);
  state.imageFx.label = label || null;
  if (state.imageFx.active) {
    updateImageFxRect();
  } else {
    hideImageFxOverlays();
  }
  requestRender();
}

function beginPendingReplace(targetId, label, extra = null) {
  if (!targetId) return;
  const payload = { targetId, startedAt: Date.now(), label: label || null };
  if (extra && typeof extra === "object") {
    for (const [key, value] of Object.entries(extra)) {
      // Prevent accidental override of the core routing keys.
      if (key === "targetId" || key === "startedAt") continue;
      payload[key] = value;
    }
  }
  state.pendingReplace = payload;
}

function clearPendingReplace() {
  state.pendingReplace = null;
}

function beginRunningAction(key) {
  const k = String(key || "").trim();
  if (!k) return;
  state.runningActionKey = k;
  renderQuickActions();
}

function clearRunningAction(key = null) {
  if (key && state.runningActionKey !== key) return;
  state.runningActionKey = null;
  renderQuickActions();
}

function clearSelection() {
  state.selection = null;
  state.lassoDraft = [];
  state.annotateDraft = null;
  state.annotateBox = null;
  state.circleDraft = null;
  hideMarkPanel();
  hideAnnotatePanel();
  hidePromptGeneratePanel();
  setTip(DEFAULT_TIP);
  scheduleVisualPromptWrite();
  requestRender();
  renderSelectionMeta();
  renderHudReadout();
}

function setTool(tool) {
  const allowed = new Set(["annotate", "pan", "lasso"]);
  if (!allowed.has(tool)) return;
  const prevTool = state.tool;
  if (tool !== "annotate") {
    state.annotateDraft = null;
    state.annotateBox = null;
    hideAnnotatePanel();
    hidePromptGeneratePanel();
    state.circleDraft = null;
    hideMarkPanel();
  }
  state.tool = tool;
  if (prevTool !== tool) {
    recordUserEvent("tool_set", { tool });
  }
  renderQuickActions();
  renderSelectionMeta();
  renderHudReadout();
  if (tool === "lasso") {
    setTip("Lasso your product, then click Studio White. Or skip lasso and let the model infer the subject.");
  } else if (tool === "annotate") {
    setTip("Annotate: drag a box to edit. Hold Shift to draw a red circle label.");
  } else {
    setTip(DEFAULT_TIP);
  }
  scheduleVisualPromptWrite();
}

function showDropHint(show) {
  if (!els.dropHint) return;
  els.dropHint.classList.toggle("hidden", !show);
}

function renderSelectionMeta() {
  const img = getActiveImage();
  if (!img) {
    if (els.selectionMeta) els.selectionMeta.textContent = "No image selected.";
    renderHudReadout();
    return;
  }
  const name = basename(img.path);
  const sel = state.selection ? `${state.selection.points.length} pts` : "none";
  if (els.selectionMeta) els.selectionMeta.textContent = `${name}\nSelection: ${sel}`;
  renderHudReadout();
}

function hideImageMenu() {
  if (!els.imageMenu) return;
  els.imageMenu.classList.add("hidden");
  state.imageMenuTargetId = null;
}

function showImageMenuAt(ptCss, imageId) {
  const menu = els.imageMenu;
  const wrap = els.canvasWrap;
  if (!menu || !wrap || !ptCss || !imageId) return;
  state.imageMenuTargetId = String(imageId);
  menu.classList.remove("hidden");

  const dx = 12;
  const dy = 12;
  const x0 = (Number(ptCss.x) || 0) + dx;
  const y0 = (Number(ptCss.y) || 0) + dy;

  menu.style.left = `${x0}px`;
  menu.style.top = `${y0}px`;

  requestAnimationFrame(() => {
    const mw = menu.offsetWidth || 0;
    const mh = menu.offsetHeight || 0;
    const maxX = Math.max(8, wrap.clientWidth - mw - 8);
    const maxY = Math.max(8, wrap.clientHeight - mh - 8);
    const x = clamp(x0, 8, maxX);
    const y = clamp(y0, 8, maxY);
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
  });
}

function hideAnnotatePanel() {
  if (!els.annotatePanel) return;
  els.annotatePanel.classList.add("hidden");
}

function promptGenerateAvailableModels() {
  if (!els.imageModel) return [];
  return Array.from(els.imageModel.options || [])
    .map((opt) => String(opt?.value || "").trim())
    .filter(Boolean);
}

function resolvePromptGenerateModel(rawModel = "") {
  const requested = String(rawModel || "").trim();
  const available = promptGenerateAvailableModels();
  if (!available.length) {
    return requested || settings.imageModel || DEFAULT_IMAGE_MODEL;
  }
  if (requested && available.includes(requested)) return requested;
  if (settings.imageModel && available.includes(settings.imageModel)) return settings.imageModel;
  return available[0];
}

function capturePromptGenerateDraftFromUi() {
  const prompt = String(els.promptGenerateText?.value || "").trim();
  const model = resolvePromptGenerateModel(els.promptGenerateModel?.value || "");
  state.promptGenerateDraft = { prompt, model };
}

function hidePromptGeneratePanel({ clearDraft = false } = {}) {
  if (!els.promptGeneratePanel) return;
  capturePromptGenerateDraftFromUi();
  if (clearDraft) {
    state.promptGenerateDraft = { prompt: "", model: "" };
    state.promptGenerateDraftAnchor = null;
    if (els.promptGenerateText) els.promptGenerateText.value = "";
  }
  els.promptGeneratePanel.classList.add("hidden");
}

function showPromptGeneratePanel() {
  const panel = els.promptGeneratePanel;
  if (!panel) return;
  const anchorCss = currentPromptGenerateAnchorCss();
  state.promptGenerateDraftAnchor = {
    anchorCss,
    anchorWorldCss: canvasScreenCssToWorldCss(anchorCss),
  };

  const targetModel = resolvePromptGenerateModel(
    state.promptGenerateDraft?.model || settings.imageModel || DEFAULT_IMAGE_MODEL
  );
  if (els.promptGenerateModel) {
    els.promptGenerateModel.innerHTML = "";
    for (const opt of Array.from(els.imageModel?.options || [])) {
      if (!opt?.value) continue;
      const optionEl = document.createElement("option");
      optionEl.value = opt.value;
      optionEl.textContent = opt.textContent || opt.value;
      els.promptGenerateModel.appendChild(optionEl);
    }
    els.promptGenerateModel.value = targetModel;
    if (els.promptGenerateModel.value !== targetModel) {
      const fallbackModel = resolvePromptGenerateModel(targetModel);
      els.promptGenerateModel.value = fallbackModel;
    }
  }

  if (els.promptGenerateText) {
    const draftPrompt = String(state.promptGenerateDraft?.prompt || "");
    els.promptGenerateText.value = draftPrompt;
  }
  if (els.promptGenerateMeta) {
    els.promptGenerateMeta.textContent = "Create a new image (no source image required).";
  }

  panel.style.left = "50%";
  panel.style.top = "50%";
  panel.style.transform = "translate(-50%, -50%)";
  panel.classList.remove("hidden");
  setTimeout(() => {
    try {
      if (els.promptGenerateText) els.promptGenerateText.focus();
    } catch {
      // ignore
    }
  }, 0);
}

function normalizePromptGeneratePrompt(promptText = "") {
  const trimmed = String(promptText || "").trim();
  if (!trimmed) return "";
  if (/^(edit|replace)\b/i.test(trimmed)) {
    return `generate a brand-new image from text only: ${trimmed}`;
  }
  return trimmed;
}

async function runPromptGenerate({ prompt = "", model = "", fromQueue = false, anchorCss = null, anchorWorldCss = null } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();

  const rawPrompt = String(prompt || "").trim();
  if (!rawPrompt) {
    showToast("Prompt Generate: enter a prompt.", "tip", 2200);
    return;
  }
  const normalizedPrompt = normalizePromptGeneratePrompt(rawPrompt);
  const selectedModel = resolvePromptGenerateModel(model || settings.imageModel || DEFAULT_IMAGE_MODEL);
  const resolvedAnchorCss = currentPromptGenerateAnchorCss(anchorCss);
  const resolvedAnchorWorldCss =
    anchorWorldCss && Number.isFinite(Number(anchorWorldCss.x)) && Number.isFinite(Number(anchorWorldCss.y))
      ? {
          x: Number(anchorWorldCss.x) || 0,
          y: Number(anchorWorldCss.y) || 0,
        }
      : canvasScreenCssToWorldCss(resolvedAnchorCss);

  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Prompt Generate",
      key: "prompt_generate",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () =>
        runPromptGenerate({
          prompt: rawPrompt,
          model: selectedModel,
          fromQueue: true,
          anchorCss: resolvedAnchorCss,
          anchorWorldCss: resolvedAnchorWorldCss,
        }),
    });
    return;
  }

  await ensureRun();
  setImageFxActive(true, "Prompt Generate");
  portraitWorking("Prompt Generate", {
    providerOverride: providerFromModel(selectedModel) || providerFromModel(settings.imageModel),
  });

  try {
    const ok = await ensureEngineSpawned({ reason: "prompt generate" });
    if (!ok) throw new Error("Engine unavailable");

    await maybeOverrideEngineImageModel(selectedModel);

    state.expectingArtifacts = true;
    state.pendingPromptGenerate = {
      prompt: normalizedPrompt,
      model: selectedModel,
      startedAt: Date.now(),
      anchorCss: resolvedAnchorCss,
      anchorWorldCss: resolvedAnchorWorldCss,
    };
    state.lastAction = "Prompt Generate";
    setStatus("Engine: prompt generateâ€¦");
    showToast(`Generating with ${selectedModel}â€¦`, "info", 2200);
    renderQuickActions();
    requestRender();
    await invoke("write_pty", { data: `${normalizedPrompt}\n` });
  } catch (err) {
    state.pendingPromptGenerate = null;
    state.expectingArtifacts = false;
    restoreEngineImageModelIfNeeded();
    setImageFxActive(false);
    updatePortraitIdle();
    renderQuickActions();
    throw err;
  }
}

async function runPromptGenerateFromPanel() {
  const rawPrompt = String(els.promptGenerateText?.value || "").trim();
  const selectedModel = resolvePromptGenerateModel(
    els.promptGenerateModel?.value || state.promptGenerateDraft?.model || settings.imageModel || DEFAULT_IMAGE_MODEL
  );
  const draftAnchor = state.promptGenerateDraftAnchor
    ? {
        anchorCss: state.promptGenerateDraftAnchor.anchorCss
          ? {
              x: Number(state.promptGenerateDraftAnchor.anchorCss.x) || 0,
              y: Number(state.promptGenerateDraftAnchor.anchorCss.y) || 0,
            }
          : null,
        anchorWorldCss: state.promptGenerateDraftAnchor.anchorWorldCss
          ? {
              x: Number(state.promptGenerateDraftAnchor.anchorWorldCss.x) || 0,
              y: Number(state.promptGenerateDraftAnchor.anchorWorldCss.y) || 0,
            }
          : null,
      }
    : null;
  state.promptGenerateDraft = {
    prompt: rawPrompt,
    model: selectedModel,
  };
  if (!rawPrompt) {
    showToast("Prompt Generate: enter a prompt.", "tip", 2200);
    if (els.promptGenerateText) {
      try {
        els.promptGenerateText.focus();
      } catch {
        // ignore
      }
    }
    return;
  }
  hidePromptGeneratePanel();
  await runPromptGenerate({
    prompt: rawPrompt,
    model: selectedModel,
    anchorCss: draftAnchor?.anchorCss || null,
    anchorWorldCss: draftAnchor?.anchorWorldCss || null,
  });
}

function _annotateBoxToCssRect(box) {
  if (!box) return null;
  const dpr = getDpr();
  const a = imageToCanvas({ x: Number(box.x0) || 0, y: Number(box.y0) || 0 });
  const b = imageToCanvas({ x: Number(box.x1) || 0, y: Number(box.y1) || 0 });
  const left = Math.min(a.x, b.x) / dpr;
  const top = Math.min(a.y, b.y) / dpr;
  const right = Math.max(a.x, b.x) / dpr;
  const bottom = Math.max(a.y, b.y) / dpr;
  return { left, top, right, bottom, width: right - left, height: bottom - top };
}

function _normalizeAnnotateBox(box, img) {
  if (!box) return null;
  const x0 = Number(box.x0) || 0;
  const y0 = Number(box.y0) || 0;
  const x1 = Number(box.x1) || 0;
  const y1 = Number(box.y1) || 0;
  let left = Math.min(x0, x1);
  let top = Math.min(y0, y1);
  let right = Math.max(x0, x1);
  let bottom = Math.max(y0, y1);
  const iw = img?.img?.naturalWidth || img?.width || null;
  const ih = img?.img?.naturalHeight || img?.height || null;
  if (iw && ih) {
    left = clamp(left, 0, iw);
    right = clamp(right, 0, iw);
    top = clamp(top, 0, ih);
    bottom = clamp(bottom, 0, ih);
  }
  return { imageId: box.imageId, x0: left, y0: top, x1: right, y1: bottom, at: box.at || Date.now() };
}

function showAnnotatePanelForBox() {
  const panel = els.annotatePanel;
  const wrap = els.canvasWrap;
  const img = getActiveImage();
  const box = state.annotateBox;
  if (!panel || !wrap || !img || !box || box.imageId !== img.id) return;

  // Populate model selector from the main image model dropdown.
  if (els.annotateModel && els.imageModel) {
    els.annotateModel.innerHTML = "";
    for (const opt of Array.from(els.imageModel.options || [])) {
      if (!opt?.value) continue;
      const o = document.createElement("option");
      o.value = opt.value;
      o.textContent = opt.textContent || opt.value;
      els.annotateModel.appendChild(o);
    }
    els.annotateModel.value = settings.imageModel;
  }

  const normalized = _normalizeAnnotateBox(box, img);
  if (!normalized) return;
  const iw = img?.img?.naturalWidth || img?.width || null;
  const ih = img?.img?.naturalHeight || img?.height || null;
  if (els.annotateMeta) {
    if (iw && ih) {
      const xPct = (normalized.x0 / iw) * 100;
      const yPct = (normalized.y0 / ih) * 100;
      const wPct = ((normalized.x1 - normalized.x0) / iw) * 100;
      const hPct = ((normalized.y1 - normalized.y0) / ih) * 100;
      els.annotateMeta.textContent = `Box: x ${xPct.toFixed(1)}% y ${yPct.toFixed(1)}% w ${wPct.toFixed(1)}% h ${hPct.toFixed(1)}%`;
    } else {
      const wPx = Math.max(0, normalized.x1 - normalized.x0);
      const hPx = Math.max(0, normalized.y1 - normalized.y0);
      els.annotateMeta.textContent = `Box: x ${Math.round(normalized.x0)} y ${Math.round(normalized.y0)} w ${Math.round(wPx)} h ${Math.round(hPx)}`;
    }
  }

  // Position near the box, clamped within canvas.
  panel.classList.remove("hidden");
  const rect = _annotateBoxToCssRect(normalized);
  const baseX = rect ? rect.right + 12 : 12;
  const baseY = rect ? rect.top : 12;
  panel.style.left = `${baseX}px`;
  panel.style.top = `${baseY}px`;

  requestAnimationFrame(() => {
    const pw = panel.offsetWidth || 0;
    const ph = panel.offsetHeight || 0;
    const maxX = Math.max(8, wrap.clientWidth - pw - 8);
    const maxY = Math.max(8, wrap.clientHeight - ph - 8);
    let x = clamp(baseX, 8, maxX);
    let y = clamp(baseY, 8, maxY);
    // If it doesn't fit to the right, prefer left of the box.
    if (rect && x >= maxX && rect.left - pw - 12 >= 8) {
      x = clamp(rect.left - pw - 12, 8, maxX);
    }
    panel.style.left = `${x}px`;
    panel.style.top = `${y}px`;
  });

  // Focus input for speed.
  setTimeout(() => {
    try {
      if (els.annotateText) els.annotateText.focus();
    } catch {
      // ignore
    }
  }, 0);
}

function _getCircles(imageId) {
  const key = String(imageId || "");
  if (!key) return [];
  const existing = state.circlesByImageId.get(key);
  return Array.isArray(existing) ? existing : [];
}

function hideMarkPanel() {
  if (!els.markPanel) return;
  els.markPanel.classList.add("hidden");
  state.activeCircle = null;
}

function showMarkPanelForCircle(circle) {
  const panel = els.markPanel;
  const wrap = els.canvasWrap;
  const img = getActiveImage();
  if (!panel || !wrap || !img || !circle || circle.imageId !== img.id) return;

  panel.classList.remove("hidden");
  state.activeCircle = { imageId: circle.imageId, id: circle.id };

  if (els.markTitle) {
    els.markTitle.textContent = "Circle";
  }

  const iw = img?.img?.naturalWidth || img?.width || null;
  const ih = img?.img?.naturalHeight || img?.height || null;
  if (els.markMeta) {
    if (iw && ih) {
      const xPct = (Number(circle.cx) / iw) * 100;
      const yPct = (Number(circle.cy) / ih) * 100;
      const rPct = (Number(circle.r) / Math.max(1, Math.min(iw, ih))) * 100;
      els.markMeta.textContent = `Circle: x ${xPct.toFixed(1)}% y ${yPct.toFixed(1)}% r ${rPct.toFixed(1)}%`;
    } else {
      els.markMeta.textContent = `Circle: x ${Math.round(Number(circle.cx) || 0)} y ${Math.round(Number(circle.cy) || 0)} r ${Math.round(
        Number(circle.r) || 0
      )} (px)`;
    }
  }

  if (els.markText) {
    els.markText.value = String(circle.label || "");
  }

  // Position near the circle (prefer right side), clamped within canvas.
  const dpr = getDpr();
  const c = imageToCanvas({ x: Number(circle.cx) || 0, y: Number(circle.cy) || 0 });
  const edge = imageToCanvas({ x: (Number(circle.cx) || 0) + (Number(circle.r) || 0), y: Number(circle.cy) || 0 });
  const rPx = Math.max(0, Math.hypot(edge.x - c.x, edge.y - c.y));
  const baseX = (c.x + rPx) / dpr + 12;
  const baseY = c.y / dpr - 10;
  panel.style.left = `${baseX}px`;
  panel.style.top = `${baseY}px`;

  requestAnimationFrame(() => {
    const pw = panel.offsetWidth || 0;
    const ph = panel.offsetHeight || 0;
    const maxX = Math.max(8, wrap.clientWidth - pw - 8);
    const maxY = Math.max(8, wrap.clientHeight - ph - 8);
    const x = clamp(baseX, 8, maxX);
    const y = clamp(baseY, 8, maxY);
    panel.style.left = `${x}px`;
    panel.style.top = `${y}px`;
  });

  // Focus input for speed.
  setTimeout(() => {
    try {
      if (els.markText) els.markText.focus();
    } catch {
      // ignore
    }
  }, 0);
}

function updateActiveCircleLabel(label) {
  const sel = state.activeCircle;
  if (!sel?.imageId || !sel?.id) return false;
  const nextLabel = String(label || "").trim();
  const list = _getCircles(sel.imageId).slice();
  const idx = list.findIndex((c) => c && c.id === sel.id);
  if (idx < 0) return false;
  list[idx] = { ...list[idx], label: nextLabel };
  state.circlesByImageId.set(sel.imageId, list);
  scheduleVisualPromptWrite();
  requestRender();
  return true;
}

function deleteActiveCircle() {
  const sel = state.activeCircle;
  if (!sel?.imageId || !sel?.id) return false;
  const list = _getCircles(sel.imageId).slice();
  const next = list.filter((c) => c && c.id !== sel.id);
  state.circlesByImageId.set(sel.imageId, next);
  hideMarkPanel();
  scheduleVisualPromptWrite();
  requestRender();
  return true;
}

const SVG_NS = "http://www.w3.org/2000/svg";
const XLINK_NS = "http://www.w3.org/1999/xlink";

function svgEl(name) {
  return document.createElementNS(SVG_NS, name);
}

function rand01(seed) {
  // Deterministic 0..1 value for a given number seed.
  const x = Math.sin(seed * 999.123) * 43758.5453123;
  return x - Math.floor(x);
}

function hash32(value) {
  // FNV-1a-ish 32-bit hash for stable per-node motion patterns.
  const s = String(value || "");
  let h = 2166136261;
  for (let i = 0; i < s.length; i += 1) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

let larvaRaf = null;
let larvaStartedAt = null;
function stopLarvaAnimator() {
  if (!larvaRaf) return;
  try {
    cancelAnimationFrame(larvaRaf);
  } catch {
    // ignore
  }
  larvaRaf = null;
}

function ensureLarvaAnimator() {
  if (larvaRaf) return;
  if (!state.larvaTargets || state.larvaTargets.length === 0) return;
  if (document.hidden) return;
  if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
  if (larvaStartedAt == null) larvaStartedAt = performance.now();
  const TAU = Math.PI * 2;
  const LOOP_MS = 4000; // Perfect loop: all larva motion repeats exactly every 4s.
  const tick = (now) => {
    if (document.hidden) {
      larvaRaf = null;
      return;
    }
    const targets = state.larvaTargets || [];
    if (targets.length === 0) {
      larvaRaf = null;
      return;
    }
    const phase = ((now - larvaStartedAt) % LOOP_MS) / LOOP_MS; // 0..1
    const w = TAU * phase;
    for (const target of targets) {
      const seed = Number(target?.seed || 0);
      const svg = target?.svgEl;
      const btnEl = target?.btnEl;
      const headEl = target?.headEl;
      const tailEl = target?.tailEl;
      if (target?.exploding) continue;

      if (svg) {
        const tilt = target?.tiltDeg || 0;
        const rotAmp = target?.rotAmp || 0.8;
        const nRot = target?.nRot || 2;
        const nSquish = target?.nSquish || 2;
        const pRot = target?.phaseRot || 0;
        const pSquish = target?.phaseSquish || 0;
        const squishAmp = target?.squishAmp || 0.0065;
        const rot = tilt + rotAmp * Math.sin(w * nRot + pRot + seed * 0.01);
        const squish = 1 + squishAmp * Math.sin(w * nSquish + pSquish + seed * 0.01);
        // Keep the larva "on the surface"; motion reads mostly as head/tail movement.
        svg.style.transform = `rotate(${rot.toFixed(2)}deg) scale(${squish.toFixed(4)})`;
      }

      if (headEl) {
        const nHead = target?.nHead || 2;
        const nHeadRot = target?.nHeadRot || nHead;
        const ampHX = target?.headAmpX || 1.3;
        const ampHY = target?.headAmpY || 0.9;
        const ampHRot = target?.headRotAmp || 8;
        const pHX = target?.phaseHeadX || 0;
        const pHY = target?.phaseHeadY || 0;
        const pHRot = target?.phaseHeadRot || 0;
        const hx = ampHX * Math.sin(w * nHead + pHX + seed * 0.01);
        const hy = ampHY * Math.cos(w * nHead + pHY + seed * 0.01);
        const ha = ampHRot * Math.sin(w * nHeadRot + pHRot + seed * 0.01);
        headEl.setAttribute(
          "transform",
          `translate(${hx.toFixed(2)} ${hy.toFixed(2)}) rotate(${ha.toFixed(2)} 54 44)`
        );
      }

      if (tailEl) {
        const nTail = target?.nTail || 2;
        const nTailRot = target?.nTailRot || nTail;
        const ampTX = target?.tailAmpX || 1.0;
        const ampTY = target?.tailAmpY || 0.7;
        const ampTRot = target?.tailRotAmp || 6;
        const pTX = target?.phaseTailX || 0;
        const pTY = target?.phaseTailY || 0;
        const pTRot = target?.phaseTailRot || 0;
        const tx = ampTX * Math.sin(w * nTail + pTX + seed * 0.01);
        const ty = ampTY * Math.cos(w * nTail + pTY + seed * 0.01);
        const ta = ampTRot * Math.sin(w * nTailRot + pTRot + seed * 0.01);
        tailEl.setAttribute(
          "transform",
          `translate(${tx.toFixed(2)} ${ty.toFixed(2)}) rotate(${ta.toFixed(2)} 302 44)`
        );
      }

      if (btnEl) {
        const nShadow = target?.nShadow || 2;
        const pShadow = target?.phaseShadow || 0;
        const sh = 0.92 + 0.08 * Math.sin(w * nShadow + pShadow + seed * 0.01);
        const sh2 = 0.70 + 0.06 * Math.sin(w * nShadow + pShadow + seed * 0.01 + 1.2);
        const shA = 0.72 + 0.10 * Math.sin(w * nShadow + pShadow + seed * 0.01 + 2.4);
        btnEl.style.setProperty("--larva-shadow-sx", sh.toFixed(3));
        btnEl.style.setProperty("--larva-shadow-sy", sh2.toFixed(3));
        btnEl.style.setProperty("--larva-shadow-a", shA.toFixed(3));
      }
    }
    larvaRaf = requestAnimationFrame(tick);
  };
  larvaRaf = requestAnimationFrame(tick);
}

function buildLarvaSvg(label, { uid, seed } = {}) {
  const title = String(label || "").toUpperCase();
  const safeUid = uid || `larva-${state.larvaUid++}`;
  const bodyId = `larva-body-${safeUid}`;
  const glowId = `larva-glow-${safeUid}`;
  const curveId = `larva-curve-${safeUid}`;
  const filterId = `larva-wiggle-${safeUid}`;

  const svg = svgEl("svg");
  svg.setAttribute("class", "larva-svg");
  svg.setAttribute("viewBox", "0 0 320 84");
  svg.setAttribute("fill", "none");
  svg.setAttribute("aria-hidden", "true");
  svg.setAttribute("preserveAspectRatio", "none");

  const defs = svgEl("defs");

  const bodyGrad = svgEl("radialGradient");
  bodyGrad.setAttribute("id", bodyId);
  bodyGrad.setAttribute("cx", "34%");
  bodyGrad.setAttribute("cy", "26%");
  bodyGrad.setAttribute("r", "90%");
  {
    const stop1 = svgEl("stop");
    stop1.setAttribute("offset", "0%");
    stop1.setAttribute("stop-color", "#ff8fd4");
    bodyGrad.appendChild(stop1);
    const stop2 = svgEl("stop");
    stop2.setAttribute("offset", "42%");
    stop2.setAttribute("stop-color", "#ff2f9c");
    bodyGrad.appendChild(stop2);
    const stop3 = svgEl("stop");
    stop3.setAttribute("offset", "100%");
    stop3.setAttribute("stop-color", "#1f020e");
    bodyGrad.appendChild(stop3);
  }
  defs.appendChild(bodyGrad);

  const glowGrad = svgEl("radialGradient");
  glowGrad.setAttribute("id", glowId);
  glowGrad.setAttribute("cx", "40%");
  glowGrad.setAttribute("cy", "40%");
  glowGrad.setAttribute("r", "80%");
  {
    const stop1 = svgEl("stop");
    stop1.setAttribute("offset", "0%");
    stop1.setAttribute("stop-color", "#ff5ebe");
    stop1.setAttribute("stop-opacity", "0.40");
    glowGrad.appendChild(stop1);
    const stop2 = svgEl("stop");
    stop2.setAttribute("offset", "60%");
    stop2.setAttribute("stop-color", "#c56bff");
    stop2.setAttribute("stop-opacity", "0.12");
    glowGrad.appendChild(stop2);
    const stop3 = svgEl("stop");
    stop3.setAttribute("offset", "100%");
    stop3.setAttribute("stop-color", "#000000");
    stop3.setAttribute("stop-opacity", "0");
    glowGrad.appendChild(stop3);
  }
  defs.appendChild(glowGrad);

  const filter = svgEl("filter");
  filter.setAttribute("id", filterId);
  filter.setAttribute("x", "-30");
  filter.setAttribute("y", "-30");
  filter.setAttribute("width", "380");
  filter.setAttribute("height", "160");
  filter.setAttribute("filterUnits", "userSpaceOnUse");

  const turb = svgEl("feTurbulence");
  turb.setAttribute("type", "turbulence");
  turb.setAttribute("baseFrequency", "0.012 0.020");
  turb.setAttribute("numOctaves", "2");
  turb.setAttribute("seed", String(seed ?? 2));
  turb.setAttribute("result", "noise");
  filter.appendChild(turb);

  const disp = svgEl("feDisplacementMap");
  disp.setAttribute("in", "SourceGraphic");
  disp.setAttribute("in2", "noise");
  disp.setAttribute("scale", "10");
  disp.setAttribute("xChannelSelector", "R");
  disp.setAttribute("yChannelSelector", "G");
  filter.appendChild(disp);

  defs.appendChild(filter);
  svg.appendChild(defs);

  const g = svgEl("g");
  g.setAttribute("filter", `url(#${filterId})`);

  const aura = svgEl("path");
  aura.setAttribute(
    "d",
    "M24 44 C32 22 78 14 124 18 C176 22 236 14 280 20 C300 22 312 30 316 42 C320 54 312 64 294 66 C244 74 176 78 122 74 C76 70 34 62 24 44 Z"
  );
  aura.setAttribute("fill", `url(#${glowId})`);
  aura.setAttribute("opacity", "0.62");
  g.appendChild(aura);

  const body = svgEl("path");
  body.setAttribute(
    "d",
    "M28 44 C36 24 82 16 128 20 C186 24 248 16 286 22 C302 24 312 32 316 42 C320 52 312 60 296 64 C248 72 180 74 128 70 C82 66 40 58 28 44 Z"
  );
  body.setAttribute("fill", `url(#${bodyId})`);
  body.setAttribute("stroke", "rgba(170, 40, 110, 0.62)");
  body.setAttribute("stroke-width", "2");
  g.appendChild(body);

  const headGroup = svgEl("g");
  headGroup.dataset.part = "head";
  // Head cap (subtle) so head/tail motion reads as "alive" without looking like a UI widget.
  const headCap = svgEl("ellipse");
  headCap.setAttribute("cx", "54");
  headCap.setAttribute("cy", "44");
  headCap.setAttribute("rx", "22");
  headCap.setAttribute("ry", "18");
  headCap.setAttribute("fill", "rgba(0, 0, 0, 0.14)");
  headGroup.appendChild(headCap);

  const headSheen = svgEl("ellipse");
  headSheen.setAttribute("cx", "48");
  headSheen.setAttribute("cy", "38");
  headSheen.setAttribute("rx", "14");
  headSheen.setAttribute("ry", "10");
  headSheen.setAttribute("fill", "rgba(255, 255, 255, 0.12)");
  headSheen.setAttribute("opacity", "0.7");
  headGroup.appendChild(headSheen);

  const headDot1 = svgEl("circle");
  headDot1.setAttribute("cx", "44");
  headDot1.setAttribute("cy", "48");
  headDot1.setAttribute("r", "2.0");
  headDot1.setAttribute("fill", "rgba(255, 255, 255, 0.10)");
  headGroup.appendChild(headDot1);

  const headDot2 = svgEl("circle");
  headDot2.setAttribute("cx", "52");
  headDot2.setAttribute("cy", "50");
  headDot2.setAttribute("r", "1.4");
  headDot2.setAttribute("fill", "rgba(255, 255, 255, 0.08)");
  headGroup.appendChild(headDot2);

  g.appendChild(headGroup);

  const tailGroup = svgEl("g");
  tailGroup.dataset.part = "tail";
  const tailTip = svgEl("path");
  tailTip.setAttribute("d", "M302 40 L318 44 L302 48 Z");
  tailTip.setAttribute("fill", "rgba(70, 10, 120, 0.55)");
  tailGroup.appendChild(tailTip);

  const tailShine = svgEl("path");
  tailShine.setAttribute("d", "M300 38 C308 38 314 40 318 44 C314 48 308 50 300 50");
  tailShine.setAttribute("stroke", "rgba(255, 255, 255, 0.10)");
  tailShine.setAttribute("stroke-width", "2");
  tailShine.setAttribute("stroke-linecap", "round");
  tailGroup.appendChild(tailShine);
  g.appendChild(tailGroup);

  // Segment ridges (worm rings).
  for (let i = 0; i < 10; i += 1) {
    const x = 68 + i * 22;
    const ridge = svgEl("path");
    ridge.setAttribute("d", `M${x} 18 Q${x - 10} 42 ${x} 66`);
    ridge.setAttribute("stroke", "rgba(255, 255, 255, 0.17)");
    ridge.setAttribute("stroke-width", "3");
    ridge.setAttribute("stroke-linecap", "round");
    ridge.setAttribute("opacity", "0.55");
    g.appendChild(ridge);

    const shadow = svgEl("path");
    shadow.setAttribute("d", `M${x + 2} 22 Q${x - 6} 44 ${x + 2} 62`);
    shadow.setAttribute("stroke", "rgba(0, 0, 0, 0.18)");
    shadow.setAttribute("stroke-width", "3");
    shadow.setAttribute("stroke-linecap", "round");
    shadow.setAttribute("opacity", "0.55");
    g.appendChild(shadow);
  }

  // Gloss highlight.
  const gloss = svgEl("path");
  gloss.setAttribute("d", "M54 34 C124 16 204 16 286 30");
  gloss.setAttribute("stroke", "rgba(255, 255, 255, 0.18)");
  gloss.setAttribute("stroke-width", "9");
  gloss.setAttribute("stroke-linecap", "round");
  gloss.setAttribute("opacity", "0.46");
  g.appendChild(gloss);

  // Speckles.
  for (let i = 0; i < 14; i += 1) {
    const c = svgEl("circle");
    const cx = 56 + ((i * 19 + (seed ?? 0) * 17) % 220);
    const cy = 26 + ((i * 13 + (seed ?? 0) * 11) % 32);
    const r = 1.1 + ((i + (seed ?? 0)) % 3) * 0.5;
    c.setAttribute("cx", String(cx));
    c.setAttribute("cy", String(cy));
    c.setAttribute("r", String(r));
    c.setAttribute("fill", "rgba(255, 255, 255, 0.11)");
    g.appendChild(c);
  }

  // Slight curve so the text feels "painted onto" the larva.
  const curve = svgEl("path");
  curve.setAttribute("id", curveId);
  // Keep the label centered on the thickest part of the body.
  curve.setAttribute("d", "M62 52 C136 50 210 50 282 52");
  curve.setAttribute("fill", "none");
  g.appendChild(curve);

  const tight = title.replace(/\s+/g, "").length;
  let fontSize = 26;
  if (tight >= 12) fontSize = 24;
  if (tight >= 14) fontSize = 22;
  if (tight >= 16) fontSize = 20;

  const text = svgEl("text");
  text.setAttribute("fill", "rgba(255, 246, 252, 0.96)");
  text.setAttribute("stroke", "rgba(0, 0, 0, 0.40)");
  text.setAttribute("stroke-width", "6");
  text.setAttribute("font-family", "Space Grotesk, sans-serif");
  text.setAttribute("font-weight", "800");
  text.setAttribute("font-size", String(fontSize));
  text.setAttribute("letter-spacing", "3");
  text.setAttribute("text-anchor", "middle");
  text.setAttribute("paint-order", "stroke fill");

  const textPath = svgEl("textPath");
  textPath.setAttribute("startOffset", "50%");
  textPath.setAttribute("href", `#${curveId}`);
  textPath.setAttributeNS(XLINK_NS, "xlink:href", `#${curveId}`);
  textPath.textContent = title;
  text.appendChild(textPath);
  g.appendChild(text);

  svg.appendChild(g);
  return { svg, turbEl: turb, dispEl: disp, headEl: headGroup, tailEl: tailGroup };
}

function spawnCooldownKey(nodeId, imageId) {
  return `${String(imageId || "")}::${String(nodeId || "")}`;
}

function isSpawnNodeOnCooldown(nodeId, imageId) {
  const key = spawnCooldownKey(nodeId, imageId);
  const until = state.spawnCooldowns.get(key);
  if (!until) return false;
  if (Date.now() >= until) {
    state.spawnCooldowns.delete(key);
    return false;
  }
  return true;
}

function setSpawnNodeCooldown(nodeId, imageId, ms = 60_000) {
  const key = spawnCooldownKey(nodeId, imageId);
  state.spawnCooldowns.set(key, Date.now() + Math.max(1_000, Number(ms) || 60_000));
}

function explodeSpawnNode(btnEl, nodeId, imageId) {
  if (!btnEl || !nodeId) return;
  if (btnEl.classList.contains("exploding")) return;
  setSpawnNodeCooldown(nodeId, imageId, 60_000);

  // Stop per-frame warping so the explosion animation can take over cleanly.
  for (const target of state.larvaTargets) {
    if (target?.btnEl === btnEl) {
      target.exploding = true;
      try {
        if (target.svgEl) target.svgEl.style.transform = "";
      } catch {
        // ignore
      }
      break;
    }
  }

  btnEl.classList.add("exploding");
  btnEl.setAttribute("disabled", "disabled");

  // Let the pop animation play, then rebuild the spawnbar without this node.
  setTimeout(() => {
    if (btnEl?.isConnected) {
      try {
        btnEl.remove();
      } catch {
        // ignore
      }
    }
    chooseSpawnNodes();
  }, 680);

  // After cooldown, refresh if the same image is still selected.
  setTimeout(() => {
    const active = getActiveImage();
    if (active?.id && active.id === imageId) chooseSpawnNodes();
  }, 60_200);
}

function renderSpawnbar() {
  if (!els.spawnbar) return;
  if (!ENABLE_SPAWN_ACTIONS) {
    els.spawnbar.innerHTML = "";
    els.spawnbar.classList.add("hidden");
    stopLarvaAnimator();
    state.larvaTargets = [];
    return;
  }
  els.spawnbar.classList.remove("hidden");
  els.spawnbar.innerHTML = "";
  stopLarvaAnimator();
  state.larvaTargets = [];
  if (!state.activeId) return;
  const activeItem = getActiveImage();
  const activeId = activeItem?.id || state.activeId || "";
  const activePath = activeItem?.path || "";
  const frag = document.createDocumentFragment();
  for (const node of state.spawnNodes) {
    if (isSpawnNodeOnCooldown(node.id, activeId)) continue;
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = ENABLE_LARVA_SPAWN ? "spawn-node" : "spawn-action";
    btn.setAttribute("aria-label", node.title || "Action");
    const text = String(node.title || "");
    if (!ENABLE_LARVA_SPAWN) {
      btn.textContent = text;
    } else {
      const rawWidth = (120 + text.length * 10) * 0.8;
      const width = clamp(Math.round(rawWidth), 150, 240);
      btn.style.setProperty("--larva-w", `${width}px`);
      btn.style.setProperty("--larva-h", "46px");
      const stable = hash32(`${node.id}::${activeId}`);
      const uid = `larva-${node.id}-${stable.toString(16)}-${state.larvaUid++}`;
      const seed = stable % 1000;
      const built = buildLarvaSvg(text, { uid, seed });
      const r1 = rand01(stable + 1.1);
      const r2 = rand01(stable + 2.2);
      const r3 = rand01(stable + 3.3);
      const r4 = rand01(stable + 4.4);
      const tilt = (r1 - 0.5) * 7.0; // ~[-3.5..3.5]deg
      btn.style.setProperty("--larva-tilt", `${tilt.toFixed(2)}deg`);
      built.svg.style.transform = `rotate(${tilt.toFixed(2)}deg)`;
      btn.appendChild(built.svg);

      // Static organic warp; we animate head/tail (not full-body squiggle).
      const baseF1 = 0.0095 + r2 * 0.0040;
      const baseF2 = 0.0140 + r3 * 0.0050;
      const warpScale = 5.2 + r3 * 1.6;
      try {
        if (built.turbEl) built.turbEl.setAttribute("baseFrequency", `${baseF1.toFixed(4)} ${baseF2.toFixed(4)}`);
        if (built.dispEl) built.dispEl.setAttribute("scale", `${warpScale.toFixed(1)}`);
      } catch {
        // ignore
      }

      state.larvaTargets.push({
        nodeId: node.id,
        imagePath: activePath,
        btnEl: btn,
        svgEl: built.svg,
        turbEl: built.turbEl,
        dispEl: built.dispEl,
        headEl: built.headEl,
        tailEl: built.tailEl,
        seed,
        tiltDeg: tilt,
        rotAmp: 0.16 + r4 * 0.55,
        nRot: 1 + Math.floor(r3 * 3),
        nSquish: 1 + Math.floor(r4 * 3),
        phaseRot: r4 * Math.PI * 2,
        phaseSquish: r1 * Math.PI * 2,
        squishAmp: 0.0045 + r2 * 0.0035,
        nHead: 1 + Math.floor(r2 * 3),
        nHeadRot: 1 + Math.floor(r3 * 3),
        headAmpX: 1.0 + r1 * 1.6,
        headAmpY: 0.6 + r2 * 1.2,
        headRotAmp: 5 + r4 * 10,
        phaseHeadX: r2 * Math.PI * 2,
        phaseHeadY: r3 * Math.PI * 2,
        phaseHeadRot: r4 * Math.PI * 2,
        nTail: 1 + Math.floor(r3 * 3),
        nTailRot: 1 + Math.floor(r4 * 3),
        tailAmpX: 0.8 + r2 * 1.4,
        tailAmpY: 0.5 + r1 * 1.0,
        tailRotAmp: 4 + r3 * 8,
        phaseTailX: r3 * Math.PI * 2,
        phaseTailY: r4 * Math.PI * 2,
        phaseTailRot: r1 * Math.PI * 2,
        nShadow: 1 + Math.floor(r2 * 3),
        phaseShadow: r4 * Math.PI * 2,
      });
    }
    btn.addEventListener("click", () => {
      bumpInteraction();
      const imageId = getActiveImage()?.id || activeId;
      explodeSpawnNode(btn, node.id, imageId);
      handleSpawnNode(node).catch((err) => {
        console.error(err);
        showToast(err?.message || String(err), "error");
      });
    });
    frag.appendChild(btn);
  }
  els.spawnbar.appendChild(frag);
  if (ENABLE_LARVA_SPAWN) ensureLarvaAnimator();
}

function isMultiActionRunning() {
  return Boolean(
    state.pendingBlend ||
      state.pendingSwapDna ||
      state.pendingBridge ||
      state.pendingExtractDna ||
      state.pendingSoulLeech ||
      state.pendingExtractRule ||
      state.pendingOddOneOut ||
      state.pendingTriforce
  );
}

const ACTION_QUEUE_MAX = 32;
const ACTION_QUEUE_PRIORITY = {
  user: 100,
  background: 10,
};

function isEngineBusy() {
  return Boolean(
    state.ptySpawning ||
      state.alwaysOnVision?.pending ||
      state.pendingBlend ||
      state.pendingSwapDna ||
      state.pendingBridge ||
      state.pendingExtractDna ||
      state.pendingSoulLeech ||
      state.pendingExtractRule ||
      state.pendingOddOneOut ||
      state.pendingTriforce ||
      state.pendingRecast ||
      state.pendingCreateLayers ||
      state.pendingPromptGenerate ||
      state.pendingReplace ||
      state.pendingRecreate ||
      state.expectingArtifacts
  );
}

function resetActionQueue() {
  state.actionQueue = [];
  state.actionQueueActive = null;
  state.actionQueueRunning = false;
  state.actionQueueStats = {
    replacedByKey: 0,
    droppedOverflow: 0,
    lastDropLabel: null,
  };
  renderSessionApiCallsReadout();
}

function _actionQueueMakeId() {
  return `aq-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
}

function enqueueAction({ label, key = null, priority = ACTION_QUEUE_PRIORITY.user, source = "user", run } = {}) {
  const fn = typeof run === "function" ? run : null;
  if (!label || !fn) return false;

  if (key && state.actionQueueActive?.key && state.actionQueueActive.key === key) {
    showToast(`${label} already running.`, "tip", 1800);
    return false;
  }

  const now = Date.now();
  let replacedCount = 0;
  if (key) {
    // De-dupe repeated clicks; keep latest request.
    const before = state.actionQueue.length;
    state.actionQueue = state.actionQueue.filter((item) => item?.key !== key);
    replacedCount = Math.max(0, before - state.actionQueue.length);
    if (replacedCount) {
      state.actionQueueStats.replacedByKey = Math.max(0, Number(state.actionQueueStats.replacedByKey) || 0) + replacedCount;
    }
  }

  const queuedItem = {
    id: _actionQueueMakeId(),
    label: String(label),
    key: key ? String(key) : null,
    priority: typeof priority === "number" ? priority : ACTION_QUEUE_PRIORITY.user,
    enqueuedAt: now,
    source: source ? String(source) : "user",
    run: fn,
  };
  state.actionQueue.push(queuedItem);

  // Keep queue bounded by dropping the lowest-priority oldest items.
  const droppedItems = [];
  while (state.actionQueue.length > ACTION_QUEUE_MAX) {
    let dropIdx = 0;
    for (let i = 1; i < state.actionQueue.length; i += 1) {
      const a = state.actionQueue[i];
      const b = state.actionQueue[dropIdx];
      const ap = typeof a?.priority === "number" ? a.priority : 0;
      const bp = typeof b?.priority === "number" ? b.priority : 0;
      if (ap < bp) {
        dropIdx = i;
        continue;
      }
      if (ap === bp && (a?.enqueuedAt || 0) < (b?.enqueuedAt || 0)) {
        dropIdx = i;
      }
    }
    const dropped = state.actionQueue.splice(dropIdx, 1)[0];
    if (dropped) droppedItems.push(dropped);
  }

  if (droppedItems.length) {
    state.actionQueueStats.droppedOverflow =
      Math.max(0, Number(state.actionQueueStats.droppedOverflow) || 0) + droppedItems.length;
    state.actionQueueStats.lastDropLabel = String(droppedItems[droppedItems.length - 1]?.label || "Action");
    const dropLead = String(droppedItems[0]?.label || "action");
    const more = droppedItems.length > 1 ? ` (+${droppedItems.length - 1} more)` : "";
    showToast(`Queue full: dropped ${dropLead}${more}.`, "tip", 2600);
  }

  const queuedKept = state.actionQueue.some((item) => item?.id === queuedItem.id);
  if (queuedKept) {
    const mergedNote = replacedCount ? ` (updated ${replacedCount})` : "";
    showToast(`Queued: ${label}${mergedNote}`, "tip", 1500);
  } else {
    showToast(`Queue full: ${label} was not queued.`, "error", 2800);
  }
  renderQuickActions();
  renderSessionApiCallsReadout();
  processActionQueue().catch((err) => {
    reportUserError("Queue processing", err, { retryHint: "Wait for current work to finish, then retry." });
  });
  return queuedKept;
}

function _pickNextQueuedActionIndex() {
  if (!state.actionQueue.length) return -1;
  let bestIdx = 0;
  for (let i = 1; i < state.actionQueue.length; i += 1) {
    const a = state.actionQueue[i];
    const b = state.actionQueue[bestIdx];
    const ap = typeof a?.priority === "number" ? a.priority : 0;
    const bp = typeof b?.priority === "number" ? b.priority : 0;
    if (ap > bp) {
      bestIdx = i;
      continue;
    }
    if (ap === bp && (a?.enqueuedAt || 0) < (b?.enqueuedAt || 0)) {
      bestIdx = i;
    }
  }
  return bestIdx;
}

async function processActionQueue() {
  if (state.actionQueueRunning) return;
  state.actionQueueRunning = true;
  try {
    if (state.actionQueueActive && !isEngineBusy()) {
      state.actionQueueActive = null;
      renderQuickActions();
      renderSessionApiCallsReadout();
    }

    while (!state.actionQueueActive && !isEngineBusy() && state.actionQueue.length) {
      // Realtime canvas context drives Suggested Ability; when it's due, run it ahead of
      // other queued API work so the UI stays responsive.
      try {
        const started = await runAlwaysOnVisionOnce();
        if (started && isEngineBusy()) return;
      } catch (err) {
        console.warn("Always-on vision priority dispatch failed:", err);
      }

      const idx = _pickNextQueuedActionIndex();
      if (idx < 0) return;
      const item = state.actionQueue.splice(idx, 1)[0];
      if (!item) return;

      state.actionQueueActive = {
        id: item.id,
        label: item.label,
        key: item.key || null,
        priority: item.priority,
        enqueuedAt: item.enqueuedAt,
        source: item.source || "user",
      };
      renderQuickActions();
      renderSessionApiCallsReadout();

      const queuedStatus = `Engine: queued action running (${item.label})`;
      const prevStatusText = String(state.lastStatusText || "");
      const prevStatusError = Boolean(state.lastStatusError);
      try {
        setStatus(queuedStatus);
        await Promise.resolve(item.run());
      } catch (err) {
        console.error("Queued action failed:", item?.label, err);
        reportUserError(item?.label || "Queued action", err, { retryHint: "Retry from Skills." });
      }

      if (isEngineBusy()) {
        // Engine-driven action is in flight; completion events will resume the queue.
        return;
      }

      // If the queued callback returned without launching engine work, clear the
      // temporary queue-running status so the ribbon does not appear stuck.
      if (String(state.lastStatusText || "") === queuedStatus) {
        setStatus(prevStatusText || (state.ptySpawned ? "Engine: ready" : "Engine: idle"), prevStatusError);
      }

      // Completed immediately (local action or no-op); continue draining.
      state.actionQueueActive = null;
      renderQuickActions();
      renderSessionApiCallsReadout();
    }
  } finally {
    state.actionQueueRunning = false;
    renderSessionApiCallsReadout();
  }
}

function chooseSpawnNodes() {
  if (!ENABLE_SPAWN_ACTIONS) {
    state.spawnNodes = [];
    renderSpawnbar();
    renderQuickActions();
    return;
  }
  if (!state.activeId) {
    state.spawnNodes = [];
    renderSpawnbar();
    renderQuickActions();
    return;
  }
  const img = getActiveImage();
  const items = [];
  if (state.canvasMode === "multi") {
    const canBlend = selectedCount() === 2 && !isMultiActionRunning();
    if (canBlend) items.push({ id: "blend_pair", title: "Combine", action: "blend_pair" });
  }
  items.push({ id: "bg_white", title: "Studio White", action: "bg_white" });
  items.push({ id: "variations", title: "Variations", action: "variations" });
  if (img?.img) {
    const w = img.img.naturalWidth;
    const h = img.img.naturalHeight;
    if (w && h && Math.abs(w - h) > 8) {
      items.push({ id: "crop_square", title: "Square Crop", action: "crop_square" });
    } else {
      items.push({ id: "bg_sweep", title: "Soft Sweep", action: "bg_sweep" });
    }
  } else {
    items.push({ id: "bg_sweep", title: "Soft Sweep", action: "bg_sweep" });
  }
  // Keep it to 3 kernels.
  const imageId = img?.id || state.activeId || "";
  const available = items.filter((item) => !isSpawnNodeOnCooldown(item.id, imageId));
  state.spawnNodes = available.slice(0, 3);
  renderSpawnbar();
  renderQuickActions();
}

function computeQuickActions() {
  // Scaffolding: keep this as a pure function of current canvas state so we can
  // grow rules over time without entangling UI code.
  const actions = [];
  const active = getActiveImage();
  const nSelected = selectedCount();

  if (!active) {
    actions.push({
      id: "no_image",
      label: "Import photos to unlock skills",
      disabled: true,
    });
    return actions;
  }

  // Multi canvas is the only supported mode.

  // Multi-image skills are driven by *selected* images, not run size.
  if (nSelected === 2) {
    actions.push({
      id: "combine",
      label: state.pendingBlend ? "Combine (runningâ€¦)" : "Combine",
      title: "Blend the 2 selected photos into one",
      disabled: false,
      onClick: () => runBlendPair().catch((err) => console.error(err)),
    });
    actions.push({
      id: "bridge",
      label: state.pendingBridge ? "Bridge (runningâ€¦)" : "Bridge",
      title: "Find the aesthetic midpoint between the 2 selected images (not a collage)",
      disabled: false,
      onClick: () => runBridgePair().catch((err) => console.error(err)),
    });
    actions.push({
      id: "swap_dna",
      label: state.pendingSwapDna ? "Swap DNA (runningâ€¦)" : "Swap DNA",
      title: "Use structure from the active image and surface qualities from the other (Shift-click to invert)",
      disabled: false,
      onClick: (ev) =>
        runSwapDnaPair({ invert: Boolean(ev?.shiftKey) }).catch((err) => console.error(err)),
    });
    return actions;
  }
  if (nSelected === 3) {
    const runningMulti = isMultiActionRunning();
    actions.push({
      id: "extract_rule",
      label: state.pendingExtractRule ? "Extract the Rule (runningâ€¦)" : "Extract the Rule",
      title: "Extract the invisible rule you're applying across the 3 selected images.",
      disabled: Boolean(runningMulti && !state.pendingExtractRule),
      onClick: () => runExtractRuleTriplet().catch((err) => console.error(err)),
    });
    actions.push({
      id: "odd_one_out",
      label: state.pendingOddOneOut ? "Odd One Out (runningâ€¦)" : "Odd One Out",
      title: "Identify which of the 3 selected breaks the shared pattern, and explain why.",
      disabled: Boolean(runningMulti && !state.pendingOddOneOut),
      onClick: () => runOddOneOutTriplet().catch((err) => console.error(err)),
    });
    actions.push({
      id: "triforce",
      label: state.pendingTriforce ? "Triforce (runningâ€¦)" : "Triforce",
      title: "Generate the centroid: one image equidistant from all 3 selected references.",
      disabled: Boolean(runningMulti && !state.pendingTriforce),
      onClick: () => runTriforceTriplet().catch((err) => console.error(err)),
    });
    return actions;
  }
  if (nSelected > 3) {
    actions.push({
      id: "multi_hint",
      label: `Multi-select: pick exactly 2 or 3 images (you have ${nSelected}).`,
      disabled: true,
    });
    return actions;
  }

  const iw = active?.img?.naturalWidth || active?.width || null;
  const ih = active?.img?.naturalHeight || active?.height || null;
  const canCropSquare = Boolean(iw && ih && Math.abs(iw - ih) > 8);

  actions.push({
    id: "create_layers",
    label: state.runningActionKey === "create_layers" ? "Create Layers (runningâ€¦)" : "Create Layers",
    title: "Generate semantic layers: background, main subject, and detachable props.",
    disabled: nSelected !== 1,
    onClick: () => runCreateLayersFromSelection().catch((err) => console.error(err)),
  });
  actions.push({
    id: "recast",
    label: state.pendingRecast ? "Recast (runningâ€¦)" : "Recast",
    title: "Reimagine the image in a totally different medium/context (lateral leap)",
    disabled: false,
    onClick: () => runRecast().catch((err) => console.error(err)),
  });

  actions.push({
    id: "bg_white",
    label: "Background: White",
    title: "Replace background with a clean studio white",
    disabled: false,
    onClick: () => applyBackground("white").catch((err) => console.error(err)),
  });
  actions.push({
    id: "bg_sweep",
    label: "Background: Sweep",
    title: "Replace background with a soft sweep gradient",
    disabled: false,
    onClick: () => applyBackground("sweep").catch((err) => console.error(err)),
  });
  actions.push({
    id: "crop_square",
    label: "Crop: Square",
    title: canCropSquare ? "Crop the active image to a centered square" : "Already square (or image size unknown)",
    disabled: !canCropSquare,
    onClick: canCropSquare ? () => cropSquare().catch((err) => console.error(err)) : null,
  });
  actions.push({
    id: "variations",
    label: "Variations",
    title: "Zero-prompt variations of the active image",
    disabled: false,
    onClick: () => runVariations().catch((err) => console.error(err)),
  });

  return actions;
}

function _runningKeyFromPendingReplace(pending) {
  const label = pending?.label ? String(pending.label) : "";
  const stable = label.toLowerCase();
  if (stable.includes("remove people")) return "remove_people";
  if (stable.includes("extract dna")) return "extract_dna";
  if (stable.includes("soul leech")) return "soul_leech";
  if (stable.includes("surprise")) return "surprise";
  if (stable.includes("studio white") || stable.includes("soft sweep") || stable.includes("background")) return "bg";
  if (stable.includes("annotate")) return "annotate";
  return "bg";
}

function currentRunningActionKey() {
  if (state.runningActionKey) return state.runningActionKey;
  if (state.pendingBlend) return "combine";
  if (state.pendingBridge) return "bridge";
  if (state.pendingSwapDna) return "swap_dna";
  if (state.pendingExtractDna) return "extract_dna";
  if (state.pendingSoulLeech) return "soul_leech";
  if (state.pendingExtractRule) return "extract_rule";
  if (state.pendingOddOneOut) return "odd_one_out";
  if (state.pendingTriforce) return "triforce";
  if (state.pendingPromptGenerate) return "prompt_generate";
  if (state.pendingRecast) return "recast";
  if (state.pendingCreateLayers) return "create_layers";
  if (state.pendingRecreate) return "variations";
  if (state.pendingReplace) return _runningKeyFromPendingReplace(state.pendingReplace);
  return null;
}

function actionGridTitleFor(key) {
  const k = String(key || "").trim();
  if (!k) return "";
  if (k === "annotate") return "Annotate (box + instruction)";
  if (k === "pan") return "Pan / Zoom";
  if (k === "lasso") return "Lasso selection";
  if (k === "bg") return "Background replace (Shift: Sweep)";
  if (k === "extract_dna") return "Extract DNA: collapse selected image(s) into transferable material/color helix";
  if (k === "soul_leech") return "Soul Leech: collapse selected image(s) into transferable emotional mask";
  if (k === "create_layers") return "Create Layers: semantic background/subject/props layer extraction";
  if (k === "prompt_generate") return "Prompt Generate: create a brand-new image from text";
  if (k === "remove_people") return "Remove people from the active image";
  if (k === "variations") return "Zero-prompt variations";
  if (k === "recast") return "Reimagine the image in a different medium/context";
  if (k === "crop_square") return "Crop the active image to a centered square";
  if (k === "combine") return "Combine: blend the 2 selected photos";
  if (k === "bridge") return "Bridge: find the aesthetic midpoint between the 2 selected photos";
  if (k === "swap_dna") return "Swap DNA (Shift: invert)";
  if (k === "extract_rule") return "Extract the Rule (3 selected photos)";
  if (k === "odd_one_out") return "Odd One Out (3 selected photos)";
  if (k === "triforce") return "Triforce (3 selected photos)";
  return k;
}

function actionGridIconFor(key) {
  const k = String(key || "").trim();
  if (!k) return "";
  // Keep SVGs small and stroke-only so the tool style does the heavy lifting.
  if (k === "annotate") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M5 6h11v11H5z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
      <path d="M14.5 4.5l5 5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M13 6l6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "pan") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 3v6M12 21v-6M3 12h6M21 12h-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="square" />
      <path d="M12 3l-2 2M12 3l2 2M12 21l-2-2M12 21l2-2M3 12l2-2M3 12l2 2M21 12l-2-2M21 12l-2 2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="square" />
    </svg>`;
  }
  if (k === "lasso") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <ellipse cx="12" cy="9.5" rx="6.5" ry="4.5" fill="none" stroke="currentColor" stroke-width="2" />
      <path d="M15 13.5c0.9 1.2 1.9 2.6 3.5 4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M19.5 18l1.8 1.8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "bg") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M6 7h10v4H6z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
      <path d="M16 9h2a2 2 0 0 1 2 2v1" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M8 11v7h4v-4h3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>`;
  }
  if (k === "extract_dna") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M7 4c4 0 6 3 10 3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M7 10c4 0 6 3 10 3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M7 16c4 0 6 3 10 3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M7 4v15M17 7v12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "soul_leech") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M6 8c0-3 2.7-5 6-5s6 2 6 5v5c0 3.7-2.8 6-6 6s-6-2.3-6-6z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
      <path d="M9 10h.01M15 10h.01" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M9.5 14c1.8 1.7 3.2 1.7 5 0" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M12 3v3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "create_layers") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <rect x="4" y="4" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" />
      <rect x="7" y="7" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" />
      <path d="M10 10h6M10 13h6M10 16h6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "prompt_generate") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 3l1.9 4.3 4.7.4-3.5 3 1 4.6-4.1-2.4-4.1 2.4 1-4.6-3.5-3 4.7-.4z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
      <path d="M18.5 15.5l.9 2 .2 2.2-2-.9-2.2-.2 1.3-1.8.8-2.1z" fill="none" stroke="currentColor" stroke-width="1.7" stroke-linejoin="round" />
    </svg>`;
  }
  if (k === "remove_people") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 12a3.5 3.5 0 1 0-0.01 0" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M5 20c1.2-3 4-5 7-5s5.8 2 7 5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M6 6l12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "variations") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M4 7h4l8 10h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M20 17l-2-2 2-2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M4 17h4l2.5-3" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M20 7l-2 2 2 2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>`;
  }
  if (k === "recast") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M21 12a9 9 0 1 1-2.7-6.4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M21 3v6h-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>`;
  }
  if (k === "crop_square") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M7 3v14a4 4 0 0 0 4 4h10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M3 7h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M7 7h10v10H7z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
    </svg>`;
  }
  if (k === "combine") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M5 7h8v8H5z" fill="none" stroke="currentColor" stroke-width="2" />
      <path d="M11 9h8v8h-8z" fill="none" stroke="currentColor" stroke-width="2" />
    </svg>`;
  }
  if (k === "bridge") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M4 8h6v8H4z" fill="none" stroke="currentColor" stroke-width="2" />
      <path d="M14 8h6v8h-6z" fill="none" stroke="currentColor" stroke-width="2" />
      <path d="M10 12h4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "swap_dna") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M7 7h10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M7 17h10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M9 9l-2-2 2-2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M15 15l2 2-2 2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>`;
  }
  if (k === "extract_rule") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M6 4h12v16H6z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
      <path d="M8 8h8M8 12h8M8 16h6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
    </svg>`;
  }
  if (k === "odd_one_out") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="7.5" cy="12" r="2.5" fill="none" stroke="currentColor" stroke-width="2" />
      <circle cx="16.5" cy="8" r="2.5" fill="none" stroke="currentColor" stroke-width="2" />
      <circle cx="16.5" cy="16" r="2.5" fill="none" stroke="currentColor" stroke-width="2" />
    </svg>`;
  }
  if (k === "triforce") {
    return `<svg class="tool-icon" viewBox="0 0 24 24" aria-hidden="true">
      <path d="M12 5l4.5 8H7.5z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
      <path d="M7.5 13l4.5 8 4.5-8z" fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round" />
    </svg>`;
  }
  return "";
}

function actionGridReelIconOverrideFor(key) {
  const k = String(key || "").trim();
  if (!k) return "";
  if (k === "pan") {
    // iOS-style gesture icon for reel mode: finger + touch ring.
    return `<svg class="tool-icon tool-icon-ios-pan" viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="17.5" cy="6.5" r="2.2" fill="none" stroke="currentColor" stroke-width="1.8" />
      <path d="M12 19v-8.4a1.6 1.6 0 0 1 3.2 0V14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
      <path d="M12 14l-1.6-1.5a1.5 1.5 0 0 0-2.2 2l2.5 2.8A4.7 4.7 0 0 0 14.3 19H16a4 4 0 0 0 4-4v-2.2a1.5 1.5 0 0 0-3 0V14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </svg>`;
  }
  return "";
}

function renderActionGrid() {
  const root = els.actionGrid;
  if (!root) return;

  const active = getActiveImage();
  const hasImage = Boolean(active);
  const selectionN = hasImage ? selectedCount() : 0;
  const slots = computeActionGridSlots({
    selectionCount: selectionN,
    hasImage,
    alwaysOnVisionEnabled: Boolean(state.alwaysOnVision?.enabled),
  });
  const reelMode = isReelSizeLocked();
  const reelNoImageSlots = [
    { key: "annotate", label: "Annotate", kind: "tool", hotkey: "1" },
    { key: "lasso", label: "Lasso", kind: "tool", hotkey: "2" },
    { key: "bg", label: "BG", kind: "ability", hotkey: "3" },
    { key: "prompt_generate", label: "Prompt", kind: "ability", hotkey: "4" },
    { key: "variations", label: "Vars", kind: "ability", hotkey: "5" },
    { key: "extract_dna", label: "DNA", kind: "ability", hotkey: "6" },
  ];
  const visibleSlots = reelMode ? (!hasImage ? reelNoImageSlots : slots.slice(0, 6)) : slots;
  root.classList.toggle("reel-grid-2x3", reelMode);
  const runningKey = currentRunningActionKey();

  const iw = active?.img?.naturalWidth || active?.width || null;
  const ih = active?.img?.naturalHeight || active?.height || null;
  const canCropSquare = Boolean(iw && ih && Math.abs(iw - ih) > 8);

  root.innerHTML = "";
  const frag = document.createDocumentFragment();

  const imageRequiredKeys = new Set([
    "bg",
    "extract_dna",
    "soul_leech",
    "create_layers",
    "remove_people",
    "variations",
    "recast",
    "crop_square",
    "combine",
    "bridge",
    "swap_dna",
    "extract_rule",
    "odd_one_out",
    "triforce",
  ]);

  for (const slot of visibleSlots) {
    if (!slot) {
      const blank = document.createElement("button");
      blank.type = "button";
      blank.className = "tool tool-blank";
      blank.disabled = true;
      blank.setAttribute("aria-hidden", "true");
      frag.appendChild(blank);
      continue;
    }

    const key = String(slot.key || "").trim();
    const hotkey = String(slot.hotkey || "").trim();
    const label = String(slot.label || "").trim();
    const kind = String(slot.kind || "");

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "tool";
    btn.dataset.key = key;
    btn.dataset.hotkey = hotkey;
    btn.title = actionGridTitleFor(key);
    btn.setAttribute("aria-label", label || key);

    if (kind === "ability_multi") btn.classList.add("tool-multi");
    if (kind === "tool" && state.tool === key) {
      btn.classList.add("selected");
      btn.classList.add("depressed");
    }
    if (runningKey && runningKey === key) btn.classList.add("depressed");

    if (key === "crop_square" && !canCropSquare) {
      btn.disabled = true;
      btn.title = "Already square (or image size unknown)";
    }
    if (!hasImage && imageRequiredKeys.has(key)) {
      btn.disabled = true;
      btn.title = "Import a photo first";
    }

    const icon = reelMode ? actionGridReelIconOverrideFor(key) || actionGridIconFor(key) : actionGridIconFor(key);
    const hintHtml = reelMode ? "" : `<span class="tool-hint" aria-hidden="true">${hotkey}</span>`;
    btn.innerHTML = `${icon}${hintHtml}`;

    btn.addEventListener("click", (ev) => {
      bumpInteraction();
      if (state.mother?.running) {
        showToast("Mother is running. Click Stop to regain control.", "tip", 2200);
        return;
      }
      recordUserEvent("action_grid_press", {
        key,
        kind: kind ? String(kind) : null,
        shift: Boolean(ev?.shiftKey),
        active_id: state.activeId || null,
        selected_ids: getSelectedIds().slice(0, 3),
      });

      if (key === "annotate" || key === "pan" || key === "lasso") {
        if (key !== "pan" && state.tool === key) {
          setTool("pan");
        } else {
          setTool(key);
        }
        return;
      }
      if (key === "bg") {
        const style = ev?.shiftKey ? "sweep" : "white";
        runWithUserError("Background replace", () => applyBackground(style), {
          retryHint: "Select an image and try again.",
        });
        return;
      }
      if (key === "extract_dna") {
        runWithUserError("Extract DNA", () => runExtractDnaFromSelection(), {
          statusScope: "Director",
          retryHint: "Select at least one image and retry.",
        });
        return;
      }
      if (key === "soul_leech") {
        runWithUserError("Soul Leech", () => runSoulLeechFromSelection(), {
          statusScope: "Director",
          retryHint: "Select at least one image and retry.",
        });
        return;
      }
      if (key === "create_layers") {
        runWithUserError("Create Layers", () => runCreateLayersFromSelection(), {
          statusScope: "Director",
          retryHint: "Select exactly one image and retry.",
        });
        return;
      }
      if (key === "prompt_generate") {
        if (!requireIntentUnlocked()) return;
        showPromptGeneratePanel();
        return;
      }
      if (key === "remove_people") {
        runWithUserError("Remove people", () => aiRemovePeople(), {
          retryHint: "Select an image and retry.",
        });
        return;
      }
      if (key === "variations") {
        runWithUserError("Variations", () => runVariations(), {
          retryHint: "Select an image and retry.",
        });
        return;
      }
      if (key === "recast") {
        runWithUserError("Recast", () => runRecast(), {
          retryHint: "Select an image and retry.",
        });
        return;
      }
      if (key === "crop_square") {
        runWithUserError("Square crop", () => cropSquare(), {
          retryHint: "Select an image and retry.",
        });
        return;
      }
      if (key === "combine") {
        runWithUserError("Combine", () => runBlendPair(), {
          retryHint: "Select exactly 2 images and retry.",
        });
        return;
      }
      if (key === "bridge") {
        runWithUserError("Bridge", () => runBridgePair(), {
          retryHint: "Select exactly 2 images and retry.",
        });
        return;
      }
      if (key === "swap_dna") {
        runWithUserError("Swap DNA", () => runSwapDnaPair({ invert: Boolean(ev?.shiftKey) }), {
          retryHint: "Select exactly 2 images and retry.",
        });
        return;
      }
      if (key === "extract_rule") {
        runWithUserError("Extract the Rule", () => runExtractRuleTriplet(), {
          statusScope: "Director",
          retryHint: "Select exactly 3 images and retry.",
        });
        return;
      }
      if (key === "odd_one_out") {
        runWithUserError("Odd One Out", () => runOddOneOutTriplet(), {
          statusScope: "Director",
          retryHint: "Select exactly 3 images and retry.",
        });
        return;
      }
      if (key === "triforce") {
        runWithUserError("Triforce", () => runTriforceTriplet(), {
          retryHint: "Select exactly 3 images and retry.",
        });
        return;
      }
    });

    frag.appendChild(btn);
  }

  root.appendChild(frag);
}

function renderQuickActions() {
  renderActionGrid();
}

async function handleSpawnNode(node) {
  if (!node) return;
  if (node.action === "blend_pair") {
    await runBlendPair();
    return;
  }
  if (node.action === "bg_white") {
    await applyBackground("white");
    return;
  }
  if (node.action === "bg_sweep") {
    await applyBackground("sweep");
    return;
  }
  if (node.action === "crop_square") {
    await cropSquare();
    return;
  }
  if (node.action === "variations") {
    await runVariations();
    return;
  }
}

function renderFilmstrip() {
  if (!els.filmstrip) return;
  if (!state.filmstripVisible || state.canvasMode === "multi") {
    els.filmstrip.classList.add("hidden");
    // Avoid accumulating observed nodes when we teardown/rebuild the filmstrip.
    if (thumbObserver) {
      try {
        thumbObserver.disconnect();
      } catch {
        // ignore
      }
    }
    state.thumbsById.clear();
    els.filmstrip.innerHTML = "";
    return;
  }
  els.filmstrip.classList.remove("hidden");
  ensureThumbObserver();
  // Avoid accumulating observed nodes when we teardown/rebuild the filmstrip.
  if (thumbObserver) {
    try {
      thumbObserver.disconnect();
    } catch {
      // ignore
    }
  }
  state.thumbsById.clear();
  els.filmstrip.innerHTML = "";
  const frag = document.createDocumentFragment();
  for (const item of state.images) {
    const div = document.createElement("div");
    div.className = "thumb" + (item.id === state.activeId ? " selected" : "");
    div.dataset.id = item.id;
    const img = document.createElement("img");
    img.alt = item.label || basename(item.path) || "Artifact";
    img.loading = "lazy";
    img.decoding = "async";
    img.dataset.path = item.path;
    // Give it something valid to avoid broken-image glyphs before we swap in a blob URL.
    img.src = THUMB_PLACEHOLDER_SRC;
    if (thumbObserver) {
      thumbObserver.observe(img);
    } else {
      ensureImageUrl(item.path)
        .then((url) => {
          if (url) img.src = url;
        })
        .catch(() => {});
    }
    div.appendChild(img);
    const label = document.createElement("div");
    label.className = "thumb-label";
    label.textContent = item.label || basename(item.path);
    div.appendChild(label);
    state.thumbsById.set(item.id, { rootEl: div, imgEl: img, labelEl: label });
    frag.appendChild(div);
  }
  els.filmstrip.appendChild(frag);
}

function appendFilmstripThumb(item) {
  if (!els.filmstrip || !item?.id || !item?.path) return;
  if (!state.filmstripVisible) return;
  if (state.canvasMode === "multi") return;
  if (state.thumbsById.has(item.id)) return;
  ensureThumbObserver();
  const div = document.createElement("div");
  div.className = "thumb" + (item.id === state.activeId ? " selected" : "");
  div.dataset.id = item.id;
  const img = document.createElement("img");
  img.alt = item.label || basename(item.path) || "Artifact";
  img.loading = "lazy";
  img.decoding = "async";
  img.dataset.path = item.path;
  img.src = THUMB_PLACEHOLDER_SRC;
  if (thumbObserver) {
    thumbObserver.observe(img);
  } else {
    ensureImageUrl(item.path)
      .then((url) => {
        if (url) img.src = url;
      })
      .catch(() => {});
  }
  div.appendChild(img);
  const label = document.createElement("div");
  label.className = "thumb-label";
  label.textContent = item.label || basename(item.path);
  div.appendChild(label);
  state.thumbsById.set(item.id, { rootEl: div, imgEl: img, labelEl: label });
  els.filmstrip.appendChild(div);
}

function setFilmstripSelected(prevId, nextId) {
  if (prevId && prevId !== nextId) {
    const prev = state.thumbsById.get(prevId);
    if (prev?.rootEl) prev.rootEl.classList.remove("selected");
  }
  const next = state.thumbsById.get(nextId);
  if (next?.rootEl) next.rootEl.classList.add("selected");
}

function updateFilmstripThumb(item) {
  if (!item?.id) return;
  const rec = state.thumbsById.get(item.id);
  if (!rec) return;
  if (rec.labelEl) rec.labelEl.textContent = item.label || basename(item.path);
  if (rec.imgEl && item.path) {
    rec.imgEl.alt = item.label || basename(item.path) || "Artifact";
    rec.imgEl.dataset.path = item.path;
    rec.imgEl.src = THUMB_PLACEHOLDER_SRC;
    if (thumbObserver) {
      thumbObserver.observe(rec.imgEl);
    } else {
      ensureImageUrl(item.path)
        .then((url) => {
          if (url) rec.imgEl.src = url;
        })
        .catch(() => {});
    }
  }
}

function _timelineMakeNodeId() {
  return `tl-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
}

function recordTimelineNode({ imageId, path, receiptPath = null, label = null, action = null, parents = [] } = {}) {
  if (!imageId || !path) return null;
  const nodeId = _timelineMakeNodeId();
  const parentIds = Array.isArray(parents)
    ? Array.from(new Set(parents.map((p) => String(p || "")).filter(Boolean)))
    : [];
  const node = {
    nodeId,
    imageId: String(imageId),
    path: String(path),
    receiptPath: receiptPath ? String(receiptPath) : null,
    label: label ? String(label) : basename(path),
    action: action ? String(action) : null,
    parents: parentIds,
    createdAt: Date.now(),
  };
  state.timelineNodes.push(node);
  state.timelineNodesById.set(nodeId, node);
  if (state.timelineOpen) renderTimeline();
  return nodeId;
}

function ensureTimelineNodeForImageItem(item) {
  if (!item || !item.id || !item.path) return null;
  if (item.timelineNodeId && state.timelineNodesById.has(item.timelineNodeId)) return item.timelineNodeId;
  const action = item.timelineAction || item.kind || null;
  const parents = Array.isArray(item.timelineParents) ? item.timelineParents : [];
  const nodeId = recordTimelineNode({
    imageId: item.id,
    path: item.path,
    receiptPath: item.receiptPath || null,
    label: item.label || null,
    action,
    parents,
  });
  item.timelineNodeId = nodeId;
  // Clear one-shot metadata (keeps `state.images` objects tidy).
  if ("timelineAction" in item) delete item.timelineAction;
  if ("timelineParents" in item) delete item.timelineParents;
  return nodeId;
}

function openTimeline() {
  if (!els.timelineOverlay) return;
  state.timelineOpen = true;
  els.timelineOverlay.classList.remove("hidden");
  renderTimeline();
}

function closeTimeline() {
  if (!els.timelineOverlay) return;
  state.timelineOpen = false;
  els.timelineOverlay.classList.add("hidden");
}

function renderTimeline() {
  if (!state.timelineOpen) return;
  const strip = els.timelineStrip;
  const detail = els.timelineDetail;
  if (!strip) return;
  strip.innerHTML = "";

  const nodes = Array.from(state.timelineNodes || []).sort((a, b) => (a?.createdAt || 0) - (b?.createdAt || 0));
  if (!nodes.length) {
    const empty = document.createElement("div");
    empty.className = "muted";
    empty.textContent = "No timeline yet.";
    strip.appendChild(empty);
    if (detail) detail.textContent = "";
    return;
  }

  const activeNodeId = getActiveImage()?.timelineNodeId || null;
  let activeNode = activeNodeId ? state.timelineNodesById.get(activeNodeId) : null;
  if (!activeNode && activeNodeId) {
    activeNode = nodes.find((n) => n?.nodeId === activeNodeId) || null;
  }

  const frag = document.createDocumentFragment();
  for (const node of nodes) {
    if (!node?.nodeId || !node.path) continue;
    const card = document.createElement("div");
    card.className = "timeline-card" + (activeNodeId && node.nodeId === activeNodeId ? " selected" : "");
    card.dataset.nodeId = node.nodeId;
    card.tabIndex = 0;
    const img = document.createElement("img");
    img.alt = node.label || basename(node.path) || "Timeline item";
    img.loading = "lazy";
    img.decoding = "async";
    img.src = THUMB_PLACEHOLDER_SRC;
    ensureImageUrl(node.path)
      .then((url) => {
        if (url) img.src = url;
      })
      .catch(() => {});
    card.appendChild(img);
    const meta = document.createElement("div");
    meta.className = "timeline-meta";
    const action = document.createElement("div");
    action.className = "timeline-action";
    action.textContent = node.action ? String(node.action) : "artifact";
    const name = document.createElement("div");
    name.textContent = node.label || basename(node.path);
    meta.appendChild(action);
    meta.appendChild(name);
    card.appendChild(meta);
    frag.appendChild(card);
  }
  strip.appendChild(frag);

  if (detail) {
    if (!activeNode) {
      detail.textContent = "Select a point in time to jump back.";
    } else {
      const pieces = [];
      pieces.push(activeNode.action ? `Action: ${activeNode.action}` : "Action: (unknown)");
      pieces.push(`File: ${basename(activeNode.path)}`);
      if (activeNode.parents?.length) pieces.push(`Parents: ${activeNode.parents.length}`);
      detail.textContent = pieces.join("\n");
    }
  }
}

async function jumpToTimelineNode(nodeId) {
  const node = nodeId ? state.timelineNodesById.get(nodeId) : null;
  if (!node) return;

  const imgItem = state.imagesById.get(node.imageId) || null;
  if (!imgItem) {
    showToast("Timeline item no longer in canvas.", "error", 2400);
    return;
  }

  if (state.activeId !== imgItem.id) {
    await setActiveImage(imgItem.id, {
      source: "timeline",
      reason: "timeline_jump",
    }).catch(() => {});
  }

  if (imgItem.path !== node.path) {
    const ok = await replaceImageInPlace(imgItem.id, {
      path: node.path,
      receiptPath: node.receiptPath || null,
      kind: imgItem.kind,
      clearVision: true,
      source: "timeline",
      reason: "timeline_jump",
    });
    if (!ok) return;
  }

  imgItem.timelineNodeId = node.nodeId;
  renderTimeline();
}

const USER_ACTIVE_IMAGE_EVENT_SOURCES = new Set(["user_select", "filmstrip_click", "timeline"]);
function activeImageEventActorForSource(source = "system", explicitActor = null) {
  if (explicitActor === "user" || explicitActor === "system") return explicitActor;
  const normalizedSource = String(source || "system").trim();
  return USER_ACTIVE_IMAGE_EVENT_SOURCES.has(normalizedSource) ? "user" : "system";
}

async function setActiveImage(id, { preserveSelection = false, source = "system", reason = null, actor = null } = {}) {
  const item = state.imagesById.get(id);
  if (!item) return;
  const prevActive = state.activeId;
  state.activeId = id;
  if (preserveSelection) {
    // Ensure the newly-active image is included and keep multi-select ordering stable.
    const next = getSelectedIds();
    setSelectedIds(next.length > 3 ? next.slice(next.length - 3) : next);
  } else {
    setSelectedIds([id]);
  }
  if (prevActive !== id) {
    const eventActor = activeImageEventActorForSource(source, actor);
    recordUserEvent("active_image_change", {
      actor: eventActor,
      source: String(source || "system"),
      reason: reason ? String(reason) : null,
      canvas_mode: state.canvasMode,
      from_active_id: prevActive || null,
      active_id: id,
      selected_ids: getSelectedIds().slice(0, 3),
    });
  }
  setFilmstripSelected(prevActive, id);
  clearSelection();
  showDropHint(false);
  renderSelectionMeta();
  renderQuickActions();
  chooseSpawnNodes();
  await setEngineActiveImage(item.path);
  if (!item.visionDesc) {
    scheduleVisionDescribe(item.path, { priority: true, fallback: true });
  }
  try {
    item.img = await loadImage(item.path);
    item.width = item.img?.naturalWidth || null;
    item.height = item.img?.naturalHeight || null;
  } catch (err) {
    console.error(err);
  }
  renderHudReadout();
  resetViewToFit();
  requestRender();
  if (state.timelineOpen) renderTimeline();
}

function addImage(item, { select = false, deferAlwaysOnVision = false, deferAmbientIntent = false } = {}) {
  if (!item || !item.id || !item.path) return;
  if (state.imagesById.has(item.id)) return;
  const assignedPaletteIndex = Number(item.uiPaletteIndex);
  if (!Number.isFinite(assignedPaletteIndex) || assignedPaletteIndex < 0) {
    const nextPaletteIndex = Math.max(0, Math.floor(Number(state.imagePaletteSeed) || 0));
    item.uiPaletteIndex = nextPaletteIndex;
    state.imagePaletteSeed = nextPaletteIndex + 1;
  } else {
    state.imagePaletteSeed = Math.max(
      Math.floor(Number(state.imagePaletteSeed) || 0),
      Math.floor(assignedPaletteIndex) + 1
    );
  }
  state.imagesById.set(item.id, item);
  state.images.push(item);
  if (!state.freeformZOrder.includes(item.id)) {
    state.freeformZOrder.push(item.id);
  }
  ensureTimelineNodeForImageItem(item);
  appendFilmstripThumb(item);
  if (state.canvasMode === "multi") {
    // Multi-canvas is the "working set"; keep HUD descriptions available for all tiles.
    scheduleVisionDescribe(item.path, { fallback: true });
  }
  if (item.receiptPath && !item.receiptMetaChecked) {
    ensureReceiptMeta(item).catch(() => {});
  }
  showDropHint(false);
  scheduleVisualPromptWrite();
  if (!deferAlwaysOnVision) {
    markAlwaysOnVisionDirty("image_add");
    scheduleAlwaysOnVision();
  }
  recordUserEvent("image_add", {
    image_id: String(item.id),
    kind: item.kind ? String(item.kind) : null,
    file: item.path ? basename(item.path) : null,
    n_images: state.images.length,
  });
  if (!deferAmbientIntent && intentAmbientActive()) {
    updateEmptyCanvasHint();
    scheduleAmbientIntentInference({ immediate: true, reason: "add", imageIds: [item.id] });
  }
  if (intentModeActive()) {
    scheduleIntentStateWrite();
  }
  if (select || !state.activeId) {
    setActiveImage(item.id).catch(() => {});
  }
  motherIdleSyncFromInteraction({ userInteraction: false });
  syncMotherPortrait();
}

async function removeImageFromCanvas(imageId) {
  const id = String(imageId || "");
  if (!id) return false;
  if (state.motherResultDetailsOpenId === id) {
    state.motherResultDetailsOpenId = null;
  }
  const item = state.imagesById.get(id) || null;
  if (!item) return false;
  recordUserEvent("image_remove", {
    image_id: id,
    file: item?.path ? basename(item.path) : null,
    n_images_before: state.images.length,
  });

  hideImageMenu();

  if (item?.path) {
    invalidateImageCache(item.path);
    dropVisionDescribePath(item.path, { cancelInFlight: true });
  }

  // Drop per-image marks.
  state.circlesByImageId.delete(id);
  clearEffectTokenForImageId(id);
  if (state.effectTokenDrag) {
    const dragTokenId = String(state.effectTokenDrag.tokenId || "");
    const dragSourceId = String(state.effectTokenDrag.sourceImageId || "");
    if (dragSourceId === id || !state.effectTokensById.has(dragTokenId)) {
      state.effectTokenDrag = null;
    }
  }

  // Remove from collections.
  state.imagesById.delete(id);
  state.images = (state.images || []).filter((item) => item?.id !== id);
  state.freeformRects.delete(id);
  state.freeformZOrder = (state.freeformZOrder || []).filter((v) => v !== id);
  state.multiRects.delete(id);
  // Maintain multi-select.
  setSelectedIds(getSelectedIds().filter((v) => v !== id));

  // Remove filmstrip thumb if present (filmstrip might be hidden in multi mode).
  const thumb = state.thumbsById.get(id);
  if (thumb?.rootEl && thumb.rootEl.parentNode) {
    try {
      thumb.rootEl.parentNode.removeChild(thumb.rootEl);
    } catch {
      // ignore
    }
  }
  state.thumbsById.delete(id);

  // If we removed the active image, select a sensible next.
  if (state.activeId === id) {
    state.activeId = null;
    const selected = Array.isArray(state.selectedIds) ? state.selectedIds : [];
    const nextSelectedId = selected.length ? selected[selected.length - 1] : null;
    const nextSelected = nextSelectedId ? state.imagesById.get(nextSelectedId) : null;
    const next = nextSelected || (state.images.length ? state.images[state.images.length - 1] : null);
    if (next?.id) await setActiveImage(next.id, { preserveSelection: true });
  }

  if (state.images.length === 0) {
    clearImageCache();
    state.imagePaletteSeed = 0;
    state.activeId = null;
    state.selectedIds = [];
    state.canvasMode = "multi";
    state.freeformRects.clear();
    state.freeformZOrder = [];
    state.multiRects.clear();
    state.pendingBlend = null;
    state.pendingSwapDna = null;
    state.pendingBridge = null;
    state.pendingExtractDna = null;
    state.pendingSoulLeech = null;
    state.pendingRecast = null;
    state.pendingPromptGenerate = null;
    clearAllEffectTokens();
    clearSelection();
    if (state.intent && !state.intent.locked) {
      state.intent.lockedAt = 0;
      state.intent.lockedBranchId = null;
      state.intent.startedAt = 0;
      state.intent.deadlineAt = 0;
      state.intent.round = 1;
      state.intent.selections = [];
      state.intent.focusBranchId = null;
      state.intent.iconState = null;
      state.intent.iconStateAt = 0;
      state.intent.pending = false;
      state.intent.pendingPath = null;
      state.intent.pendingAt = 0;
      state.intent.pendingFrameId = null;
      state.intent.rtState = "off";
      state.intent.disabledReason = null;
      state.intent.lastError = null;
      state.intent.lastErrorAt = 0;
      state.intent.lastSignature = null;
      state.intent.lastRunAt = 0;
      state.intent.forceChoice = false;
      state.intent.uiHits = [];
      clearTimeout(intentInferenceTimer);
      intentInferenceTimer = null;
      clearTimeout(intentInferenceTimeout);
      intentInferenceTimeout = null;
      stopIntentTicker();
      if (state.ptySpawned) {
        invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_STOP}\n` }).catch(() => {});
      }
      syncIntentModeClass();
      scheduleIntentStateWrite({ immediate: true });
    }
    resetAmbientIntentState();
    if (state.ptySpawned) {
      invoke("write_pty", { data: `${PTY_COMMANDS.INTENT_RT_STOP}\n` }).catch(() => {});
    }
    updateEmptyCanvasHint();
    setTip(DEFAULT_TIP);
    setDirectorText(null, null);
    renderFilmstrip();
    renderQuickActions();
    renderHudReadout();
    motherIdleSyncFromInteraction({ userInteraction: false });
    state.alwaysOnVision.contentDirty = false;
    state.alwaysOnVision.dirtyReason = null;
    requestRender();
    return true;
  }

  renderFilmstrip();

  updateEmptyCanvasHint();
  scheduleVisualPromptWrite();
  markAlwaysOnVisionDirty("image_remove");
  scheduleAlwaysOnVision();
  if (intentAmbientActive()) scheduleAmbientIntentInference({ immediate: true, reason: "remove" });
  scheduleIntentStateWrite();
  renderQuickActions();
  renderHudReadout();
  motherIdleSyncFromInteraction({ userInteraction: false });
  requestRender();
  return true;
}

function invalidateImageCache(path) {
  if (!path) return;
  const rec = state.imageCache.get(path);
  if (!rec) return;
  if (rec.url) {
    try {
      URL.revokeObjectURL(rec.url);
    } catch {
      // ignore
    }
  }
  state.imageCache.delete(path);
}

async function replaceImageInPlace(
  targetId,
  { path, receiptPath = null, kind = null, label = null, clearVision = true } = {}
) {
  const item = state.imagesById.get(targetId);
  if (!item || !path) return false;
  clearEffectTokenForImageId(targetId);
  const oldPath = item.path;
  if (oldPath && oldPath !== path) {
    invalidateImageCache(oldPath);
    dropVisionDescribePath(oldPath, { cancelInFlight: true });
  }
  // New paths are always new files; no need to invalidate unless we overwrite, but be safe.
  invalidateImageCache(path);

  item.path = path;
  item.receiptPath = receiptPath;
  item.receiptMeta = null;
  item.receiptMetaChecked = false;
  item.receiptMetaLoading = false;
  if (kind) item.kind = kind;
  const explicitLabel = typeof label === "string" ? label.trim() : "";
  if (explicitLabel) {
    item.label = explicitLabel;
  } else if (path && oldPath && oldPath !== path) {
    const oldPathLabel = basename(oldPath || "");
    const nextPathLabel = basename(path || "");
    const currentLabel = String(item.label || "").trim();
    // If the label still mirrors the old path (or is empty), keep it in sync with the new file path.
    if (!currentLabel || (oldPathLabel && currentLabel === oldPathLabel)) {
      if (nextPathLabel) item.label = nextPathLabel;
    }
  }
  item.img = null;
  item.width = null;
  item.height = null;
  if (clearVision) {
    item.visionDesc = null;
    item.visionPending = false;
    if (state.describePendingPath === oldPath) state.describePendingPath = null;
  }

  updateFilmstripThumb(item);
  if (item.receiptPath) ensureReceiptMeta(item).catch(() => {});
  if (state.activeId === targetId) {
    try {
      item.img = await loadImage(item.path);
      item.width = item.img?.naturalWidth || null;
      item.height = item.img?.naturalHeight || null;
    } catch (err) {
      console.error(err);
    }
    await setEngineActiveImage(item.path);
    if (!item.visionDesc) scheduleVisionDescribe(item.path, { priority: true, fallback: true });
    renderSelectionMeta();
    chooseSpawnNodes();
    renderHudReadout();
    resetViewToFit();
    requestRender();
  }
  scheduleVisualPromptWrite();
  markAlwaysOnVisionDirty("image_replace");
  scheduleAlwaysOnVision();
  motherIdleSyncFromInteraction({ userInteraction: false });
  if (intentAmbientActive()) {
    scheduleAmbientIntentInference({ immediate: true, reason: "replace", imageIds: [targetId] });
  }
  return true;
}

async function setEngineActiveImage(path) {
  if (!path) return;
  if (!state.ptySpawned) {
    // Active image tracking is best-effort; don't block UI if engine isn't ready yet.
    return;
  }
  await invoke("write_pty", { data: `${PTY_COMMANDS.USE} ${quoteForPtyArg(path)}\n` }).catch(() => {
    state.ptySpawned = false;
  });
}

function restoreEngineImageModelIfNeeded() {
  const restore = state.engineImageModelRestore;
  if (!restore) return;
  state.engineImageModelRestore = null;
  if (!state.ptySpawned) return;
  invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${restore}\n` }).catch(() => {});
}

async function maybeOverrideEngineImageModel(desiredModel) {
  const desired = String(desiredModel || "").trim();
  if (!desired) return false;
  if (!state.ptySpawned) return false;
  if (desired === settings.imageModel) return false;
  state.engineImageModelRestore = settings.imageModel;
  await invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${desired}\n` }).catch(() => {});
  return true;
}

async function writeLocalReceipt({ artifactId, imagePath, operation, meta = {} }) {
  if (!state.runDir) return null;
  const receiptPath = `${state.runDir}/receipt-${artifactId}.json`;
  const payload = {
    schema_version: 1,
    request: {
      prompt: "",
      mode: "local",
      size: null,
      n: 1,
      seed: null,
      output_format: extname(imagePath).replace(".", "") || "png",
      inputs: { init_image: null, mask: null, reference_images: [] },
      provider: "local",
      model: null,
      provider_options: {},
      out_dir: state.runDir,
      metadata: { operation },
    },
    resolved: {
      provider: "local",
      model: null,
      size: null,
      width: null,
      height: null,
      output_format: extname(imagePath).replace(".", "") || "png",
      background: null,
      seed: null,
      n: 1,
      user: null,
      prompt: "",
      inputs: { init_image: null, mask: null, reference_images: [] },
      stream: false,
      partial_images: null,
      provider_params: {},
      warnings: [],
    },
    provider_request: {},
    provider_response: {},
    warnings: [],
    artifacts: { image_path: imagePath, receipt_path: receiptPath },
    result_metadata: { operation, ...meta, created_at: new Date().toISOString() },
  };
  await writeTextFile(receiptPath, JSON.stringify(payload, null, 2));
  return receiptPath;
}

function isoFromMs(ms) {
  const t = typeof ms === "number" && Number.isFinite(ms) ? ms : Date.now();
  try {
    return new Date(t).toISOString();
  } catch {
    return new Date().toISOString();
  }
}

function buildVisualPrompt() {
  const nowIso = new Date().toISOString();
  const canvas = els.workCanvas;
  const dpr = getDpr();
  const active = getActiveImage();

  let multiRects = null;
  if (state.canvasMode === "multi" && canvas) {
    const rectMap =
      state.multiRects && state.multiRects.size ? state.multiRects : computeFreeformRectsPx(canvas.width, canvas.height);
    multiRects = Array.from(rectMap.entries()).map(([imageId, rect]) => ({
      image_id: String(imageId),
      x: Number(rect?.x) || 0,
      y: Number(rect?.y) || 0,
      w: Number(rect?.w) || 0,
      h: Number(rect?.h) || 0,
      cell_x: Number(rect?.cellX) || 0,
      cell_y: Number(rect?.cellY) || 0,
      cell_w: Number(rect?.cellW) || 0,
      cell_h: Number(rect?.cellH) || 0,
    }));
  }

  const images = state.images.map((item) => ({
    id: String(item?.id || ""),
    kind: item?.kind ? String(item.kind) : null,
    source: item?.source ? String(item.source) : "user",
    path: item?.path ? String(item.path) : null,
    label: item?.label ? String(item.label) : null,
    width: Number(item?.img?.naturalWidth || item?.width) || null,
    height: Number(item?.img?.naturalHeight || item?.height) || null,
    // Optional vision-side description of the image contents (e.g., "couch").
    // This is written for run trace/debugging only; intent inference remains images-only.
    vision_desc: item?.visionDesc ? String(item.visionDesc) : null,
    vision_desc_meta: item?.visionDescMeta
      ? {
          source: item.visionDescMeta?.source ? String(item.visionDescMeta.source) : null,
          model: item.visionDescMeta?.model ? String(item.visionDescMeta.model) : null,
          at_ms: Number(item.visionDescMeta?.at) || null,
        }
      : null,
  }));

  const marks = [];

  // Lasso polygon (active image only).
  if (active?.id && state.selection?.points?.length >= 3) {
    const atMs = Number(state.selection?.at) || Date.now();
    marks.push({
      id: `lasso-${atMs}`,
      type: "lasso_polygon",
      color: "rgba(255, 179, 0, 0.95)",
      label: null,
      target_image_id: String(active.id),
      image_space: {
        points: state.selection.points.map((pt) => ({
          x: Number(pt?.x) || 0,
          y: Number(pt?.y) || 0,
        })),
      },
      created_at: isoFromMs(atMs),
    });
  }

  // Annotate box (draft/final, active image only).
  if (active?.id && state.annotateBox && state.annotateBox.imageId === active.id) {
    const atMs = Number(state.annotateBox?.at) || Date.now();
    const label = String(els.annotateText?.value || "").trim() || null;
    marks.push({
      id: `box-${atMs}`,
      type: "box",
      color: "rgba(82, 255, 148, 0.92)",
      label,
      target_image_id: String(active.id),
      image_space: {
        x0: Number(state.annotateBox?.x0) || 0,
        y0: Number(state.annotateBox?.y0) || 0,
        x1: Number(state.annotateBox?.x1) || 0,
        y1: Number(state.annotateBox?.y1) || 0,
      },
      created_at: isoFromMs(atMs),
    });
  }

  // Circles.
  for (const [imageId, list] of Array.from(state.circlesByImageId.entries())) {
    const imageKey = String(imageId || "");
    if (!imageKey || !Array.isArray(list)) continue;
    for (const circle of list) {
      const atMs = Number(circle?.at) || Date.now();
      marks.push({
        id: String(circle?.id || `c-${atMs}`),
        type: "circle",
        color: circle?.color ? String(circle.color) : "rgba(255, 95, 95, 0.92)",
        label: circle?.label ? String(circle.label) : null,
        target_image_id: imageKey,
        image_space: {
          cx: Number(circle?.cx) || 0,
          cy: Number(circle?.cy) || 0,
          r: Number(circle?.r) || 0,
        },
        created_at: isoFromMs(atMs),
      });
    }
  }

  return {
    schema: "brood.visual_prompt",
    schema_version: VISUAL_PROMPT_SCHEMA_VERSION,
    visual_grammar_version: VISUAL_GRAMMAR_VERSION,
    updated_at: nowIso,
    run_dir: state.runDir ? String(state.runDir) : null,
    canvas: {
      mode: state.canvasMode,
      dpr,
      size_px: canvas ? { w: canvas.width || 0, h: canvas.height || 0 } : null,
      tool: state.tool,
      active_image_id: state.activeId ? String(state.activeId) : null,
      view: {
        scale: Number(state.view?.scale) || 1,
        offset_x: Number(state.view?.offsetX) || 0,
        offset_y: Number(state.view?.offsetY) || 0,
      },
      multi_view: {
        scale: Number(state.multiView?.scale) || 1,
        offset_x: Number(state.multiView?.offsetX) || 0,
        offset_y: Number(state.multiView?.offsetY) || 0,
      },
      multi_rects_px: multiRects,
    },
    images,
    marks,
  };
}

async function writeVisualPrompt() {
  if (!state.runDir) return false;
  const outPath = `${state.runDir}/${VISUAL_PROMPT_FILENAME}`;
  const payload = buildVisualPrompt();
  await writeTextFile(outPath, JSON.stringify(payload, null, 2));
  return true;
}

function _defaultImportPointCss() {
  const wrap = els.canvasWrap;
  const w = wrap?.clientWidth || 0;
  const h = wrap?.clientHeight || 0;
  return { x: Math.round(w * 0.5), y: Math.round(h * 0.5) };
}

function _computeImportPlacementsCss(n, center, tile, gap, canvasCssW, canvasCssH) {
  const count = Math.max(0, Number(n) || 0);
  if (!count) return [];
  const margin = 14;
  let cols = 1;
  if (count === 2) cols = 2;
  else if (count <= 4) cols = 2;
  else cols = 3;
  const rows = Math.ceil(count / cols);
  const clusterW = cols * tile + (cols - 1) * gap;
  const clusterH = rows * tile + (rows - 1) * gap;
  const maxX = Math.max(margin, Math.round(canvasCssW - clusterW - margin));
  const maxY = Math.max(margin, Math.round(canvasCssH - clusterH - margin));
  const startX = clamp(Math.round((Number(center?.x) || 0) - clusterW / 2), margin, maxX);
  const startY = clamp(Math.round((Number(center?.y) || 0) - clusterH / 2), margin, maxY);
  const out = [];
  for (let i = 0; i < count; i += 1) {
    const col = i % cols;
    const row = Math.floor(i / cols);
    out.push({
      x: Math.round(startX + col * (tile + gap)),
      y: Math.round(startY + row * (tile + gap)),
      w: tile,
      h: tile,
    });
  }
  return out;
}

function seedPromptGeneratePlacementRectCss(artifactId, pendingPromptGenerate = null) {
  const id = String(artifactId || "").trim();
  if (!id || state.freeformRects.has(id)) return;

  const wrap = els.canvasWrap;
  const canvasCssW = Number(wrap?.clientWidth) || 0;
  const canvasCssH = Number(wrap?.clientHeight) || 0;
  if (!(canvasCssW > 0 && canvasCssH > 0)) return;

  const totalAfter = (state.images?.length || 0) + 1;
  const tile = freeformDefaultTileCss(canvasCssW, canvasCssH, { count: Math.max(1, totalAfter) });
  const anchorWorldCss = pendingPromptGenerate?.anchorWorldCss
    ? {
        x: Number(pendingPromptGenerate.anchorWorldCss.x) || 0,
        y: Number(pendingPromptGenerate.anchorWorldCss.y) || 0,
      }
    : canvasScreenCssToWorldCss(currentPromptGenerateAnchorCss(pendingPromptGenerate?.anchorCss || null));
  const rect = clampFreeformRectCss(
    {
      x: Math.round((Number(anchorWorldCss.x) || 0) - tile / 2),
      y: Math.round((Number(anchorWorldCss.y) || 0) - tile / 2),
      w: tile,
      h: tile,
      autoAspect: true,
    },
    canvasCssW,
    canvasCssH,
    freeformWorkspaceClampOptions(canvasCssW, canvasCssH, { minSize: 44 })
  );
  state.freeformRects.set(id, rect);
}

async function importLocalPathsAtCanvasPoint(
  paths,
  pointCss,
  { source = "picker", idPrefix = "input", enforceIntentLimit = true, focusImported = false } = {}
) {
  let list = (Array.isArray(paths) ? paths : [paths])
    .map((v) => normalizeLocalFsPath(typeof v === "string" ? v : ""))
    .filter(Boolean);
  if (String(source || "").startsWith("browser")) {
    try {
      list = await fileBrowserResolveImportPaths(list);
    } catch {
      // keep original list on resolver errors
    }
  }
  if (!list.length) {
    setStatus("Engine: ready");
    return { ok: 0, failed: 0, importedIds: [] };
  }

  const INTENT_MAX_PHOTOS = 5;
  const intentActive = intentModeActive();
  let importable = list.filter((path) => isBrowserImagePath(path));
  if (enforceIntentLimit && intentActive) {
    const remaining = Math.max(0, INTENT_MAX_PHOTOS - (state.images?.length || 0));
    if (remaining <= 0) {
      showToast(`Intent Mode: only ${INTENT_MAX_PHOTOS} photos allowed.`, "tip", 2600);
      setStatus("Engine: ready");
      return { ok: 0, failed: 0, importedIds: [] };
    }
    if (importable.length > remaining) {
      importable = importable.slice(0, remaining);
      showToast(`Intent Mode: only ${INTENT_MAX_PHOTOS} photos allowed.`, "tip", 2600);
    }
  }
  if (!importable.length) {
    setStatus("Engine: ready");
    return { ok: 0, failed: 0, importedIds: [] };
  }

  await ensureRun();
  const inputsDir = `${state.runDir}/inputs`;
  await createDir(inputsDir, { recursive: true }).catch(() => {});
  const stamp = Date.now();

  const wrap = els.canvasWrap;
  const canvasCssW = wrap?.clientWidth || 0;
  const canvasCssH = wrap?.clientHeight || 0;
  const totalAfter = (state.images?.length || 0) + importable.length;
  const tile = freeformDefaultTileCss(canvasCssW, canvasCssH, { count: totalAfter });
  const gap = Math.round(tile * 0.11);
  const placements = _computeImportPlacementsCss(importable.length, pointCss, tile, gap, canvasCssW, canvasCssH);

  let ok = 0;
  let failed = 0;
  let lastErr = null;
  const importedIds = [];
  const importedVisionPaths = [];
  for (let idx = 0; idx < importable.length; idx += 1) {
    const src = importable[idx];
    try {
      const ext = extname(src);
      const safeExt = ext && ext.length <= 8 ? ext : ".png";
      const artifactId = `${idPrefix}-${stamp}-${String(idx).padStart(2, "0")}`;
      const dest = `${inputsDir}/${artifactId}${safeExt}`;
      const place = placements[idx] || null;
      if (place && artifactId) {
        state.freeformRects.set(artifactId, { ...place, autoAspect: true });
      }
      await copyFile(src, dest);
      const receiptPath = await writeLocalReceipt({
        artifactId,
        imagePath: dest,
        operation: "import",
        meta: { source_path: src, source },
      });
      addImage(
        {
          id: artifactId,
          kind: "import",
          path: dest,
          receiptPath,
          label: basename(src),
        },
        {
          select: focusImported ? ok === 0 : ok === 0 && !state.activeId,
          deferAlwaysOnVision: true,
          deferAmbientIntent: true,
        }
      );
      importedIds.push(artifactId);
      importedVisionPaths.push(dest);
      ok += 1;
    } catch (err) {
      failed += 1;
      lastErr = err;
      console.error("Import failed:", src, err);
    }
  }

  if (ok <= 0) {
    const msg = lastErr?.message || String(lastErr || "unknown error");
    setStatus(`Engine: import failed (${msg})`, true);
    return { ok, failed, importedIds };
  }

  const motherIdle = state.motherIdle;
  if (motherIdle) {
    motherIdle.lastUploadCompletedAt = Date.now();
    motherIdle.speculativePrefetchReadyMode = null;
    motherV2ClearSpeculativePrefetchTimer();
  }
  motherV2ArmMultiUploadIdleBoost(ok);
  if (
    motherIdle &&
    ok >= MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL &&
    !state.pointer.active &&
    !motherV2InCooldown()
  ) {
    if (motherIdle.phase === MOTHER_IDLE_STATES.OBSERVING) {
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
    } else if (motherIdle.phase === MOTHER_IDLE_STATES.WATCHING) {
      motherIdleTransitionTo(MOTHER_IDLE_EVENTS.IDLE_WINDOW_ELAPSED);
    }
    if (state.motherIdle?.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
      motherV2RequestIntentInference({
        snapshotLoadTimeoutMs: MOTHER_V2_UPLOAD_FAST_INTENT_SNAPSHOT_WAIT_MS,
        snapshotMaxDimPx: MOTHER_V2_UPLOAD_FAST_INTENT_SNAPSHOT_MAX_DIM_PX,
        scheduleVisionLabels: false,
        fastUploadPath: true,
      }).catch(() => {});
    }
  }
  const deferUploadVision =
    Boolean(motherIdle) &&
    ok >= MOTHER_V2_MIN_IMAGES_FOR_PROPOSAL &&
    String(state.motherIdle?.phase || "") === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING;
  markAlwaysOnVisionDirty("image_add_batch");
  if (deferUploadVision) {
    const burstPaths = importedVisionPaths.slice();
    setTimeout(() => {
      if (!state.images.length) return;
      scheduleAlwaysOnVision();
      scheduleVisionDescribeBurst(burstPaths, {
        priority: true,
        maxConcurrent: 1,
      });
    }, MOTHER_V2_UPLOAD_VISION_DEFER_MS);
  } else {
    scheduleAlwaysOnVision();
    scheduleVisionDescribeBurst(importedVisionPaths, {
      priority: true,
      maxConcurrent: UPLOAD_DESCRIBE_PRIORITY_BURST,
    });
  }
  const suffix = failed ? ` (${failed} failed)` : "";
  setStatus(`Engine: imported ${ok} photo${ok === 1 ? "" : "s"}${suffix}`, failed > 0);

  if (state.images.length > 1 && state.canvasMode !== "multi") {
    setCanvasMode("multi");
    if (!intentActive) {
      setTip("Multiple photos loaded. Click a photo to focus it. Press M to toggle multi view.");
    }
  }
  if (intentActive && !state.intent.startedAt) {
    state.intent.startedAt = Date.now();
    state.intent.deadlineAt = state.intent.startedAt + INTENT_DEADLINE_MS;
    state.intent.rtState = "connecting";
    ensureIntentTicker();
  }
  if (intentActive) {
    updateEmptyCanvasHint();
    scheduleIntentInference({ immediate: true, reason: "import" });
    scheduleIntentStateWrite({ immediate: true });
  }
  if (intentAmbientActive()) {
    const touched = importedIds.filter((id) => state.imagesById.has(id));
    if (touched.length) {
      setTimeout(() => {
        const visibleTouched = touched.filter((id) => state.imagesById.has(id));
        if (!visibleTouched.length) return;
        scheduleAmbientIntentInference({
          immediate: false,
          reason: "import_batch",
          imageIds: visibleTouched,
        });
      }, INTENT_AMBIENT_IMPORT_DELAY_MS);
    }
  }
  requestRender();
  return { ok, failed, importedIds };
}

async function importPhotosAtCanvasPoint(pointCss) {
  bumpInteraction();
  setStatus("Engine: pick photosâ€¦");
  const picked = await open({
    multiple: true,
    filters: [{ name: "Images", extensions: ["png", "jpg", "jpeg", "webp", "heic"] }],
  });
  const pickedPaths = Array.isArray(picked) ? picked : picked ? [picked] : [];
  if (!pickedPaths.length) {
    setStatus("Engine: ready");
    return;
  }
  await importLocalPathsAtCanvasPoint(pickedPaths, pointCss, {
    source: "picker",
    idPrefix: "input",
    enforceIntentLimit: true,
  });
}

async function importPhotos() {
  await importPhotosAtCanvasPoint(canvasScreenCssToWorldCss(_defaultImportPointCss()));
}

async function cropSquare({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Crop: Square",
      key: "crop_square",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => cropSquare({ fromQueue: true }),
    });
    return;
  }
  state.lastAction = "Square Crop";
  const imgItem = getActiveImage();
  if (!imgItem || !imgItem.img) return;
  await ensureRun();
  beginRunningAction("crop_square");
  setImageFxActive(true, "Square Crop");
  portraitWorking("Square Crop");
  try {
    const img = imgItem.img;
    const w = img.naturalWidth;
    const h = img.naturalHeight;
    const size = Math.min(w, h);
    const sx = Math.floor((w - size) / 2);
    const sy = Math.floor((h - size) / 2);
    const canvas = document.createElement("canvas");
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(img, sx, sy, size, size, 0, 0, size, size);
    await saveCanvasAsArtifact(canvas, {
      operation: "crop_square",
      label: "Square crop",
      replaceActive: true,
      targetId: imgItem.id,
    });
  } finally {
    setImageFxActive(false);
    updatePortraitIdle();
    clearRunningAction("crop_square");
  }
}

async function aiReplaceBackground(style) {
  const imgItem = getActiveImage();
  if (!imgItem) {
    showToast("No image selected.", "error");
    return;
  }
  await ensureRun();
  const label = style === "sweep" ? "Soft Sweep" : "Studio White";
  setImageFxActive(true, label);
  portraitWorking(label, { providerOverride: providerFromModel(ACTION_IMAGE_MODEL.bg_replace) });
  beginPendingReplace(imgItem.id, label);
  try {
    const ok = await ensureEngineSpawned({ reason: label });
    if (!ok) throw new Error("Engine unavailable");
    await setEngineActiveImage(imgItem.path);
    await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.bg_replace);
    state.expectingArtifacts = true;
    state.lastAction = label;
    setStatus(`Engine: ${label}â€¦`);
    showToast(`Morphing: ${label}`, "info", 2200);

    // Must start with "replace" for Brood's edit detection.
    const prompt =
      style === "sweep"
        ? "replace the background with a soft studio sweep background. keep the subject exactly the same. preserve logos and text. do not crop."
        : "replace the background with a seamless studio white background. keep the subject exactly the same. preserve logos and text. do not crop.";
    await invoke("write_pty", { data: `${prompt}\n` });
  } catch (err) {
    clearPendingReplace();
    setImageFxActive(false);
    updatePortraitIdle();
    throw err;
  }
}

async function aiRemovePeople({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Remove People",
      key: "remove_people",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => aiRemovePeople({ fromQueue: true }),
    });
    return;
  }
  const imgItem = getActiveImage();
  if (!imgItem) {
    showToast("No image selected.", "error");
    return;
  }

  const label = "Remove People";
  await ensureRun();
  setImageFxActive(true, label);
  portraitWorking(label, { providerOverride: providerFromModel(ACTION_IMAGE_MODEL.remove_people) || "gemini" });
  beginPendingReplace(imgItem.id, label);
  try {
    const ok = await ensureEngineSpawned({ reason: label });
    if (!ok) throw new Error("Engine unavailable");
    await setEngineActiveImage(imgItem.path);
    state.expectingArtifacts = true;
    state.lastAction = label;
    setStatus(`Engine: ${label}â€¦`);
    showToast("Removing peopleâ€¦", "info", 2200);

    await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.remove_people || pickGeminiImageModel());

    // Must start with "edit" or "replace" for Brood's edit detection.
    const prompt =
      "edit the image: remove any people (humans) from the image completely. " +
      "fill in the background naturally. keep everything else exactly the same. " +
      "preserve logos and text. do not crop.";
    await invoke("write_pty", { data: `${prompt}\n` });
  } catch (err) {
    state.expectingArtifacts = false;
    state.engineImageModelRestore = null;
    clearPendingReplace();
    setImageFxActive(false);
    updatePortraitIdle();
    throw err;
  }
}

async function aiSurpriseMe({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Surprise Me",
      key: "surprise_me",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => aiSurpriseMe({ fromQueue: true }),
    });
    return;
  }
  const imgItem = getActiveImage();
  if (!imgItem) {
    showToast("No image selected.", "error");
    return;
  }

  const label = "Surprise Me";
  await ensureRun();
  setImageFxActive(true, label);
  portraitWorking(label, { providerOverride: providerFromModel(ACTION_IMAGE_MODEL.surprise) || "gemini" });
  beginPendingReplace(imgItem.id, label);
  try {
    const ok = await ensureEngineSpawned({ reason: label });
    if (!ok) throw new Error("Engine unavailable");
    await setEngineActiveImage(imgItem.path);
    state.expectingArtifacts = true;
    state.lastAction = label;
    setStatus(`Engine: ${label}â€¦`);
    showToast("Surprising youâ€¦", "info", 2200);

    await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.surprise || pickGeminiFastImageModel());

    const surprises = [
      "replace the background with a bold but clean gradient (no patterns) and add a subtle soft shadow under the product.",
      "make the lighting moodier and more dramatic (soft rim light + slightly deeper shadows) while keeping details crisp.",
      "add a minimal studio tabletop plane and a gentle vignette, keeping the product unchanged.",
      "add a tasteful subtle film look (slight contrast + very light grain), keeping all logos and text identical.",
      "replace the background with a bright high-key studio look with a soft floor reflection, keeping the subject exactly the same.",
    ];
    const chosen = surprises[Math.floor(Math.random() * surprises.length)] || surprises[0];

    // Must start with "edit" or "replace" for Brood's edit detection.
    const prompt =
      `edit the image: * surprise me.\n` +
      `${chosen}\n` +
      "Keep the subject exactly the same. Preserve all existing logos and text exactly. " +
      "Do not add any new people or readable text. Do not crop.";
    await invoke("write_pty", { data: `${prompt}\n` });
  } catch (err) {
    state.expectingArtifacts = false;
    state.engineImageModelRestore = null;
    clearPendingReplace();
    setImageFxActive(false);
    updatePortraitIdle();
    throw err;
  }
}

async function aiAnnotateEdit({
  fromQueue = false,
  targetId = null,
  boxOverride = null,
  instructionOverride = null,
  requestedModelOverride = null,
} = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  const activeItem = getActiveImage();
  const imgItem = targetId ? state.imagesById.get(targetId) || null : activeItem;
  if (!imgItem) {
    showToast("No image selected.", "error");
    return;
  }

  const box = boxOverride || state.annotateBox;
  if (!box || box.imageId !== imgItem.id) {
    showToast("Annotate: draw a box first.", "tip", 2200);
    return;
  }

  const instruction =
    typeof instructionOverride === "string"
      ? instructionOverride.trim()
      : String(els.annotateText?.value || "").trim();
  if (!instruction) {
    showToast("Annotate: enter an instruction.", "tip", 2200);
    return;
  }

  const requestedModel =
    typeof requestedModelOverride === "string"
      ? requestedModelOverride.trim()
      : String(els.annotateModel?.value || settings.imageModel || "").trim();

  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    const captured = {
      targetId: imgItem.id,
      box: { ...box },
      instruction,
      requestedModel,
    };

    // Mirror the "send" UX: clear the box + prompt input immediately, even if queued.
    if (els.annotateText) els.annotateText.value = "";
    state.annotateBox = null;
    state.annotateDraft = null;
    hideAnnotatePanel();
    scheduleVisualPromptWrite();
    requestRender();

    enqueueAction({
      label: "Annotate",
      key: `annotate:${captured.targetId}`,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () =>
        aiAnnotateEdit({
          fromQueue: true,
          targetId: captured.targetId,
          boxOverride: captured.box,
          instructionOverride: captured.instruction,
          requestedModelOverride: captured.requestedModel,
        }),
    });
    return;
  }

  // Keep the target image visible when replaying queued edits.
  if (state.activeId !== imgItem.id) {
    await setActiveImage(imgItem.id).catch(() => {});
  }

  let effectiveModel = requestedModel || settings.imageModel;
  if (providerFromModel(effectiveModel) !== "gemini") {
    effectiveModel = pickGeminiImageModel();
    if (!fromQueue) {
      showToast(`Annotate box edits currently require Gemini. Using ${effectiveModel}.`, "tip", 3200);
    }
  }
  const provider = providerFromModel(effectiveModel);
  const label = "Annotate";
  await ensureRun();
  setImageFxActive(true, label);
  portraitWorking(label, { providerOverride: provider });
  try {
    const ok = await ensureEngineSpawned({ reason: label });
    if (!ok) throw new Error("Engine unavailable");

    if (!imgItem.img) {
      setStatus("Engine: loading imageâ€¦");
      try {
        imgItem.img = await loadImage(imgItem.path);
        imgItem.width = imgItem.img?.naturalWidth || imgItem.width || null;
        imgItem.height = imgItem.img?.naturalHeight || imgItem.height || null;
      } catch (err) {
        showToast("Failed to load image.", "error", 3200);
        setStatus("Engine: ready");
        return;
      }
      setStatus("Engine: ready");
    }

    const normalized = _normalizeAnnotateBox(box, imgItem);
    if (!normalized) {
      showToast("Annotate: invalid box.", "error", 2600);
      return;
    }
    const x0 = Math.floor(Number(normalized.x0) || 0);
    const y0 = Math.floor(Number(normalized.y0) || 0);
    const x1 = Math.ceil(Number(normalized.x1) || 0);
    const y1 = Math.ceil(Number(normalized.y1) || 0);
    const wBox = Math.max(1, x1 - x0);
    const hBox = Math.max(1, y1 - y0);
    if (wBox < 8 || hBox < 8) {
      showToast("Annotate: box too small.", "tip", 2200);
      return;
    }

    // Crop the selection region so the model can only edit what's inside the box.
    const cropCanvas = document.createElement("canvas");
    cropCanvas.width = wBox;
    cropCanvas.height = hBox;
    const cropCtx = cropCanvas.getContext("2d");
    cropCtx.drawImage(imgItem.img, x0, y0, wBox, hBox, 0, 0, wBox, hBox);
    const cropPath = `${state.runDir}/tmp-annotate-crop-${Date.now()}-${Math.random().toString(16).slice(2)}.png`;
    await writeCanvasPngToPath(cropCanvas, cropPath);

    beginPendingReplace(imgItem.id, label, {
      mode: "annotate_box",
      basePath: imgItem.path,
      box: { x0, y0, x1, y1, w: wBox, h: hBox },
      cropPath,
      instruction,
    });

    // Point the engine at the cropped image so "edit the image" edits the crop.
    await invoke("write_pty", { data: `${PTY_COMMANDS.USE} ${quoteForPtyArg(cropPath)}\n` }).catch(() => {});

    state.expectingArtifacts = true;
    state.lastAction = label;
    setStatus(`Engine: ${label}â€¦`);
    showToast("Annotate: editingâ€¦", "info", 2200);

    if (state.ptySpawned && effectiveModel && effectiveModel !== settings.imageModel) {
      state.engineImageModelRestore = settings.imageModel;
      await invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${effectiveModel}\n` }).catch(() => {});
    }

    // Must start with "edit" or "replace" for Brood's edit detection.
    const prompt =
      `edit the image: ${instruction}\n` +
      "Output ONE image. No split-screen or collage. Do not add any text or logos. Do not crop.";
    await invoke("write_pty", { data: `${prompt}\n` });

    // Clear UI selection now that the instruction is sent.
    if (els.annotateText) els.annotateText.value = "";
    state.annotateBox = null;
    state.annotateDraft = null;
    hideAnnotatePanel();
    scheduleVisualPromptWrite();
    requestRender();
  } catch (err) {
    state.expectingArtifacts = false;
    state.engineImageModelRestore = null;
    clearPendingReplace();
    setImageFxActive(false);
    updatePortraitIdle();
    throw err;
  }
}

async function compositeAnnotateBoxEdit(targetId, editedCropPath, { box, instruction = null } = {}) {
  if (!targetId || !editedCropPath || !box) return false;
  const item = state.imagesById.get(targetId) || null;
  if (!item?.path) return false;

  // Ensure base + crop images are loaded.
  if (!item.img) {
    try {
      item.img = await loadImage(item.path);
      item.width = item.img?.naturalWidth || item.width || null;
      item.height = item.img?.naturalHeight || item.height || null;
    } catch (err) {
      console.error("Annotate composite failed to load base image:", err);
      return false;
    }
  }

  let cropImg = null;
  try {
    cropImg = await loadImage(editedCropPath);
  } catch (err) {
    console.error("Annotate composite failed to load crop image:", err);
    return false;
  }

  const baseImg = item.img;
  const bw = baseImg?.naturalWidth || item.width || 1;
  const bh = baseImg?.naturalHeight || item.height || 1;
  const out = document.createElement("canvas");
  out.width = bw;
  out.height = bh;
  const ctx = out.getContext("2d");
  ctx.drawImage(baseImg, 0, 0);
  ctx.drawImage(cropImg, Number(box.x0) || 0, Number(box.y0) || 0, Number(box.w) || 1, Number(box.h) || 1);

  await saveCanvasAsArtifact(out, {
    operation: "annotate_box",
    label: "Annotate",
    meta: {
      instruction: instruction ? String(instruction) : null,
      box,
      edited_crop_path: String(editedCropPath),
    },
    replaceActive: true,
    targetId,
  });
  return true;
}

async function applyBackground(style, { fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    const label = style === "sweep" ? "Background: Sweep" : "Background: White";
    enqueueAction({
      label,
      key: `bg:${String(style || "")}`,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => applyBackground(style, { fromQueue: true }),
    });
    return;
  }
  const imgItem = getActiveImage();
  if (!imgItem) {
    showToast("No image selected.", "error");
    return;
  }
  if (!imgItem.img) {
    setStatus("Engine: loading imageâ€¦");
    try {
      imgItem.img = await loadImage(imgItem.path);
    } catch (err) {
      showToast("Failed to load image.", "error");
      setStatus("Engine: ready");
      return;
    }
    setStatus("Engine: ready");
  }
  // If the user hasn't lassoed, fall back to model-powered background replacement.
  if (!state.selection || !state.selection.points || state.selection.points.length < 3) {
    await aiReplaceBackground(style);
    return;
  }
  const label = style === "sweep" ? "Soft Sweep" : "Studio White";
  state.lastAction = `${label} (local)`;
  await ensureRun();
  beginRunningAction("bg");
  setImageFxActive(true, label);
  portraitWorking(label);
  try {
    const img = imgItem.img;
    const w = img.naturalWidth;
    const h = img.naturalHeight;

    const fgCanvas = document.createElement("canvas");
    fgCanvas.width = w;
    fgCanvas.height = h;
    const fgCtx = fgCanvas.getContext("2d");
    fgCtx.drawImage(img, 0, 0);

    // Build polygon mask in image pixel space.
    const maskCanvas = document.createElement("canvas");
    maskCanvas.width = w;
    maskCanvas.height = h;
    const maskCtx = maskCanvas.getContext("2d");
    maskCtx.clearRect(0, 0, w, h);
    maskCtx.fillStyle = "#fff";
    maskCtx.beginPath();
    const pts = state.selection.points;
    maskCtx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i += 1) {
      maskCtx.lineTo(pts[i].x, pts[i].y);
    }
    maskCtx.closePath();
    maskCtx.fill();

    fgCtx.globalCompositeOperation = "destination-in";
    fgCtx.drawImage(maskCanvas, 0, 0);
    fgCtx.globalCompositeOperation = "source-over";

    const out = document.createElement("canvas");
    out.width = w;
    out.height = h;
    const outCtx = out.getContext("2d");
    if (style === "sweep") {
      const g = outCtx.createLinearGradient(0, 0, 0, h);
      g.addColorStop(0, "#ffffff");
      g.addColorStop(1, "#e9eef5");
      outCtx.fillStyle = g;
    } else {
      outCtx.fillStyle = "#ffffff";
    }
    outCtx.fillRect(0, 0, w, h);
    outCtx.drawImage(fgCanvas, 0, 0);

    await saveCanvasAsArtifact(out, {
      operation: "bg_replace",
      label: style === "sweep" ? "BG sweep" : "BG white",
      meta: { style, selection_points: pts.length },
      replaceActive: true,
      targetId: imgItem.id,
    });
    clearSelection();
    chooseSpawnNodes();
  } finally {
    setImageFxActive(false);
    updatePortraitIdle();
    clearRunningAction("bg");
  }
}

async function writeCanvasPngToPath(canvas, outPath) {
  const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
  if (!blob) throw new Error("Failed to encode PNG");
  const buf = new Uint8Array(await blob.arrayBuffer());
  await writeBinaryFile(outPath, buf);
  return outPath;
}

async function saveCanvasAsArtifact(
  canvas,
  { operation, label, meta = {}, replaceActive = false, targetId = null, parentImageId = null, select = true }
) {
  if (!state.runDir) return;
  const stamp = Date.now();
  const artifactId = `local-${operation}-${stamp}`;
  const imagePath = `${state.runDir}/artifact-${stamp}-${operation}.png`;
  setStatus("Engine: writing artifactâ€¦");
  const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
  if (!blob) throw new Error("Failed to encode PNG");
  const buf = new Uint8Array(await blob.arrayBuffer());
  await writeBinaryFile(imagePath, buf);
  const receiptPath = await writeLocalReceipt({
    artifactId,
    imagePath,
    operation,
    meta,
  });
  if (replaceActive) {
    const id = targetId || state.activeId;
    const parentNodeId = id ? state.imagesById.get(id)?.timelineNodeId || null : null;
    const ok = id ? await replaceImageInPlace(id, { path: imagePath, receiptPath, kind: "local" }) : false;
    if (ok && id) {
      const nodeId = recordTimelineNode({
        imageId: id,
        path: imagePath,
        receiptPath,
        label: label || basename(imagePath),
        action: label || operation,
        parents: parentNodeId ? [parentNodeId] : [],
      });
      const item = state.imagesById.get(id) || null;
      if (item && nodeId) item.timelineNodeId = nodeId;
    } else {
      addImage(
        {
          id: artifactId,
          kind: "local",
          path: imagePath,
          receiptPath,
          label: label || operation,
          timelineAction: label || operation,
        },
        { select: true }
      );
    }
  } else {
    const parentSourceId = parentImageId ? String(parentImageId) : state.activeId;
    const parentNodeId = parentSourceId ? state.imagesById.get(parentSourceId)?.timelineNodeId || null : null;
    addImage(
      {
        id: artifactId,
        kind: "local",
        path: imagePath,
        receiptPath,
        label: label || operation,
        timelineAction: label || operation,
        timelineParents: parentNodeId ? [parentNodeId] : [],
      },
      { select: Boolean(select) }
    );
  }
  setStatus("Engine: ready");
}

async function runVariations({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Variations",
      key: "variations",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runVariations({ fromQueue: true }),
    });
    return;
  }
  state.lastAction = "Variations";
  const imgItem = getActiveImage();
  if (!imgItem) return;
  await ensureRun();
  setImageFxActive(true, "Variations");
  portraitWorking("Variations");
  try {
    const ok = await ensureEngineSpawned({ reason: "variations" });
    if (!ok) throw new Error("Engine unavailable");
    state.expectingArtifacts = true;
    state.pendingRecreate = { startedAt: Date.now() };
    setStatus("Engine: variationsâ€¦");
    await invoke("write_pty", { data: `${PTY_COMMANDS.RECREATE} ${imgItem.path}\n` });
  } catch (err) {
    state.expectingArtifacts = false;
    state.pendingRecreate = null;
    setImageFxActive(false);
    updatePortraitIdle();
    throw err;
  }
}

function quoteForPtyArg(value) {
  return quoteForPtyArgUtil(value);
}

async function runBlendPair({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Combine",
      key: "combine",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runBlendPair({ fromQueue: true }),
    });
    return;
  }
  if (!state.runDir) {
    await ensureRun();
  }
  const pair = getSelectedImagesActiveFirst({ requireCount: 2 });
  if (pair.length !== 2) {
    showToast("Combine needs exactly 2 selected photos.", "error", 3200);
    return;
  }
  const [a, b] = pair;
  if (!a?.path || !b?.path) {
    showToast("Combine failed: missing image paths.", "error", 3200);
    return;
  }

  const okEngine = await ensureEngineSpawned({ reason: "combine" });
  if (!okEngine) return;
  await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.combine);
  setImageFxActive(true, "Combine");
  state.expectingArtifacts = true;
  state.pendingBlend = { sourceIds: [a.id, b.id], startedAt: Date.now() };
  state.lastAction = "Combine";
  setStatus("Engine: combineâ€¦");
  portraitWorking("Combine", { providerOverride: providerFromModel(ACTION_IMAGE_MODEL.combine) });
  showToast("Combining photosâ€¦", "info", 2200);
  renderQuickActions();
  requestRender();

  try {
    await invoke("write_pty", {
      data: `${PTY_COMMANDS.BLEND} ${quoteForPtyArg(a.path)} ${quoteForPtyArg(b.path)}\n`,
    });
  } catch (err) {
    console.error(err);
    state.expectingArtifacts = false;
    state.pendingBlend = null;
    setStatus(`Engine: combine failed (${err?.message || err})`, true);
    showToast("Combine failed to start.", "error", 3200);
    setImageFxActive(false);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runSwapDnaPair({ invert = false, fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Swap DNA",
      key: `swap_dna:${invert ? "1" : "0"}`,
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runSwapDnaPair({ invert, fromQueue: true }),
    });
    return;
  }
  if (!state.runDir) {
    await ensureRun();
  }
  const pair = getSelectedImagesActiveFirst({ requireCount: 2 });
  if (pair.length !== 2) {
    showToast("Swap DNA needs exactly 2 selected photos.", "error", 3200);
    return;
  }

  const [first, second] = pair;
  let structure = invert ? second : first;
  let surface = invert ? first : second;
  if (!structure?.path || !surface?.path) {
    showToast("Swap DNA failed: missing image paths.", "error", 3200);
    return;
  }

  const okEngine = await ensureEngineSpawned({ reason: "swap dna" });
  if (!okEngine) return;
  await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.swap_dna);
  setImageFxActive(true, "Swap DNA");
  state.expectingArtifacts = true;
  state.pendingSwapDna = { structureId: structure.id, surfaceId: surface.id, startedAt: Date.now() };
  state.lastAction = "Swap DNA";
  setStatus("Engine: swap dnaâ€¦");
  portraitWorking("Swap DNA", { providerOverride: providerFromModel(ACTION_IMAGE_MODEL.swap_dna) });
  const structureLabel = structure.label || basename(structure.path) || "Image A";
  const surfaceLabel = surface.label || basename(surface.path) || "Image B";
  const invertNote = invert ? " (inverted)" : "";
  showToast(`Swap DNA${invertNote}: structure=${structureLabel} | surface=${surfaceLabel}`, "info", 3200);
  renderQuickActions();
  requestRender();

  try {
    await invoke("write_pty", {
      data: `${PTY_COMMANDS.SWAP_DNA} ${quoteForPtyArg(structure.path)} ${quoteForPtyArg(surface.path)}\n`,
    });
  } catch (err) {
    console.error(err);
    state.expectingArtifacts = false;
    state.pendingSwapDna = null;
    setStatus(`Engine: swap dna failed (${err?.message || err})`, true);
    showToast("Swap DNA failed to start.", "error", 3200);
    setImageFxActive(false);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runBridgePair({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Bridge",
      key: "bridge",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runBridgePair({ fromQueue: true }),
    });
    return;
  }
  if (!state.runDir) {
    await ensureRun();
  }
  const pair = getSelectedImagesActiveFirst({ requireCount: 2 });
  if (pair.length !== 2) {
    showToast("Bridge needs exactly 2 selected photos.", "error", 3200);
    return;
  }

  const [first, second] = pair;
  if (!first?.path || !second?.path) {
    showToast("Bridge failed: missing image paths.", "error", 3200);
    return;
  }

  const okEngine = await ensureEngineSpawned({ reason: "bridge" });
  if (!okEngine) return;
  await maybeOverrideEngineImageModel(ACTION_IMAGE_MODEL.bridge);
  setImageFxActive(true, "Bridge");
  state.expectingArtifacts = true;
  state.pendingBridge = { sourceIds: [first.id, second.id], startedAt: Date.now() };
  state.lastAction = "Bridge";
  setStatus("Engine: bridgeâ€¦");
  portraitWorking("Bridge", { providerOverride: providerFromModel(ACTION_IMAGE_MODEL.bridge) });
  const aLabel = first.label || basename(first.path) || "Image A";
  const bLabel = second.label || basename(second.path) || "Image B";
  showToast(`Bridging: ${aLabel} â†” ${bLabel}`, "info", 3200);
  renderQuickActions();
  requestRender();

  try {
    await invoke("write_pty", {
      data: `${PTY_COMMANDS.BRIDGE} ${quoteForPtyArg(first.path)} ${quoteForPtyArg(second.path)}\n`,
    });
  } catch (err) {
    console.error(err);
    state.expectingArtifacts = false;
    state.pendingBridge = null;
    setStatus(`Engine: bridge failed (${err?.message || err})`, true);
    showToast("Bridge failed to start.", "error", 3200);
    setImageFxActive(false);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runExtractRuleTriplet({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || isMultiActionRunning() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Extract the Rule",
      key: "extract_rule",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runExtractRuleTriplet({ fromQueue: true }),
    });
    return;
  }
  if (!state.runDir) {
    await ensureRun();
  }
  const triplet = getSelectedImagesActiveFirst({ requireCount: 3 });
  if (triplet.length !== 3) {
    showToast("Extract the Rule needs exactly 3 selected photos.", "error", 3200);
    return;
  }
  const [a, b, c] = triplet;
  if (!a?.path || !b?.path || !c?.path) {
    showToast("Extract the Rule failed: missing image paths.", "error", 3200);
    return;
  }

  const okEngine = await ensureEngineSpawned({ reason: "extract rule" });
  if (!okEngine) return;

  state.pendingExtractRule = { sourceIds: [a.id, b.id, c.id], startedAt: Date.now() };
  state.lastAction = "Extract the Rule";
  setStatus("Director: extract ruleâ€¦");
  setDirectorText("Extracting the ruleâ€¦", { kind: "extract_rule", at: Date.now(), paths: [a.path, b.path, c.path] });
  portraitWorking("Extract the Rule", { providerOverride: "openai", clearDirector: false });
  showToast("Extracting the ruleâ€¦", "info", 2200);
  state.tripletRuleAnnotations.clear();
  state.tripletOddOneOutId = null;
  renderQuickActions();
  requestRender();

  try {
    await invoke("write_pty", {
      data: `${PTY_COMMANDS.EXTRACT_RULE} ${quoteForPtyArg(a.path)} ${quoteForPtyArg(b.path)} ${quoteForPtyArg(c.path)}\n`,
    });
    bumpSessionApiCalls();
  } catch (err) {
    console.error(err);
    state.pendingExtractRule = null;
    setStatus(`Director: extract rule failed (${err?.message || err})`, true);
    showToast("Extract the Rule failed to start.", "error", 3200);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runOddOneOutTriplet({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || isMultiActionRunning() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Odd One Out",
      key: "odd_one_out",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runOddOneOutTriplet({ fromQueue: true }),
    });
    return;
  }
  if (!state.runDir) {
    await ensureRun();
  }
  const triplet = getSelectedImagesActiveFirst({ requireCount: 3 });
  if (triplet.length !== 3) {
    showToast("Odd One Out needs exactly 3 selected photos.", "error", 3200);
    return;
  }
  const [a, b, c] = triplet;
  if (!a?.path || !b?.path || !c?.path) {
    showToast("Odd One Out failed: missing image paths.", "error", 3200);
    return;
  }

  const okEngine = await ensureEngineSpawned({ reason: "odd one out" });
  if (!okEngine) return;

  state.pendingOddOneOut = { sourceIds: [a.id, b.id, c.id], startedAt: Date.now() };
  state.lastAction = "Odd One Out";
  setStatus("Director: odd one outâ€¦");
  setDirectorText("Finding the odd one outâ€¦", { kind: "odd_one_out", at: Date.now(), paths: [a.path, b.path, c.path] });
  portraitWorking("Odd One Out", { providerOverride: "openai", clearDirector: false });
  showToast("Finding the odd one outâ€¦", "info", 2200);
  state.tripletRuleAnnotations.clear();
  state.tripletOddOneOutId = null;
  renderQuickActions();
  requestRender();

  try {
    await invoke("write_pty", {
      data: `${PTY_COMMANDS.ODD_ONE_OUT} ${quoteForPtyArg(a.path)} ${quoteForPtyArg(b.path)} ${quoteForPtyArg(c.path)}\n`,
    });
    bumpSessionApiCalls();
  } catch (err) {
    console.error(err);
    state.pendingOddOneOut = null;
    setStatus(`Director: odd one out failed (${err?.message || err})`, true);
    showToast("Odd One Out failed to start.", "error", 3200);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runTriforceTriplet({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || isMultiActionRunning() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Triforce",
      key: "triforce",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runTriforceTriplet({ fromQueue: true }),
    });
    return;
  }
  if (!state.runDir) {
    await ensureRun();
  }
  const triplet = getSelectedImagesActiveFirst({ requireCount: 3 });
  if (triplet.length !== 3) {
    showToast("Triforce needs exactly 3 selected photos.", "error", 3200);
    return;
  }
  const okProvider = await ensureGeminiProImagePreviewForAction("Triforce");
  if (!okProvider) {
    showToast("Triforce requires a Gemini image model (multi-image).", "error", 3600);
    return;
  }

  const [first, second, third] = triplet;
  if (!first?.path || !second?.path || !third?.path) {
    showToast("Triforce failed: missing image paths.", "error", 3200);
    return;
  }

  const okEngine = await ensureEngineSpawned({ reason: "triforce" });
  if (!okEngine) return;
  setImageFxActive(true, "Triforce");
  state.expectingArtifacts = true;
  state.pendingTriforce = { sourceIds: [first.id, second.id, third.id], startedAt: Date.now() };
  state.lastAction = "Triforce";
  setStatus("Engine: triforceâ€¦");
  portraitWorking("Triforce", { providerOverride: "gemini" });
  showToast("Generating centroidâ€¦", "info", 2200);
  state.tripletRuleAnnotations.clear();
  state.tripletOddOneOutId = null;
  renderQuickActions();
  requestRender();

  try {
    await invoke("write_pty", {
      data: `${PTY_COMMANDS.TRIFORCE} ${quoteForPtyArg(first.path)} ${quoteForPtyArg(second.path)} ${quoteForPtyArg(third.path)}\n`,
    });
  } catch (err) {
    console.error(err);
    state.expectingArtifacts = false;
    state.pendingTriforce = null;
    setStatus(`Engine: triforce failed (${err?.message || err})`, true);
    showToast("Triforce failed to start.", "error", 3200);
    setImageFxActive(false);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function runRecast({ fromQueue = false } = {}) {
  if (!requireIntentUnlocked()) return;
  bumpInteraction();
  if (!fromQueue && (isEngineBusy() || state.actionQueueActive || state.actionQueue.length)) {
    enqueueAction({
      label: "Recast",
      key: "recast",
      priority: ACTION_QUEUE_PRIORITY.user,
      run: () => runRecast({ fromQueue: true }),
    });
    return;
  }
  const imgItem = getActiveImage();
  if (!imgItem?.path) {
    showToast("No image selected.", "error", 2400);
    return;
  }

  const label = "Recast";
  await ensureRun();
  const okEngine = await ensureEngineSpawned({ reason: label });
  if (!okEngine) return;
  setImageFxActive(true, label);
  portraitWorking(label, { providerOverride: "gemini" });
  state.expectingArtifacts = true;
  state.pendingRecast = { sourceId: imgItem.id, startedAt: Date.now() };
  state.lastAction = label;
  setStatus(`Engine: ${label.toLowerCase()}â€¦`);
  showToast("Recastingâ€¦", "info", 2200);
  renderQuickActions();
  requestRender();

  try {
    const desired = "gemini-3-pro-image-preview";
    if (state.ptySpawned && desired && desired !== settings.imageModel) {
      state.engineImageModelRestore = settings.imageModel;
      await invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${desired}\n` }).catch(() => {});
    }
    await invoke("write_pty", { data: `${PTY_COMMANDS.RECAST} ${quoteForPtyArg(imgItem.path)}\n` });
  } catch (err) {
    console.error(err);
    state.expectingArtifacts = false;
    state.pendingRecast = null;
    state.engineImageModelRestore = null;
    setStatus(`Engine: recast failed (${err?.message || err})`, true);
    showToast("Recast failed to start.", "error", 3200);
    setImageFxActive(false);
    updatePortraitIdle();
    renderQuickActions();
  }
}

async function exportRun() {
  bumpInteraction();
  if (!state.runDir) {
    showToast("Create or open a run before exporting.", "tip", 2600);
    return;
  }
  const outPath = `${state.runDir}/export.html`;
  setStatus("Engine: exporting runâ€¦");
  try {
    await invoke("export_run", { runDir: state.runDir, outPath });
    setStatus(`Engine: exported ${basename(outPath)}`);
    showToast(`Exported ${basename(outPath)}.`, "tip", 2600);
  } catch (err) {
    const msg = err?.message || String(err || "export failed");
    setStatus(`Engine: export failed (${msg})`, true);
    showToast(`Export failed: ${msg}`, "error", 4200);
  }
}

async function ensureRun() {
  if (state.runDir) return;
  await createRun();
}

async function createRun() {
  const previous = captureRunResetSnapshot();
  announceRunTransition("new", previous);
  const payload = await invoke("create_run_dir");
  state.runDir = payload.run_dir;
  state.eventsPath = payload.events_path;
  state.eventsByteOffset = 0;
  state.eventsTail = "";
  state.eventsDecoder = new TextDecoder("utf-8");
  state.fallbackToFullRead = false;
  fallbackLineOffset = 0;
  state.sessionApiCalls = 0;
  resetTopMetrics();
  resetDescribeQueue();
  // Run-local interaction history for canvas context envelopes.
  state.userEvents = [];
  state.userTelemetryEvents = [];
  state.userEventSeq = 0;
  state.images = [];
  state.imagesById.clear();
  state.imagePaletteSeed = 0;
  state.activeId = null;
  state.selectedIds = [];
  state.timelineNodes = [];
  state.timelineNodesById.clear();
  closeTimeline();
  state.canvasMode = "multi";
  state.freeformRects.clear();
  state.freeformZOrder = [];
  state.multiRects.clear();
  state.pendingBlend = null;
  state.pendingSwapDna = null;
  state.pendingBridge = null;
  state.pendingExtractDna = null;
  state.pendingSoulLeech = null;
  state.pendingExtractRule = null;
  state.pendingOddOneOut = null;
  state.pendingTriforce = null;
  state.pendingRecast = null;
  state.pendingCreateLayers = null;
  state.pendingPromptGenerate = null;
  state.pendingRecreate = null;
  resetActionQueue();
  state.tripletRuleAnnotations.clear();
  state.tripletOddOneOutId = null;
  clearImageCache();
  clearAllEffectTokens();
  state.selection = null;
  state.lassoDraft = [];
  state.annotateDraft = null;
  state.annotateBox = null;
  hideAnnotatePanel();
  hidePromptGeneratePanel({ clearDraft: true });
  state.circleDraft = null;
  state.circlesByImageId.clear();
  hideMarkPanel();
  state.expectingArtifacts = false;
  state.lastRecreatePrompt = null;
  state.lastDirectorText = null;
  state.lastDirectorMeta = null;
  resetMotherIdleAndWheelState();
  state.intent.locked = true;
  state.intent.lockedAt = 0;
  state.intent.lockedBranchId = null;
  state.intent.startedAt = 0;
  state.intent.deadlineAt = 0;
  state.intent.round = 1;
  state.intent.selections = [];
  state.intent.focusBranchId = null;
  state.intent.iconState = null;
  state.intent.iconStateAt = 0;
  state.intent.pending = false;
  state.intent.pendingPath = null;
  state.intent.rtState = "off";
  state.intent.disabledReason = null;
  state.intent.lastError = null;
  state.intent.lastErrorAt = 0;
  state.intent.lastSignature = null;
  state.intent.lastRunAt = 0;
  state.intent.forceChoice = false;
  state.intent.uiHits = [];
  resetAmbientIntentState();
  if (state.alwaysOnVision) {
    state.alwaysOnVision.pending = false;
    state.alwaysOnVision.pendingPath = null;
    state.alwaysOnVision.pendingAt = 0;
    state.alwaysOnVision.contentDirty = false;
    state.alwaysOnVision.dirtyReason = null;
    state.alwaysOnVision.lastSignature = null;
    state.alwaysOnVision.lastRunAt = 0;
    state.alwaysOnVision.lastText = null;
    state.alwaysOnVision.lastMeta = null;
    state.alwaysOnVision.disabledReason = null;
    state.alwaysOnVision.rtState = state.alwaysOnVision.enabled ? "connecting" : "off";
  }
  setRunInfo(`Run: ${state.runDir}`);
  setTip(DEFAULT_TIP);
  setDirectorText(null, null);
  stopIntentTicker();
  clearTimeout(intentInferenceTimer);
  intentInferenceTimer = null;
  clearTimeout(intentInferenceTimeout);
  intentInferenceTimeout = null;
  clearTimeout(intentStateWriteTimer);
  intentStateWriteTimer = null;
  clearAmbientIntentTimers();
  syncIntentModeClass();
  updateEmptyCanvasHint();
  renderFilmstrip();
  chooseSpawnNodes();
  scheduleVisualPromptWrite({ immediate: true });
  await spawnEngine();
  await startEventsPolling();
  if (state.ptySpawned) setStatus("Engine: ready");
  finalizeRunTransition("new", { engineReady: state.ptySpawned });
}

async function openExistingRun() {
  bumpInteraction();
  const selected = await open({ directory: true, multiple: false });
  if (!selected) return;
  const previous = captureRunResetSnapshot();
  announceRunTransition("open", previous);
  state.runDir = selected;
  state.eventsPath = `${selected}/events.jsonl`;
  state.eventsByteOffset = 0;
  state.eventsTail = "";
  state.eventsDecoder = new TextDecoder("utf-8");
  state.fallbackToFullRead = false;
  fallbackLineOffset = 0;
  state.sessionApiCalls = 0;
  resetTopMetrics();
  resetDescribeQueue();
  // Run-local interaction history for canvas context envelopes.
  state.userEvents = [];
  state.userTelemetryEvents = [];
  state.userEventSeq = 0;
  state.images = [];
  state.imagesById.clear();
  state.imagePaletteSeed = 0;
  state.activeId = null;
  state.selectedIds = [];
  state.timelineNodes = [];
  state.timelineNodesById.clear();
  closeTimeline();
  state.canvasMode = "multi";
  state.freeformRects.clear();
  state.freeformZOrder = [];
  state.multiRects.clear();
  state.pendingBlend = null;
  state.pendingSwapDna = null;
  state.pendingBridge = null;
  state.pendingExtractDna = null;
  state.pendingSoulLeech = null;
  state.pendingExtractRule = null;
  state.pendingOddOneOut = null;
  state.pendingTriforce = null;
  state.pendingRecast = null;
  state.pendingCreateLayers = null;
  state.pendingPromptGenerate = null;
  state.pendingRecreate = null;
  resetActionQueue();
  state.tripletRuleAnnotations.clear();
  state.tripletOddOneOutId = null;
  renderFilmstrip();
  clearImageCache();
  clearAllEffectTokens();
  state.selection = null;
  state.lassoDraft = [];
  state.annotateDraft = null;
  state.annotateBox = null;
  hideAnnotatePanel();
  hidePromptGeneratePanel({ clearDraft: true });
  state.circleDraft = null;
  state.circlesByImageId.clear();
  hideMarkPanel();
  state.expectingArtifacts = false;
  state.lastRecreatePrompt = null;
  state.lastDirectorText = null;
  state.lastDirectorMeta = null;
  resetMotherIdleAndWheelState();
  state.intent.locked = true;
  state.intent.lockedAt = 0;
  state.intent.lockedBranchId = null;
  state.intent.startedAt = 0;
  state.intent.deadlineAt = 0;
  state.intent.round = 1;
  state.intent.selections = [];
  state.intent.focusBranchId = null;
  state.intent.iconState = null;
  state.intent.iconStateAt = 0;
  state.intent.pending = false;
  state.intent.pendingPath = null;
  state.intent.rtState = "off";
  state.intent.disabledReason = null;
  state.intent.lastError = null;
  state.intent.lastErrorAt = 0;
  state.intent.lastSignature = null;
  state.intent.lastRunAt = 0;
  state.intent.forceChoice = false;
  state.intent.uiHits = [];
  resetAmbientIntentState();
  if (state.alwaysOnVision) {
    state.alwaysOnVision.pending = false;
    state.alwaysOnVision.pendingPath = null;
    state.alwaysOnVision.pendingAt = 0;
    state.alwaysOnVision.contentDirty = false;
    state.alwaysOnVision.dirtyReason = null;
    state.alwaysOnVision.lastSignature = null;
    state.alwaysOnVision.lastRunAt = 0;
    state.alwaysOnVision.lastText = null;
    state.alwaysOnVision.lastMeta = null;
    state.alwaysOnVision.disabledReason = null;
    state.alwaysOnVision.rtState = state.alwaysOnVision.enabled ? "connecting" : "off";
  }
  setRunInfo(`Run: ${state.runDir}`);
  setTip(DEFAULT_TIP);
  setDirectorText(null, null);
  stopIntentTicker();
  clearTimeout(intentInferenceTimer);
  intentInferenceTimer = null;
  clearTimeout(intentInferenceTimeout);
  intentInferenceTimeout = null;
  clearTimeout(intentStateWriteTimer);
  intentStateWriteTimer = null;
  clearAmbientIntentTimers();
  syncIntentModeClass();
  updateEmptyCanvasHint();
  await restoreIntentStateFromRunDir().catch(() => {});
  const restoredArtifacts = await loadExistingArtifacts();
  await spawnEngine();
  await startEventsPolling();
  scheduleVisualPromptWrite({ immediate: true });
  if (intentAmbientActive() && getVisibleCanvasImages().length) {
    scheduleAmbientIntentInference({ immediate: true, reason: "composition_change" });
  }
  if (state.ptySpawned) setStatus("Engine: ready");
  finalizeRunTransition("open", { restoredArtifacts, engineReady: state.ptySpawned });
}

async function loadExistingArtifacts() {
  if (!state.runDir) return;
  const entries = await readDir(state.runDir, { recursive: false }).catch(() => []);
  let restored = 0;
  for (const entry of entries) {
    if (!entry?.name) continue;
    if (!entry.name.startsWith("receipt-") || !entry.name.endsWith(".json")) continue;
    const receiptPath = entry.path;
    let payload = null;
    try {
      payload = JSON.parse(await readTextFile(receiptPath));
    } catch {
      continue;
    }
    const imagePath = payload?.artifacts?.image_path;
    if (typeof imagePath !== "string" || !imagePath) continue;
    const artifactId = entry.name.slice("receipt-".length).replace(/\.json$/, "");
    addImage(
      {
        id: artifactId,
        kind: "receipt",
        path: imagePath,
        receiptPath,
        receiptMeta: extractReceiptMeta(payload),
        receiptMetaChecked: true,
        label: basename(imagePath),
      },
      { select: false }
    );
    restored += 1;
  }
  // Select latest.
  if (state.images.length > 0 && !state.activeId) {
    await setActiveImage(state.images[state.images.length - 1].id);
  }
  if (state.images.length > 1) {
    setCanvasMode("multi");
    setTip("Multiple photos loaded. Click a photo to focus it.");
  }
  return restored;
}

async function spawnEngine() {
  if (!state.runDir || !state.eventsPath) return;
  if (state.ptySpawning) return;
  state.ptySpawning = true;
  setStatus("Engine: startingâ€¦");
  state.ptySpawned = false;
  const preferredMode = "native";
  const baseEnv = { BROOD_MEMORY: settings.memory ? "1" : "0" };
  const broodArgs = ["chat", "--out", state.runDir, "--events", state.eventsPath];
  try {
    let spawned = false;
    let lastErr = null;
    let launchMeta = null;

    const spawnAttempt = async ({ command, args, cwd, label }) => {
      if (spawned) return;
      try {
        await invoke("spawn_pty", { command, args, cwd, env: baseEnv });
        spawned = true;
        launchMeta = { mode: "native", label };
      } catch (err) {
        lastErr = err;
        console.warn(`[brood] spawn attempt failed (${label})`, err);
      }
    };

    // In dev, prefer running from repo roots so desktop always matches local changes.
    let repoRoot = null;
    try {
      repoRoot = await invoke("get_repo_root");
    } catch (_) {
      repoRoot = null;
    }

    if (repoRoot) {
      await spawnAttempt({
        command: "cargo",
        args: ["run", "-q", "-p", "brood-cli", "--", ...broodArgs],
        cwd: `${repoRoot}/rust_engine`,
        label: "cargo run -p brood-cli",
      });
    }

    await spawnAttempt({
      command: "brood-rs",
      args: broodArgs,
      cwd: state.runDir,
      label: "brood-rs",
    });

    if (!spawned) {
      const detail = lastErr?.message || String(lastErr || "native engine launch failed");
      throw new Error(
        `${detail}. Native engine launch failed; Python compatibility runtime is no longer available in desktop runtime.`
      );
    }

    state.ptySpawned = true;
    state.engineLaunchMode = launchMeta?.mode || "native";
    state.engineLaunchPath = launchMeta?.label || "unknown";
    console.info(
      `[brood] engine launch mode=${state.engineLaunchMode} path=${state.engineLaunchPath} preferred=${preferredMode}`
    );
    await invoke("write_pty", { data: `${PTY_COMMANDS.TEXT_MODEL} ${settings.textModel}\n` }).catch(() => {});
    await invoke("write_pty", { data: `${PTY_COMMANDS.IMAGE_MODEL} ${settings.imageModel}\n` }).catch(() => {});
    const active = getActiveImage();
    if (active?.path) {
      await invoke("write_pty", { data: `${PTY_COMMANDS.USE} ${active.path}\n` }).catch(() => {});
      if (!active.visionDesc) scheduleVisionDescribe(active.path, { priority: true, fallback: true });
    }
    processDescribeQueue();
    setStatus(`Engine: started (${state.engineLaunchMode})`);
  } catch (err) {
    console.error(err);
    setStatus(`Engine: failed (${err?.message || err})`, true);
  } finally {
    state.ptySpawning = false;
    await flushDeferredEnginePtyExit();
    processActionQueue().catch(() => {});
  }
}

function startEventsPolling() {
  if (state.poller) return;
  // Poll fast, but incrementally (offset-based) for responsiveness.
  state.poller = setInterval(() => {
    pollEventsOnce().catch(() => {});
  }, 250);
}

async function pollEventsOnce() {
  if (!state.eventsPath) return;
  if (!(await exists(state.eventsPath))) return;
  if (state.pollInFlight) return;
  state.pollInFlight = true;
  try {
    if (state.fallbackToFullRead) {
      await pollEventsFallback();
      return;
    }
    const resp = await invoke("read_file_since", {
      path: state.eventsPath,
      offset: state.eventsByteOffset,
      maxBytes: 1024 * 256,
    });
    const chunk = resp?.chunk;
    const clampedOffset = Number(resp?.clamped_offset);
    const newOffset = Number(resp?.new_offset);
    if (Number.isFinite(clampedOffset) && clampedOffset < state.eventsByteOffset) {
      state.eventsTail = "";
      state.eventsDecoder = new TextDecoder("utf-8");
    }
    if (Number.isFinite(newOffset)) state.eventsByteOffset = newOffset;

    let chunkText = "";
    if (typeof chunk === "string") {
      chunkText = chunk;
    } else if (chunk instanceof Uint8Array) {
      chunkText = state.eventsDecoder.decode(chunk, { stream: true });
    } else if (Array.isArray(chunk)) {
      chunkText = state.eventsDecoder.decode(Uint8Array.from(chunk), { stream: true });
    }
    if (!chunkText) return;
    state.eventsTail += chunkText;
    const lines = state.eventsTail.split("\n");
    state.eventsTail = lines.pop() || "";
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      try {
        await handleEvent(JSON.parse(trimmed));
      } catch {
        // ignore malformed
      }
    }
  } catch (err) {
    // Command missing or invoke failed; use old approach.
    console.warn("Incremental event reader failed, falling back:", err);
    state.eventsTail = "";
    state.eventsDecoder = new TextDecoder("utf-8");
    state.fallbackToFullRead = true;
  } finally {
    state.pollInFlight = false;
  }
}

let fallbackLineOffset = 0;
async function pollEventsFallback() {
  const content = await readTextFile(state.eventsPath);
  const lines = content.trim().split("\n").filter(Boolean);
  for (let i = fallbackLineOffset; i < lines.length; i += 1) {
    try {
      await handleEvent(JSON.parse(lines[i]));
    } catch {
      // ignore
    }
  }
  fallbackLineOffset = lines.length;
}

function handleMotherDesktopEvent(event) {
  return handleEventLegacy(event);
}

function handleArtifactDesktopEvent(event) {
  return handleEventLegacy(event);
}

function handleIntentDesktopEvent(event) {
  return handleEventLegacy(event);
}

function handleDiagnosticsDesktopEvent(event) {
  return handleEventLegacy(event);
}

function handleRecreateDesktopEvent(event) {
  return handleEventLegacy(event);
}

let desktopEventHandlerMap = null;
function getDesktopEventHandlerMap() {
  if (desktopEventHandlerMap) return desktopEventHandlerMap;
  desktopEventHandlerMap = createDesktopEventHandlerMap(DESKTOP_EVENT_TYPES, {
    onMother: handleMotherDesktopEvent,
    onArtifact: handleArtifactDesktopEvent,
    onIntent: handleIntentDesktopEvent,
    onDiagnostics: handleDiagnosticsDesktopEvent,
    onRecreate: handleRecreateDesktopEvent,
  });
  return desktopEventHandlerMap;
}

async function handleEvent(event) {
  if (!event || typeof event !== "object") return;
  const type = String(event.type || "");
  const handler = getDesktopEventHandlerMap().get(type);
  if (!handler) return;
  await handler(event);
}

async function handleEventLegacy(event) {
  if (!event || typeof event !== "object") return;
  const eventType = String(event.type || "");
  if (eventType && eventType !== DESKTOP_EVENT_TYPES.ARTIFACT_CREATED) {
    topMetricIngestTokensFromPayload(event, { atMs: Date.now(), render: false });
  }
  if (eventType === DESKTOP_EVENT_TYPES.PLAN_PREVIEW) {
    const cached = Boolean(event?.plan && event.plan.cached);
    if (!cached) bumpSessionApiCalls();
    return;
  }
  if (eventType === DESKTOP_EVENT_TYPES.VERSION_CREATED) {
    promptBenchmarkBindVersion(motherEventVersionId(event));
    motherIdleTrackVersionCreated(event);
    return;
  }
  if (eventType === DESKTOP_EVENT_TYPES.MOTHER_INTENT_INFERRED) {
    appendMotherTraceLog({
      kind: "intent_inferred_ignored",
      traceId: state.motherIdle?.telemetry?.traceId || null,
      actionVersion: Number(state.motherIdle?.actionVersion) || 0,
      reason: "heuristic_intent_disabled",
      source: event.source ? String(event.source) : null,
    }).catch(() => {});
    return;
  }
  if (eventType === DESKTOP_EVENT_TYPES.MOTHER_INTENT_INFER_FAILED) {
    appendMotherTraceLog({
      kind: "intent_infer_failed_ignored",
      traceId: state.motherIdle?.telemetry?.traceId || null,
      actionVersion: Number(state.motherIdle?.actionVersion) || 0,
      reason: "heuristic_intent_disabled",
      source: event.source ? String(event.source) : null,
    }).catch(() => {});
    return;
  }
  if (eventType === DESKTOP_EVENT_TYPES.MOTHER_PROMPT_COMPILED) {
    const idle = state.motherIdle;
    if (!idle) return;
    const actionVersion = Number(event.action_version) || 0;
    if (actionVersion !== (Number(idle.actionVersion) || 0)) {
      motherV2MarkStale({
        stage: "prompt_compiled",
        event_action_version: actionVersion,
      });
      return;
    }
    // Ignore late compile results after local fallback dispatch (prevents duplicate generation requests).
    if (!idle.pendingPromptCompile || idle.pendingGeneration || Boolean(idle.pendingDispatchToken)) {
      appendMotherTraceLog({
        kind: "prompt_compiled_ignored",
        traceId: idle.telemetry?.traceId || null,
        actionVersion,
        pending_prompt_compile: Boolean(idle.pendingPromptCompile),
        pending_generation: Boolean(idle.pendingGeneration),
        pending_dispatch_token: Number(idle.pendingDispatchToken) || 0,
      }).catch(() => {});
      return;
    }
    await motherV2DispatchCompiledPrompt(event.compiled || {}).catch((err) => {
      motherIdleHandleGenerationFailed(err?.message || "Mother prompt compile dispatch failed.");
    });
    return;
  }
  if (eventType === DESKTOP_EVENT_TYPES.MOTHER_PROMPT_COMPILE_FAILED) {
    const idle = state.motherIdle;
    if (!idle) return;
    if (!idle.pendingPromptCompile) return;
    idle.pendingPromptCompile = false;
    const compileWasSpeculative = Boolean(idle.pendingPromptCompileSpeculative);
    idle.pendingPromptCompileSpeculative = false;
    idle.pendingPromptCompilePath = null;
    clearTimeout(idle.pendingPromptCompileTimeout);
    idle.pendingPromptCompileTimeout = null;
    if ((Number(idle.pendingActionVersion) || 0) !== (Number(idle.actionVersion) || 0)) {
      motherV2MarkStale({ stage: "prompt_compile_failed" });
      return;
    }
    const compiled = motherV2CompilePromptLocal({
      action_version: Number(idle.actionVersion) || 0,
      intent: idle.intent || null,
      roles: motherV2RoleMapClone(),
      transformation_mode: motherV2NormalizeTransformationMode(idle.intent?.transformation_mode),
      intensity: clamp(Number(idle.intensity) || 62, 0, 100),
      active_id: getVisibleActiveId() || null,
      images: motherIdleBaseImageItems().map((item) => ({
        id: String(item.id || ""),
        file: basename(item.path || ""),
        vision_desc: normalizeVisionHintForIntent(item?.visionDesc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS }) || "",
      })),
    });
    idle.pendingPromptCompileSpeculative = compileWasSpeculative;
    await motherV2DispatchCompiledPrompt(compiled).catch((err) => {
      motherIdleHandleGenerationFailed(err?.message || "Mother prompt compile fallback failed.");
    });
    return;
  }
  if (eventType === DESKTOP_EVENT_TYPES.ARTIFACT_CREATED) {
    const id = event.artifact_id;
    const path = event.image_path;
    if (!id || !path) return;
    const eventMetrics = event.metrics && typeof event.metrics === "object" ? event.metrics : null;
    if (eventMetrics) {
      topMetricIngestRenderDuration(eventMetrics.latency_per_image_s);
    }
    if (event.receipt_path) {
      ingestTopMetricsFromReceiptPath(event.receipt_path, {
        allowCostFallback: false,
        allowLatencyFallback: !eventMetrics,
      }).catch(() => {});
    }
    renderSessionApiCallsReadout();
    if (state.pendingCreateLayers) {
      const handledCreateLayers = await handleCreateLayersArtifact(event).catch((err) => {
        console.error(err);
        finishCreateLayersFailure(`Create Layers failed (${err?.message || err}).`);
        return true;
      });
      if (handledCreateLayers) return;
    }
    const idleForCancel = state.motherIdle;
    const noForegroundPendingForCancel =
      !state.pendingReplace &&
      !state.pendingBlend &&
      !state.pendingSwapDna &&
      !state.pendingBridge &&
      !state.pendingCreateLayers &&
      !state.pendingExtractDna &&
      !state.pendingSoulLeech &&
      !state.pendingExtractRule &&
      !state.pendingOddOneOut &&
      !state.pendingTriforce &&
      !state.pendingRecast &&
      !state.pendingPromptGenerate &&
      !state.pendingRecreate;
    if (
      idleForCancel &&
      Date.now() < (Number(idleForCancel.cancelArtifactUntil) || 0) &&
      noForegroundPendingForCancel &&
      String(state.lastAction || "") === "Mother Suggestion"
    ) {
      appendMotherTraceLog({
        kind: "discard_artifact_after_cancel",
        traceId: idleForCancel.telemetry?.traceId || null,
        actionVersion: Number(idleForCancel.actionVersion) || 0,
        image_id: String(id),
        image_path: String(path),
        reason: idleForCancel.cancelArtifactReason || "cancel",
      }).catch(() => {});
      removeFile(path).catch(() => {});
      if (event.receipt_path) removeFile(event.receipt_path).catch(() => {});
      return;
    }
    const eventVersionId = motherEventVersionId(event);
    if (eventVersionId) {
      promptBenchmarkMarkSuccessFromArtifactEvent(event);
    }
    const motherDispatchInFlight =
      motherV2DispatchInFlight(state.motherIdle) &&
      !state.pendingReplace &&
      !state.pendingBlend &&
      !state.pendingSwapDna &&
      !state.pendingBridge &&
      !state.pendingCreateLayers &&
      !state.pendingExtractDna &&
      !state.pendingSoulLeech &&
      !state.pendingExtractRule &&
      !state.pendingOddOneOut &&
      !state.pendingTriforce &&
      !state.pendingRecast &&
      !state.pendingPromptGenerate &&
      !state.pendingRecreate;
    if (motherDispatchInFlight && !motherIdleDispatchVersionMatches(eventVersionId)) {
      if (eventVersionId) motherIdleRememberIgnoredVersion(eventVersionId);
      appendMotherSuggestionLog({
        stage: "out_of_band_result_ignored",
        request_id: state.motherIdle?.pendingSuggestionLog?.request_id || null,
        expected_version_id: state.motherIdle?.pendingVersionId || null,
        ignored_version_id: eventVersionId,
        ignored_image_id: String(id),
        ignored_image_path: String(path),
        ignored_receipt_path: event.receipt_path ? String(event.receipt_path) : null,
      }).catch(() => {});
      console.warn("[mother_suggestion] ignored out-of-band artifact during active dispatch", {
        expected_version_id: state.motherIdle?.pendingVersionId || null,
        ignored_version_id: eventVersionId,
        ignored_image_id: String(id),
      });
      removeFile(path).catch(() => {});
      if (event.receipt_path) removeFile(event.receipt_path).catch(() => {});
      return;
    }
    if (motherDispatchInFlight) {
      const handled = await motherIdleHandleSuggestionArtifact({
        id,
        path,
        receiptPath: event.receipt_path || null,
        versionId: eventVersionId,
      }).catch((err) => {
        console.error(err);
        return false;
      });
      if (handled) {
        state.expectingArtifacts = false;
        restoreEngineImageModelIfNeeded();
        setStatus("Engine: ready");
        updatePortraitIdle();
        setImageFxActive(false);
        renderMotherReadout();
        renderQuickActions();
        renderHudReadout();
        processActionQueue().catch(() => {});
        return;
      }
    }
    if (eventVersionId && motherIdleIsIgnoredVersion(eventVersionId)) {
      appendMotherSuggestionLog({
        stage: "late_result_ignored",
        ignored_version_id: eventVersionId,
        ignored_image_id: String(id),
        ignored_image_path: String(path),
        ignored_receipt_path: event.receipt_path ? String(event.receipt_path) : null,
      }).catch(() => {});
      console.warn("[mother_suggestion] ignored late artifact from blocked version", {
        ignored_version_id: eventVersionId,
        ignored_image_id: String(id),
      });
      removeFile(path).catch(() => {});
      if (event.receipt_path) removeFile(event.receipt_path).catch(() => {});
      return;
    }
    const motherIdle = state.motherIdle || null;
    const noForegroundPending =
      !state.pendingReplace &&
      !state.pendingBlend &&
      !state.pendingSwapDna &&
      !state.pendingBridge &&
      !state.pendingCreateLayers &&
      !state.pendingExtractDna &&
      !state.pendingSoulLeech &&
      !state.pendingExtractRule &&
      !state.pendingOddOneOut &&
      !state.pendingTriforce &&
      !state.pendingRecast &&
      !state.pendingPromptGenerate &&
      !state.pendingRecreate;
    const motherSingleSuggestionGuard =
      !motherDispatchInFlight &&
      motherIdle?.phase === MOTHER_IDLE_STATES.WAITING_FOR_USER &&
      Boolean(motherIdle?.generatedImageId) &&
      Boolean(motherIdle?.hasGeneratedSinceInteraction) &&
      noForegroundPending &&
      String(state.lastAction || "") === "Mother Suggestion" &&
      Date.now() <= (Number(motherIdle?.lastSuggestionAt) || 0) + MOTHER_V2_SINGLE_RESULT_GUARD_WINDOW_MS;
    if (motherSingleSuggestionGuard && String(id) !== String(motherIdle.generatedImageId)) {
      appendMotherSuggestionLog({
        stage: "extra_result_ignored",
        retained_image_id: String(motherIdle.generatedImageId || ""),
        ignored_image_id: String(id),
        ignored_image_path: String(path),
        ignored_receipt_path: event.receipt_path ? String(event.receipt_path) : null,
      }).catch(() => {});
      console.info("[mother_suggestion] ignored extra artifact", {
        retained_image_id: String(motherIdle.generatedImageId || ""),
        ignored_image_id: String(id),
      });
      removeFile(path).catch(() => {});
      if (event.receipt_path) removeFile(event.receipt_path).catch(() => {});
      state.expectingArtifacts = false;
      restoreEngineImageModelIfNeeded();
      setStatus("Engine: ready");
      updatePortraitIdle();
      setImageFxActive(false);
      renderQuickActions();
      renderHudReadout();
      processActionQueue().catch(() => {});
      return;
    }
    const blend = state.pendingBlend;
    const swapDna = state.pendingSwapDna;
    const bridge = state.pendingBridge;
    const triforce = state.pendingTriforce;
    const recast = state.pendingRecast;
    const promptGenerate = state.pendingPromptGenerate;
    const recreate = state.pendingRecreate;
    const pending = state.pendingReplace;

    const wasBlend = Boolean(blend);
    const wasSwapDna = Boolean(swapDna);
    const wasBridge = Boolean(bridge);
    const wasTriforce = Boolean(triforce);
    const wasRecast = Boolean(recast);
    const wasPromptGenerate = Boolean(promptGenerate);
    const wasRecreate = Boolean(recreate);
    const wasMultiGenAction = wasBlend || wasSwapDna || wasBridge || wasTriforce;

    // Timeline metadata for this newly created artifact.
    let timelineAction = state.lastAction || null;
    let timelineParents = [];
    if (blend?.sourceIds?.length) {
      timelineAction = "Combine";
      timelineParents = blend.sourceIds.map((src) => state.imagesById.get(src)?.timelineNodeId).filter(Boolean);
    } else if (swapDna?.structureId && swapDna?.surfaceId) {
      timelineAction = "Swap DNA";
      timelineParents = [swapDna.structureId, swapDna.surfaceId]
        .map((src) => state.imagesById.get(src)?.timelineNodeId)
        .filter(Boolean);
    } else if (bridge?.sourceIds?.length) {
      timelineAction = "Bridge";
      timelineParents = bridge.sourceIds.map((src) => state.imagesById.get(src)?.timelineNodeId).filter(Boolean);
    } else if (triforce?.sourceIds?.length) {
      timelineAction = "Triforce";
      timelineParents = triforce.sourceIds.map((src) => state.imagesById.get(src)?.timelineNodeId).filter(Boolean);
    } else if (recast?.sourceId) {
      timelineAction = "Recast";
      const parent = state.imagesById.get(recast.sourceId)?.timelineNodeId || null;
      timelineParents = parent ? [parent] : [];
    } else if (wasPromptGenerate) {
      timelineAction = "Prompt Generate";
      timelineParents = [];
    } else {
      const activeParent = getActiveImage()?.timelineNodeId || null;
      timelineParents = activeParent ? [activeParent] : [];
    }
    if (wasBlend) {
      state.pendingBlend = null;
      setTip("Combine complete. Output selected.");
      showToast("Combine complete.", "tip", 2400);
    }
    if (wasSwapDna) {
      state.pendingSwapDna = null;
      setTip("Swap DNA complete. Output selected.");
      showToast("Swap DNA complete.", "tip", 2400);
    }
    if (wasBridge) {
      state.pendingBridge = null;
      setTip("Bridge complete. Output selected.");
      showToast("Bridge complete.", "tip", 2400);
    }
    if (wasTriforce) {
      state.pendingTriforce = null;
      setTip("Triforce complete. Output selected.");
      showToast("Triforce complete.", "tip", 2400);
    }
    if (wasRecast) {
      state.pendingRecast = null;
      setTip("Recast complete. Output selected.");
      showToast("Recast complete.", "tip", 2400);
    }
    if (wasPromptGenerate) {
      state.pendingPromptGenerate = null;
      setTip("Prompt Generate complete. Output selected.");
      showToast("Prompt Generate complete.", "tip", 2400);
    }
    if (pending?.targetId) {
      const targetId = pending.targetId;
      const mode = pending.mode ? String(pending.mode) : "";
      const box = pending.box || null;
      const instruction = pending.instruction || null;
      const actionLabel = pending.label || timelineAction || "Edit";
      const parentNodeId = state.imagesById.get(targetId)?.timelineNodeId || null;
      const effectTokenId = mode === "effect_token_apply" ? String(pending.effect_token_id || "").trim() : "";
      const effectTokenDispatchId = Number(pending.effect_token_dispatch_id) || 0;
      clearPendingReplace();
      if (mode === "annotate_box") {
        const cropPath = pending.cropPath || null;
        const ok = await compositeAnnotateBoxEdit(targetId, path, { box, instruction }).catch((err) => {
          console.error(err);
          return false;
        });
        // Clean up intermediate artifacts so they don't surface as "weird" partial images
        // in the filmstrip when the run is reopened.
        if (cropPath) {
          removeFile(cropPath).catch(() => {});
        }
        if (ok) {
          removeFile(path).catch(() => {});
          if (event.receipt_path) removeFile(event.receipt_path).catch(() => {});
        }
        if (!ok) {
          showToast("Annotate failed to apply the box edit.", "error", 3600);
        }
      } else {
        const ok = await replaceImageInPlace(targetId, {
          path,
          receiptPath: event.receipt_path || null,
          kind: "engine",
        }).catch((err) => {
          console.error(err);
          return false;
        });
        if (ok) {
          const nodeId = recordTimelineNode({
            imageId: targetId,
            path,
            receiptPath: event.receipt_path || null,
            label: basename(path),
            action: actionLabel,
            parents: parentNodeId ? [parentNodeId] : [],
          });
          const item = state.imagesById.get(targetId) || null;
          if (item && nodeId) item.timelineNodeId = nodeId;
          if (effectTokenId) {
            const token = state.effectTokensById.get(effectTokenId) || null;
            const sourceImageId = String(token?.sourceImageId || pending.source_image_id || "").trim();
            if (token) {
              consumeEffectToken(token);
              clearEffectTokenForImageId(sourceImageId);
            } else if (sourceImageId) {
              clearEffectTokenForImageId(sourceImageId);
            }
            if (sourceImageId && sourceImageId !== targetId) {
              await removeImageFromCanvas(sourceImageId).catch(() => {});
            }
            state.effectTokenApplyLocks.delete(effectTokenId);
            showToast("Effect consumed.", "tip", 1800);
            requestRender();
          }
        } else if (effectTokenId) {
          const token = state.effectTokensById.get(effectTokenId) || null;
          state.effectTokenApplyLocks.delete(effectTokenId);
          if (token) recoverEffectTokenApply(token);
          requestRender();
        }
      }
    } else {
      if (wasPromptGenerate) {
        seedPromptGeneratePlacementRectCss(id, promptGenerate);
      }
      addImage(
        {
          id,
          kind: "engine",
          path,
          receiptPath: event.receipt_path || null,
          label: basename(path),
          timelineAction,
          timelineParents,
        },
        { select: state.expectingArtifacts || !state.activeId }
      );
    }

    // After multi-image generations (Combine / Swap DNA / Bridge / Triforce), show only the output
    // image on the canvas and collapse the run to the output (source images removed from the filmstrip).
    // Keep multi canvas active so the resulting image remains draggable/resizable.
    if (wasMultiGenAction) {
      const sourceIds = [];
      if (blend?.sourceIds?.length) sourceIds.push(...blend.sourceIds);
      if (swapDna?.structureId) sourceIds.push(swapDna.structureId);
      if (swapDna?.surfaceId) sourceIds.push(swapDna.surfaceId);
      if (bridge?.sourceIds?.length) sourceIds.push(...bridge.sourceIds);
      if (triforce?.sourceIds?.length) sourceIds.push(...triforce.sourceIds);

      const outputId = String(id);
      for (const srcId of Array.from(new Set(sourceIds.map((v) => String(v || "").trim())))) {
        if (!srcId || srcId === outputId) continue;
        await removeImageFromCanvas(srcId).catch(() => {});
      }
    }

    // For Recast, keep only the output on canvas while preserving multi-canvas interactions.
    if (wasRecast) {
      const outputId = String(id);
      const removeIds = Array.from(new Set((state.images || []).map((item) => String(item?.id || "")).filter(Boolean)))
        .filter((imageId) => imageId !== outputId);
      for (const imageId of removeIds) {
        await removeImageFromCanvas(imageId).catch(() => {});
      }
    }

    // Same workflow for Variations/Recreate: keep only the new artifact while preserving multi mode.
    if (wasRecreate) {
      const outputId = String(id);
      const removeIds = Array.from(new Set((state.images || []).map((item) => String(item?.id || "")).filter(Boolean)))
        .filter((imageId) => imageId !== outputId);
      for (const imageId of removeIds) {
        await removeImageFromCanvas(imageId).catch(() => {});
      }
    }
    state.expectingArtifacts = false;
    restoreEngineImageModelIfNeeded();
    setStatus("Engine: ready");
    updatePortraitIdle();
    setImageFxActive(false);
    renderQuickActions();
    renderHudReadout();
    processActionQueue().catch(() => {});
  } else if (eventType === DESKTOP_EVENT_TYPES.GENERATION_FAILED) {
    promptBenchmarkMarkFailureFromGenerationFailedEvent(event);
    const idleDrafting = state.motherIdle?.phase === MOTHER_IDLE_STATES.DRAFTING;
    const idleDispatching = motherV2DispatchInFlight(state.motherIdle);
    if (idleDrafting && idleDispatching) {
      const msg = event.error ? `Mother draft failed: ${event.error}` : "Mother draft failed.";
      setStatus(`Engine: ${msg}`, true);
      motherIdleHandleGenerationFailed(msg);
      renderQuickActions();
      renderHudReadout();
      processActionQueue().catch(() => {});
      return;
    }
    const eventVersionId = motherEventVersionId(event);
    const wasMotherDispatch = motherV2DispatchInFlight(state.motherIdle);
    const hiddenSpeculativeDispatch = Boolean(
      wasMotherDispatch &&
      state.motherIdle?.phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
      state.motherIdle?.pendingDispatchSpeculative
    );
    if (wasMotherDispatch) {
      if (!motherIdleDispatchVersionMatches(eventVersionId)) {
        if (eventVersionId) motherIdleRememberIgnoredVersion(eventVersionId);
        appendMotherSuggestionLog({
          stage: "out_of_band_failed_ignored",
          request_id: state.motherIdle?.pendingSuggestionLog?.request_id || null,
          expected_version_id: state.motherIdle?.pendingVersionId || null,
          ignored_version_id: eventVersionId,
          error: event.error ? String(event.error) : null,
        }).catch(() => {});
        console.warn("[mother_suggestion] ignored out-of-band failure during active dispatch", {
          expected_version_id: state.motherIdle?.pendingVersionId || null,
          ignored_version_id: eventVersionId,
          error: event.error ? String(event.error) : null,
        });
        return;
      }
      if (hiddenSpeculativeDispatch) {
        const msg = event.error ? `Mother speculative prefetch failed: ${event.error}` : "Mother speculative prefetch failed.";
        motherIdleHandleGenerationFailed(msg, { speculative: true });
        renderMotherReadout();
        requestRender();
        return;
      }
      clearMotherIdleDispatchTimeout();
      const idle = state.motherIdle;
      const retryModel =
        idle && !idle.retryAttempted
          ? motherIdlePickRetryModel(idle.lastDispatchModel || idle.pendingSuggestionLog?.model || motherPreferredGenerationModel())
          : null;
      if (idle && retryModel) {
        const failedVersionId = idle.pendingVersionId || eventVersionId || null;
        idle.retryAttempted = true;
        idle.pendingDispatchToken = 0;
        idle.pendingDispatchSpeculative = false;
        idle.pendingDispatchProposalMode = null;
        idle.pendingPromptCompileSpeculative = false;
        idle.dispatchTimeoutExtensions = 0;
        motherIdleResetDispatchCorrelation({ rememberPendingVersion: true });
        state.expectingArtifacts = false;
        restoreEngineImageModelIfNeeded();
        appendMotherSuggestionLog({
          stage: "retry_scheduled",
          request_id: idle.pendingSuggestionLog?.request_id || null,
          from_model: idle.lastDispatchModel || idle.pendingSuggestionLog?.model || null,
          to_model: retryModel,
          version_id: failedVersionId,
          error: event.error ? String(event.error) : null,
        }).catch(() => {});
        setStatus(`Engine: Mother retrying with ${retryModel}â€¦`);
        const retried = await motherIdleDispatchGeneration().catch(() => false);
        if (retried) {
          renderQuickActions();
          renderHudReadout();
          processActionQueue().catch(() => {});
          return;
        }
      }
      const msg = event.error ? `Mother suggestion failed: ${event.error}` : "Mother suggestion failed.";
      setStatus(`Engine: ${msg}`, true);
      state.expectingArtifacts = false;
      restoreEngineImageModelIfNeeded();
      updatePortraitIdle();
      setImageFxActive(false);
      motherIdleHandleGenerationFailed(msg);
      renderQuickActions();
      renderHudReadout();
      processActionQueue().catch(() => {});
      return;
    }
    const motherIdle = state.motherIdle || null;
    if (eventVersionId && motherIdleIsIgnoredVersion(eventVersionId)) {
      appendMotherSuggestionLog({
        stage: "late_failed_ignored",
        ignored_version_id: eventVersionId,
        error: event.error ? String(event.error) : null,
        phase: motherIdle?.phase || null,
      }).catch(() => {});
      console.warn("[mother_suggestion] ignored late failure from blocked version", {
        ignored_version_id: eventVersionId,
        phase: motherIdle?.phase || null,
        error: event.error ? String(event.error) : null,
      });
      return;
    }
    if (state.pendingCreateLayers) {
      const pending = state.pendingCreateLayers;
      const idx = Math.max(0, Number(pending?.nextIndex) || 0);
      const specs = Array.isArray(pending?.layerSpecs) ? pending.layerSpecs : [];
      const spec = specs[idx] || null;
      const stageLabel = spec?.summary ? String(spec.summary) : `layer ${idx + 1}`;
      const msg = event.error
        ? `Create Layers failed while generating ${stageLabel}: ${event.error}`
        : `Create Layers failed while generating ${stageLabel}.`;
      finishCreateLayersFailure(msg);
      return;
    }
    const errText = String(event.error || "").trim();
    const errLower = errText.toLowerCase();
    const anyForegroundPending =
      Boolean(state.pendingReplace) ||
      Boolean(state.pendingBlend) ||
      Boolean(state.pendingSwapDna) ||
      Boolean(state.pendingBridge) ||
      Boolean(state.pendingCreateLayers) ||
      Boolean(state.pendingExtractDna) ||
      Boolean(state.pendingSoulLeech) ||
      Boolean(state.pendingTriforce) ||
      Boolean(state.pendingRecast) ||
      Boolean(state.pendingExtractRule) ||
      Boolean(state.pendingOddOneOut) ||
      Boolean(state.pendingRecreate) ||
      Boolean(state.pendingPromptGenerate) ||
      Boolean(state.pendingGeneration?.remaining);
    const motherRecentSuccess =
      !wasMotherDispatch &&
      Boolean(motherIdle?.generatedImageId) &&
      !state.expectingArtifacts &&
      !anyForegroundPending &&
      String(state.lastAction || "") === "Mother Suggestion" &&
      Date.now() <= (Number(motherIdle?.suppressFailureUntil) || 0);
    const looksLikeNoImageError = /no images?|failed to return|no artifacts?|no output/i.test(errLower);
    if (motherRecentSuccess && looksLikeNoImageError) {
      appendMotherSuggestionLog({
        stage: "spurious_failed_after_success",
        image_id: String(motherIdle.generatedImageId || ""),
        error: errText || null,
        phase: motherIdle?.phase || null,
        last_action: state.lastAction || null,
      }).catch(() => {});
      console.warn("[mother_suggestion] ignored spurious failure after successful artifact", {
        image_id: String(motherIdle.generatedImageId || ""),
        phase: motherIdle?.phase || null,
        error: errText || null,
      });
      state.expectingArtifacts = false;
      restoreEngineImageModelIfNeeded();
      setStatus("Engine: ready");
      updatePortraitIdle();
      setImageFxActive(false);
      renderQuickActions();
      renderHudReadout();
      processActionQueue().catch(() => {});
      return;
    }
    const msg = event.error ? `Generation failed: ${event.error}` : "Generation failed.";
    setStatus(`Engine: ${msg}`, true);
    showToast(msg, "error", 3200);
    state.expectingArtifacts = false;
    state.pendingRecreate = null;
    state.pendingBlend = null;
    state.pendingSwapDna = null;
    state.pendingBridge = null;
    state.pendingExtractDna = null;
    state.pendingSoulLeech = null;
    state.pendingTriforce = null;
    state.pendingRecast = null;
    state.pendingCreateLayers = null;
    state.pendingPromptGenerate = null;
    state.pendingExtractRule = null;
    state.pendingOddOneOut = null;
    state.tripletRuleAnnotations.clear();
    state.tripletOddOneOutId = null;
    resetActionQueue();
    clearPendingReplace();
    for (const [tokenId] of state.effectTokenApplyLocks.entries()) {
      const token = state.effectTokensById.get(tokenId) || null;
      if (token) recoverEffectTokenApply(token);
    }
    state.effectTokenApplyLocks.clear();
    restoreEngineImageModelIfNeeded();
    updatePortraitIdle();
    setImageFxActive(false);
    renderQuickActions();
    renderHudReadout();
    chooseSpawnNodes();
    requestRender();
    processActionQueue().catch(() => {});
  } else if (eventType === DESKTOP_EVENT_TYPES.COST_LATENCY_UPDATE) {
    promptBenchmarkAttachCostLatencyEvent(event);
    state.lastCostLatency = {
      provider: event.provider,
      model: event.model,
      cost_total_usd: event.cost_total_usd,
      cost_per_1k_images_usd: event.cost_per_1k_images_usd,
      latency_per_image_s: event.latency_per_image_s,
      at: Date.now(),
    };
    topMetricIngestCost(event.cost_total_usd);
    renderHudReadout();
    renderSessionApiCallsReadout();
  } else if (eventType === DESKTOP_EVENT_TYPES.CANVAS_CONTEXT) {
    const text = event.text;
    const isPartial = Boolean(event.partial);
    if (isOpenAiRealtimeSignal({ source: event.source, model: event.model })) {
      markOpenAiRealtimePortraitActivity();
    }
    if (!isPartial) {
      topMetricIngestRealtimeCostFromPayload(event, { render: true });
    }
    const aov = state.alwaysOnVision;
    if (aov) {
      if (isPartial) {
        // Keep the "pending" state while the realtime session is streaming partial text.
        aov.pending = true;
      } else {
        aov.pending = false;
        aov.pendingPath = null;
        aov.pendingAt = 0;
      }
      if (typeof text === "string" && text.trim()) {
        aov.lastText = text.trim();
      }
      aov.lastMeta = {
        source: event.source || null,
        model: event.model || null,
        at: Date.now(),
        image_path: event.image_path || null,
        partial: isPartial,
      };
      const src = String(event.source || "");
      if (realtimeSourceSupported(src)) {
        aov.rtState = "ready";
        aov.disabledReason = null;
      }
    }
    if (!isPartial) {
      clearTimeout(alwaysOnVisionTimeout);
      alwaysOnVisionTimeout = null;
    }
    updateAlwaysOnVisionReadout();
    if (!isPartial) {
      processActionQueue().catch(() => {});
    }
    if (!isPartial && typeof text === "string" && text.trim()) {
      const top = extractCanvasContextTopAction(text);
      state.canvasContextSuggestion = top?.action
        ? {
            action: top.action,
            why: top.why || null,
            at: Date.now(),
            source: event.source || null,
            model: event.model || null,
          }
        : null;
      renderQuickActions();
    }
  } else if (eventType === DESKTOP_EVENT_TYPES.CANVAS_CONTEXT_FAILED) {
    if (isOpenAiRealtimeSignal({ source: event.source, model: event.model })) {
      markOpenAiRealtimePortraitActivity();
    }
    const aov = state.alwaysOnVision;
    if (aov) {
      aov.pending = false;
      aov.pendingPath = null;
      aov.pendingAt = 0;
      const msg = event.error ? `Canvas context failed: ${event.error}` : "Canvas context failed.";
      aov.lastText = msg;
      aov.lastMeta = {
        source: event.source || null,
        model: event.model || null,
        at: Date.now(),
        image_path: event.image_path || null,
      };
      const src = String(event.source || "");
      if (event.fatal && realtimeSourceSupported(src)) {
        aov.enabled = false;
        aov.rtState = "failed";
        aov.disabledReason = event.error
          ? `Always-on vision disabled: ${event.error}`
          : `Always-on vision disabled (${src || "canvas context"} error).`;
        settings.alwaysOnVision = false;
        localStorage.setItem("brood.alwaysOnVision", "0");
        if (els.alwaysOnVisionToggle) els.alwaysOnVisionToggle.checked = false;

        clearTimeout(alwaysOnVisionTimer);
        alwaysOnVisionTimer = null;

        // Best-effort shutdown; the engine will ignore if not running.
        if (state.ptySpawned) {
          invoke("write_pty", { data: `${PTY_COMMANDS.CANVAS_CONTEXT_RT_STOP}\n` }).catch(() => {});
        }
        setStatus("Engine: always-on vision disabled (canvas context failure)", true);
      }
    }
    state.canvasContextSuggestion = null;
    clearTimeout(alwaysOnVisionTimeout);
    alwaysOnVisionTimeout = null;
    updateAlwaysOnVisionReadout();
    renderQuickActions();
    processActionQueue().catch(() => {});
  } else if (event.type === DESKTOP_EVENT_TYPES.INTENT_ICONS) {
    const intent = state.intent;
    const ambient = state.intentAmbient;
    const motherIdle = state.motherIdle;
    const motherPhase = String(motherIdle?.phase || "");
    const motherActionVersion = Number(motherIdle?.actionVersion) || 0;
    const motherPendingActionVersion = Number(motherIdle?.pendingActionVersion) || 0;
    const motherVersionMatches = motherPendingActionVersion === motherActionVersion;
    const motherRealtimePath = String(motherIdle?.pendingIntentRealtimePath || "").trim();
    const motherRequestId = String(motherIdle?.pendingIntentRequestId || "").trim() || null;
    const motherHasFallbackIntent = String(motherIdle?.intent?._intent_source_kind || "").trim().toLowerCase() === "fallback";
    const motherLateRealtimeUpgrade = Boolean(
      !motherIdle?.pendingIntent &&
      motherHasFallbackIntent &&
      motherPhase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
      motherVersionMatches &&
      motherRealtimePath &&
      Date.now() <= (Number(motherIdle?.pendingIntentUpgradeUntil) || 0) &&
      !motherIdle?.pendingPromptCompile &&
      !motherIdle?.pendingGeneration
    );
    const motherCanAcceptRealtime = Boolean(
      (motherIdle?.pendingIntent && motherPhase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING && motherVersionMatches) ||
      motherLateRealtimeUpgrade
    );
    if (!intent && !ambient && !motherCanAcceptRealtime) return;
    const isPartial = Boolean(event.partial);
    if (isOpenAiRealtimeSignal({ source: event.source, model: event.model })) {
      markOpenAiRealtimePortraitActivity();
    }
    if (!isPartial) {
      topMetricIngestRealtimeCostFromPayload(event, { render: true });
    }
    const text = event.text;
    const path = event.image_path ? String(event.image_path) : "";
    if (!path) return;
    const eventIntentScope = String(event.intent_scope || "").trim().toLowerCase();
    const eventIsMotherScoped = !eventIntentScope || eventIntentScope === "mother";
    const eventActionVersionRaw = Number(event.action_version);
    const routing = classifyIntentIconsRouting({
      path,
      intentPendingPath: intent?.pendingPath,
      ambientPendingPath: ambient?.pendingPath,
      motherCanAcceptRealtime,
      motherRealtimePath,
      motherActionVersion,
      eventActionVersion: eventActionVersionRaw,
      eventIntentScope,
    });
    const { matchAmbient, matchIntent, matchMother, ignoreReason } = routing;
    if (ignoreReason === "scope_mismatch") {
      return;
    }
    if (ignoreReason === "snapshot_path_mismatch" || ignoreReason === "path_mismatch") {
      if (!isPartial && ignoreReason === "snapshot_path_mismatch") {
        appendMotherTraceLog({
          kind: "intent_icons_ignored",
          traceId: motherIdle?.telemetry?.traceId || null,
          actionVersion: motherActionVersion,
          request_id: motherRequestId,
          reason: ignoreReason,
          expected_snapshot_path: motherRealtimePath || null,
          event_snapshot_path: path || null,
          event_action_version: Number.isFinite(eventActionVersionRaw) ? eventActionVersionRaw : null,
        }).catch(() => {});
      }
      return;
    }
    if (ignoreReason === "event_action_version_mismatch") {
      appendMotherTraceLog({
        kind: "intent_icons_ignored",
        traceId: motherIdle?.telemetry?.traceId || null,
        actionVersion: motherActionVersion,
        request_id: motherRequestId,
        reason: ignoreReason,
        event_action_version: eventActionVersionRaw,
      }).catch(() => {});
      return;
    }

    if (isPartial) {
      if (matchIntent && intent) intent.pending = true;
      if (matchAmbient && ambient) ambient.pending = true;
    } else {
      if (matchIntent && intent) {
        intent.pending = false;
        intent.pendingPath = null;
        intent.pendingAt = 0;
        intent.pendingFrameId = null;
      }
      if (matchAmbient && ambient) {
        clearAmbientIntentPending();
      }
    }

    const hasText = typeof text === "string" && text.trim();
    if (hasText) {
      if (isPartial && matchMother && motherIdle?.pendingIntent) {
        // Sliding timeout: keep request alive while realtime stream is actively delivering deltas.
        motherV2ArmRealtimeIntentTimeout({ timeoutMs: MOTHER_V2_INTENT_RT_TIMEOUT_MS });
      }
      const parsedResult = parseIntentIconsJsonDetailed(text);
      const parsed = parsedResult?.ok ? parsedResult.value : null;
      const parseStrategy = String(parsedResult?.strategy || "none");
      const parseReason = parsedResult?.reason ? String(parsedResult.reason) : null;
      const parseError = parsedResult?.error ? String(parsedResult.error) : null;
      const textLen = text.length;
      const textHash = intentIconsPayloadChecksum(text);

      if (!isPartial) {
        const snippet = parsed ? { head: "", tail: "" } : intentIconsPayloadSafeSnippet(text);
        if (matchIntent || matchAmbient) {
          appendIntentTrace({
            kind: "model_icons_payload_parse",
            parse_ok: Boolean(parsed),
            parse_strategy: parseStrategy,
            parse_reason: parseReason,
            parse_error: parseError,
            snapshot_path: path ? String(path) : null,
            request_id: matchMother ? motherRequestId : null,
            action_version: matchMother ? motherActionVersion : null,
            source: event.source || null,
            model: event.model || null,
            response_status: event.response_status ? String(event.response_status) : null,
            response_status_reason: event.response_status_reason ? String(event.response_status_reason) : null,
            text_len: textLen,
            text_hash: textHash,
            snippet_head: snippet.head || null,
            snippet_tail: snippet.tail || null,
          }).catch(() => {});
        }
        if (matchMother && motherIdle) {
          appendMotherTraceLog({
            kind: "intent_payload_parse",
            traceId: motherIdle.telemetry?.traceId || null,
            actionVersion: Number(motherIdle.actionVersion) || 0,
            request_id: motherRequestId,
            snapshot_path: path || null,
            parse_ok: Boolean(parsed),
            parse_strategy: parseStrategy,
            parse_reason: parseReason,
            parse_error: parseError,
            source: event.source || null,
            model: event.model || null,
            response_status: event.response_status ? String(event.response_status) : null,
            response_status_reason: event.response_status_reason ? String(event.response_status_reason) : null,
            text_len: textLen,
            text_hash: textHash,
            snippet_head: snippet.head || null,
            snippet_tail: snippet.tail || null,
          }).catch(() => {});
        }
      }

      if (parsed) {
        // Capture per-image vision labels from the intent realtime response so we can
        // use them as signals without issuing separate /describe calls.
        const imageDescs = !isPartial ? extractIntentImageDescriptions(parsed) : [];
        if (!isPartial && matchAmbient) {
          maybeScheduleVisionDescribeFallbackForAmbientRealtime(ambient, imageDescs);
        }
        let wroteVision = false;
        if (!isPartial && imageDescs.length) {
          for (const rec of imageDescs) {
            const imageId = rec?.image_id ? String(rec.image_id) : "";
            const label = rec?.label ? String(rec.label) : "";
            if (!imageId || !label) continue;
            const imgItem = state.imagesById.get(imageId) || null;
            if (!imgItem) continue;
            const prevLabel = _normalizeVisionLabel(imgItem.visionDesc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS });
            const prevSource = String(imgItem?.visionDescMeta?.source || "").trim();
            const keepExplicitDescribe =
              Boolean(prevLabel) &&
              (prevSource === "openai_realtime_describe" || prevSource === "openai_vision");
            if (keepExplicitDescribe) {
              continue;
            }
            if (prevLabel && prevLabel === label) {
              maybeScheduleVisionDescribeFallback(imgItem, prevLabel);
              continue;
            }
            imgItem.visionDesc = label;
            imgItem.visionPending = false;
            imgItem.visionDescMeta = {
              source: event.source || null,
              model: event.model || null,
              at: Date.now(),
            };
            maybeScheduleVisionDescribeFallback(imgItem, label);
            wroteVision = true;
            if (intentModeActive() || intentAmbientActive()) {
              appendIntentTrace({
                kind: "vision_description",
                image_id: imageId,
                image_path: imgItem?.path ? String(imgItem.path) : null,
                description: label,
                source: event.source || null,
                model: event.model || null,
              }).catch(() => {});
            }
          }
        }

        if (wroteVision) {
          scheduleVisualPromptWrite();
          if (getActiveImage()?.id) renderHudReadout();
        }

        const parsedAt = Date.now();
        if (matchIntent && intent) {
          intent.iconState = parsed;
          intent.iconStateAt = parsedAt;
          intent.rtState = "ready";
          intent.disabledReason = null;
          intent.lastError = null;
          intent.lastErrorAt = 0;
          intent.uiHideSuggestion = false;
        }
        if (matchAmbient && ambient) {
          ambient.iconState = parsed;
          ambient.iconStateAt = parsedAt;
          ambient.rtState = "ready";
          ambient.disabledReason = null;
          ambient.lastError = null;
          ambient.lastErrorAt = 0;
          if (!isPartial) {
            const touched = imageDescs.map((rec) => String(rec?.image_id || "")).filter(Boolean);
            if (touched.length) rememberAmbientTouchedImageIds(touched);
            rebuildAmbientIntentSuggestions(parsed, { reason: "realtime", nowMs: parsedAt });
          }
        }
        if (matchMother && motherIdle && !isPartial) {
          const payloadForMother = motherIdle.pendingIntentPayload && typeof motherIdle.pendingIntentPayload === "object"
            ? motherIdle.pendingIntentPayload
            : motherV2IntentPayload();
          const realtimeIntent = motherV2IntentFromRealtimeIcons(parsed, payloadForMother);
          const hasRealtimeModeSignal = Boolean(
            motherV2MaybeTransformationMode(realtimeIntent?.transformation_mode) ||
              (Array.isArray(realtimeIntent?.transformation_mode_candidates) &&
                realtimeIntent.transformation_mode_candidates.some((entry) =>
                  Boolean(motherV2MaybeTransformationMode(entry?.mode || entry?.transformation_mode))
                ))
          );
          if (!hasRealtimeModeSignal) {
            const missingModeMessage = "Mother realtime intent missing transformation mode.";
            appendMotherTraceLog({
              kind: "intent_realtime_failed",
              traceId: motherIdle.telemetry?.traceId || null,
              actionVersion: Number(motherIdle.actionVersion) || 0,
              request_id: motherRequestId,
              source: event.source || "intent_rt_realtime",
              error: missingModeMessage,
            }).catch(() => {});
            motherIdleHandleGenerationFailed(missingModeMessage);
            return;
          }
          const isLateRealtimeUpgrade = !motherIdle.pendingIntent;
          if (!motherIdle.pendingIntent) {
            appendMotherTraceLog({
              kind: "intent_realtime_upgrade",
              traceId: motherIdle.telemetry?.traceId || null,
              actionVersion: Number(motherIdle.actionVersion) || 0,
              request_id: motherRequestId,
              snapshot_path: path || null,
            }).catch(() => {});
          }
          motherV2ApplyIntent(realtimeIntent, {
            source: event.source || "intent_rt_realtime",
            sourceModel: event.model || null,
            requestId: motherRequestId,
            preserveMode: isLateRealtimeUpgrade,
          });
        }
        // Keep focus stable if possible (unless rejected); otherwise pick the next suggestion.
        const picked = pickSuggestedIntentBranch(parsed);
        if (matchIntent && intent) {
          intent.focusBranchId = (picked?.branch_id ? String(picked.branch_id) : "") || pickDefaultIntentFocusBranchId(parsed);
        }
        if (!isPartial && (matchIntent || matchAmbient)) {
          const branchIds = Array.isArray(parsed?.branches)
            ? parsed.branches.map((b) => (b?.branch_id ? String(b.branch_id) : "")).filter(Boolean)
            : [];
          const branchRank = Array.isArray(parsed?.branches)
            ? parsed.branches
                .map((b) => ({
                  branch_id: b?.branch_id ? String(b.branch_id) : "",
                  confidence: typeof b?.confidence === "number" && Number.isFinite(b.confidence) ? clamp(Number(b.confidence) || 0, 0, 1) : null,
                  evidence_image_ids: Array.isArray(b?.evidence_image_ids)
                    ? b.evidence_image_ids.map((v) => String(v || "").trim()).filter(Boolean).slice(0, 3)
                    : [],
                }))
                .filter((b) => Boolean(b.branch_id))
            : [];
          appendIntentTrace({
            kind: "model_icons",
            partial: false,
            frame_id: parsed?.frame_id ? String(parsed.frame_id) : null,
            snapshot_path: path ? String(path) : null,
            branch_ids: branchIds,
            branch_rank: branchRank.length ? branchRank : null,
            focus_branch_id: intent?.focusBranchId ? String(intent.focusBranchId) : null,
            checkpoint_applies_to: parsed?.checkpoint?.applies_to ? String(parsed.checkpoint.applies_to) : null,
            checkpoint_branch_id: picked?.checkpoint_branch_id ? String(picked.checkpoint_branch_id) : null,
            ranked_branch_ids: Array.isArray(picked?.ranked_branch_ids) && picked.ranked_branch_ids.length ? picked.ranked_branch_ids : null,
            suggestion_reason: picked?.reason ? String(picked.reason) : null,
            image_descriptions: imageDescs.length ? imageDescs : null,
            text_len: textLen,
            text_hash: textHash,
            parse_strategy: parseStrategy,
          }).catch(() => {});
        }
        if (matchIntent && intent) {
          const total = Math.max(1, Number(intent.totalRounds) || 3);
          const round = Math.max(1, Number(intent.round) || 1);
          // After the final round proposals arrive, force an explicit YES to proceed.
          if (INTENT_FORCE_CHOICE_ENABLED && INTENT_ROUNDS_ENABLED && !isPartial && round >= total && !intent.forceChoice) {
            intent.forceChoice = true;
            ensureIntentFallbackIconState("final_round");
            scheduleIntentStateWrite({ immediate: true });
          } else {
            if (!INTENT_FORCE_CHOICE_ENABLED) intent.forceChoice = false;
            scheduleIntentStateWrite();
          }
        }
      } else if (!isPartial) {
        // Treat invalid JSON as a non-fatal failure: fall back to local branches and keep the UI interactive.
        const parseReasonLabel = parseReason ? parseReason.replace(/_/g, " ") : "parse failed";
        const intentParseMessage = `Intent icons parse failed (${parseReasonLabel}).`;
        const snippet = intentIconsPayloadSafeSnippet(text);
        if (matchIntent && intent) {
          intent.rtState = "failed";
          intent.disabledReason = "Intent icons parse failed.";
          intent.lastError = intent.disabledReason;
          intent.lastErrorAt = Date.now();
          intent.uiHideSuggestion = false;
          if (!INTENT_FORCE_CHOICE_ENABLED) intent.forceChoice = false;
          const icon = ensureIntentFallbackIconState("parse_failed");
          if (!intent.focusBranchId) intent.focusBranchId = pickSuggestedIntentBranchId(icon) || pickDefaultIntentFocusBranchId(icon);
        }
        if (matchAmbient && ambient) {
          applyAmbientIntentFallback("parse_failed", { message: intentParseMessage });
          maybeScheduleVisionDescribeFallbackForAmbientRealtime(ambient, []);
        }
        if (matchMother && motherIdle) {
          const fallbackMessage = parseReason === "truncated_json"
            ? "Mother realtime intent response was truncated."
            : "Mother realtime intent parse failed.";
          appendMotherTraceLog({
            kind: "intent_realtime_failed",
            traceId: motherIdle.telemetry?.traceId || null,
            actionVersion: Number(motherIdle.actionVersion) || 0,
            request_id: motherRequestId,
            source: "intent_rt_parse_failed",
            parse_reason: parseReason,
            parse_strategy: parseStrategy,
            parse_error: parseError,
            response_status: event.response_status ? String(event.response_status) : null,
            response_status_reason: event.response_status_reason ? String(event.response_status_reason) : null,
            snapshot_path: path || null,
            text_len: textLen,
            text_hash: textHash,
            snippet_head: snippet.head || null,
            snippet_tail: snippet.tail || null,
            error: fallbackMessage,
          }).catch(() => {});
          motherIdleHandleGenerationFailed(fallbackMessage);
        }
        if (matchIntent || matchAmbient) {
          appendIntentTrace({
            kind: "model_icons_parse_failed",
            reason: intent?.disabledReason || intentParseMessage,
            parse_reason: parseReason,
            parse_strategy: parseStrategy,
            parse_error: parseError,
            response_status: event.response_status ? String(event.response_status) : null,
            response_status_reason: event.response_status_reason ? String(event.response_status_reason) : null,
            snapshot_path: path ? String(path) : null,
            text_len: textLen,
            text_hash: textHash,
            snippet_head: snippet.head || null,
            snippet_tail: snippet.tail || null,
            rt_state: intent?.rtState || ambient?.rtState || "failed",
          }).catch(() => {});
        }
        if (matchIntent && intent) scheduleIntentStateWrite({ immediate: true });
      }
    }

    if (!isPartial) {
      if (matchIntent) {
        clearTimeout(intentInferenceTimeout);
        intentInferenceTimeout = null;
      }
      if (matchAmbient) {
        clearTimeout(intentAmbientInferenceTimeout);
        intentAmbientInferenceTimeout = null;
      }
    }

    requestRender();
    renderQuickActions();
  } else if (event.type === DESKTOP_EVENT_TYPES.INTENT_ICONS_FAILED) {
    const intent = state.intent;
    const ambient = state.intentAmbient;
    let motherIdle = state.motherIdle;
    const path = event.image_path ? String(event.image_path) : "";
    if (!path) return;
    const eventIntentScope = String(event.intent_scope || "").trim().toLowerCase();
    const eventIsMotherScoped = !eventIntentScope || eventIntentScope === "mother";
    if (eventIsMotherScoped) {
      motherV2ClearIntentRealtimeBusy({
        path,
        reason: "intent_icons_failed",
      });
    }
    const resolveActiveMotherRealtimeFailureTarget = () => {
      const motherIdleLatest = state.motherIdle;
      const matchMotherLatest = Boolean(
        eventIsMotherScoped &&
          motherIdleLatest?.pendingIntent &&
          String(motherIdleLatest?.phase || "") === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING &&
          String(motherIdleLatest?.pendingIntentRealtimePath || "") === path &&
          (Number(motherIdleLatest?.pendingActionVersion) || 0) === (Number(motherIdleLatest?.actionVersion) || 0)
      );
      const motherRequestIdLatest = String(motherIdleLatest?.pendingIntentRequestId || "").trim() || null;
      return { motherIdleLatest, matchMotherLatest, motherRequestIdLatest };
    };
    const matchAmbient = Boolean(ambient?.pendingPath && String(ambient.pendingPath) === path);
    const matchIntent = Boolean(intent?.pendingPath && String(intent.pendingPath) === path);
    let { motherIdleLatest: resolvedMotherIdle, matchMotherLatest: matchMother, motherRequestIdLatest: motherRequestId } =
      resolveActiveMotherRealtimeFailureTarget();
    motherIdle = resolvedMotherIdle;
    if (!matchIntent && !matchAmbient && !matchMother) return;
    if (isOpenAiRealtimeSignal({ source: event.source, model: event.model })) {
      markOpenAiRealtimePortraitActivity();
    }

    if (matchIntent && intent) {
      intent.pending = false;
      intent.pendingPath = null;
      intent.pendingAt = 0;
      intent.pendingFrameId = null;
    }
    if (matchAmbient && ambient) {
      clearAmbientIntentPending();
    }
    if (matchIntent) {
      clearTimeout(intentInferenceTimeout);
      intentInferenceTimeout = null;
    }
    if (matchAmbient) {
      clearTimeout(intentAmbientInferenceTimeout);
      intentAmbientInferenceTimeout = null;
    }

    const errRaw = typeof event.error === "string" ? event.error.trim() : "";
    const msg = errRaw ? `Intent inference failed: ${errRaw}` : "Intent inference failed.";
    const retryDecision = nextMotherRealtimeIntentFailureAction({
      event,
      matchMother,
      pendingIntent: Boolean(motherIdle?.pendingIntent),
      phase: motherIdle?.phase || "",
      actionVersion: Number(motherIdle?.actionVersion) || 0,
      pendingActionVersion: Number(motherIdle?.pendingActionVersion) || 0,
      retryCount: Number(motherIdle?.pendingIntentTransportRetryCount) || 0,
      maxRetries: MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX,
    });
    if (retryDecision.action === "retry") {
      const retried = await motherV2RetryRealtimeIntentTransport({
        path,
        errorMessage: msg,
      });
      if (retried) {
        setStatus("Mother: retrying realtime intentâ€¦");
        renderMotherReadout();
        requestRender();
        return;
      }
      ({ motherIdleLatest: motherIdle, matchMotherLatest: matchMother, motherRequestIdLatest: motherRequestId } =
        resolveActiveMotherRealtimeFailureTarget());
      if (!matchIntent && !matchAmbient && !matchMother) return;
    }
    if (retryDecision.retryable && retryDecision.action === "fail") {
      appendMotherTraceLog({
        kind: "intent_realtime_retry_exhausted",
        traceId: motherIdle?.telemetry?.traceId || null,
        actionVersion: Number(motherIdle?.actionVersion) || 0,
        request_id: motherRequestId,
        retry_count: Number(motherIdle?.pendingIntentTransportRetryCount) || 0,
        max_retries: MOTHER_V2_INTENT_RT_TRANSPORT_RETRY_MAX,
        reason: retryDecision.reason || null,
        error: msg,
      }).catch(() => {});
    }
		    if (matchIntent && intent) {
		      intent.rtState = "failed";
		      intent.lastError = msg;
	      intent.lastErrorAt = Date.now();
	      intent.uiHideSuggestion = false;
	    }
	    if (matchIntent || matchAmbient) {
	      appendIntentTrace({
	        kind: "model_icons_failed",
	        reason: msg,
	        snapshot_path: path ? String(path) : null,
	        rt_state: intent?.rtState || ambient?.rtState || "failed",
	      }).catch(() => {});
	    }

    const errLower = errRaw.toLowerCase();
    const hardDisable = Boolean(
      errLower.includes("missing openai_api_key") ||
        errLower.includes("missing gemini_api_key") ||
        errLower.includes("missing google_api_key") ||
        errLower.includes("gemini_api_key (or google_api_key)") ||
        errLower.includes("realtime provider 'openai_realtime'") ||
        errLower.includes("realtime provider 'gemini_flash'") ||
        errLower.includes("openrouter_api_key alone is insufficient") ||
        errLower.includes("missing dependency") ||
        errLower.includes("disabled (brood_intent_realtime_disabled=1") ||
        errLower.includes("realtime intent inference is disabled")
    );
    // Only treat clearly-unrecoverable cases as a "hard" disabled state. Otherwise,
    // keep retrying opportunistically while the user continues arranging images.
    if (matchIntent && intent) intent.disabledReason = hardDisable ? msg : null;

    // Fall back to a local branch set so the user can still lock an intent.
    if (matchIntent && intent) {
      ensureIntentFallbackIconState("failed");
      if (!intent.focusBranchId) {
        intent.focusBranchId = pickSuggestedIntentBranchId(intent.iconState) || pickDefaultIntentFocusBranchId();
      }
    }
    if (matchAmbient && ambient) {
      applyAmbientIntentFallback("failed", { message: msg, hardDisable });
      maybeScheduleVisionDescribeFallbackForAmbientRealtime(ambient, []);
    }
    if (matchMother && motherIdle) {
      appendMotherTraceLog({
        kind: "intent_realtime_failed",
        traceId: motherIdle.telemetry?.traceId || null,
        actionVersion: Number(motherIdle.actionVersion) || 0,
        request_id: motherRequestId,
        source: "intent_rt_failed",
        error: msg,
      }).catch(() => {});
      motherIdleHandleGenerationFailed(`Mother realtime intent failed. ${msg}`);
    }

    if (matchIntent && intent && !INTENT_FORCE_CHOICE_ENABLED) {
      intent.forceChoice = false;
    } else if (matchIntent && intent) {
      // Only force choice if time is up or we're already at the final round gate.
      const total = Math.max(1, Number(intent.totalRounds) || 3);
      const round = Math.max(1, Number(intent.round) || 1);
      const remainingMs = intent.startedAt ? intentRemainingMs(Date.now()) : INTENT_DEADLINE_MS;
      const gateByTimer = Boolean(INTENT_TIMER_ENABLED) && remainingMs <= 0;
      const gateByRounds = Boolean(INTENT_ROUNDS_ENABLED) && round >= total;
      if (gateByTimer || gateByRounds) {
        intent.forceChoice = true;
      }
    }

    if (matchIntent && intent) scheduleIntentStateWrite({ immediate: true });
    if (matchIntent || matchAmbient) setStatus(`Engine: ${msg}`, true);
    requestRender();
    renderQuickActions();

    if (matchAmbient && ambient && !hardDisable) {
      scheduleAmbientIntentInference({ immediate: false, reason: "composition_change" });
    }
    if (!hardDisable && matchIntent && intentModeActive() && intent && !intent.forceChoice) {
      scheduleIntentInference({ immediate: false, reason: "retry" });
    }
	  } else if (event.type === DESKTOP_EVENT_TYPES.IMAGE_DESCRIPTION) {
	    const path = event.image_path;
	    const desc = event.description;
	    if (typeof path === "string" && typeof desc === "string" && desc.trim()) {
	      const cleaned = _normalizeVisionLabel(desc, { maxChars: REALTIME_VISION_LABEL_MAX_CHARS }) || desc.trim();
	      for (const item of state.images) {
	        if (item?.path === path) {
	          item.visionDesc = cleaned;
	          item.visionPending = false;
	          item.visionDescMeta = {
	            source: event.source || null,
	            model: event.model || null,
	            at: Date.now(),
	          };
	          break;
	        }
	      }
	      dropDescribeQueuedPath(path);
	      const releasedSlot = clearDescribeInFlightPath(path);
	      if (releasedSlot) processDescribeQueue();
	      // Persist the new per-image description into run artifacts.
	      scheduleVisualPromptWrite();
	
	      if (intentAmbientActive()) {
	        appendIntentTrace({
	          kind: "ambient_vision_description",
	          image_path: path,
	          description: cleaned,
	          source: event.source || null,
	          model: event.model || null,
	        }).catch(() => {});
	        const touched = state.images
	          .filter((img) => img?.path === path)
	          .map((img) => String(img.id || ""))
	          .filter(Boolean);
	        // Vision-derived labels are useful intent signals; schedule a refresh so the
	        // suggested branch can tighten as these descriptions arrive.
	        scheduleAmbientIntentInference({ immediate: true, reason: "describe", imageIds: touched });
	      }
	      if (getActiveImage()?.path === path) renderHudReadout();
	    }
	  } else if (event.type === DESKTOP_EVENT_TYPES.IMAGE_DNA_EXTRACTED) {
    const path = typeof event.image_path === "string" ? event.image_path : "";
    const matchedImageId = consumePendingEffectExtraction("dna", path);
    const resolvedImageId = matchedImageId || resolveExtractionEventImageIdByPath(path);
    if (!resolvedImageId) {
      requestRender();
      return;
    }
    const item = state.imagesById.get(resolvedImageId) || null;
    if (item?.id) {
      const token = createOrUpdateEffectToken({
        type: "extract_dna",
        imageId: item.id,
        imagePath: path,
        palette: Array.isArray(event.palette) ? event.palette : [],
        colors: Array.isArray(event.colors) ? event.colors : [],
        materials: Array.isArray(event.materials) ? event.materials : [],
        summary: typeof event.summary === "string" ? event.summary : "",
        source: event.source || null,
        model: event.model || null,
      });
      if (token) {
        if (!suppressReelDnaToasts()) {
          showToast(`DNA extracted: ${item.label || basename(item.path)}`, "tip", 1800);
        }
      }
      requestRender();
    }
  } else if (event.type === DESKTOP_EVENT_TYPES.IMAGE_DNA_EXTRACTED_FAILED) {
    const path = typeof event.image_path === "string" ? event.image_path : "";
    const msg = event.error ? `Extract DNA failed: ${event.error}` : "Extract DNA failed.";
    showToast(msg, "error", 2600);
    if (path) consumePendingEffectExtraction("dna", path);
    else {
      state.pendingExtractDna = null;
      updatePortraitIdle();
      renderQuickActions();
      processActionQueue().catch(() => {});
    }
  } else if (event.type === DESKTOP_EVENT_TYPES.IMAGE_SOUL_EXTRACTED) {
    const path = typeof event.image_path === "string" ? event.image_path : "";
    const matchedImageId = consumePendingEffectExtraction("soul", path);
    const resolvedImageId = matchedImageId || resolveExtractionEventImageIdByPath(path);
    if (!resolvedImageId) {
      requestRender();
      return;
    }
    const item = state.imagesById.get(resolvedImageId) || null;
    if (item?.id) {
      const token = createOrUpdateEffectToken({
        type: "soul_leech",
        imageId: item.id,
        imagePath: path,
        emotion: typeof event.emotion === "string" ? event.emotion : "",
        summary: typeof event.summary === "string" ? event.summary : "",
        source: event.source || null,
        model: event.model || null,
      });
      if (token) {
        showToast(`Soul extracted: ${item.label || basename(item.path)}`, "tip", 1800);
      }
      requestRender();
    }
  } else if (event.type === DESKTOP_EVENT_TYPES.IMAGE_SOUL_EXTRACTED_FAILED) {
    const path = typeof event.image_path === "string" ? event.image_path : "";
    const msg = event.error ? `Soul Leech failed: ${event.error}` : "Soul Leech failed.";
    showToast(msg, "error", 2600);
    if (path) consumePendingEffectExtraction("soul", path);
    else {
      state.pendingSoulLeech = null;
      updatePortraitIdle();
      renderQuickActions();
      processActionQueue().catch(() => {});
    }
  } else if (event.type === DESKTOP_EVENT_TYPES.TRIPLET_RULE) {
    state.pendingExtractRule = null;
    const paths = Array.isArray(event.image_paths) ? event.image_paths : [];
    const principle = typeof event.principle === "string" ? event.principle.trim() : "";
    const evidence = Array.isArray(event.evidence) ? event.evidence : [];
    const textRaw = typeof event.text === "string" ? event.text.trim() : "";
    let text = textRaw;
    if (!text) {
      const lines = [];
      if (principle) {
        lines.push("RULE:");
        lines.push(principle);
      }
      if (evidence.length) {
        if (lines.length) lines.push("");
        lines.push("EVIDENCE:");
        for (const item of evidence.slice(0, 6)) {
          const img = item?.image ? String(item.image).trim() : "";
          const note = item?.note ? String(item.note).trim() : "";
          if (!note) continue;
          lines.push(`- ${img ? `${img}: ` : ""}${note}`);
        }
      }
      text = lines.join("\n").trim();
    }

    state.tripletRuleAnnotations.clear();
    state.tripletOddOneOutId = null;
    const annotations = Array.isArray(event.annotations) ? event.annotations : [];
    if (paths.length === 3 && annotations.length) {
      for (const ann of annotations) {
        const tag = String(ann?.image || "").trim().toUpperCase();
        const idx = tag === "A" ? 0 : tag === "B" ? 1 : tag === "C" ? 2 : -1;
        if (idx < 0) continue;
        const x = Number(ann?.x);
        const y = Number(ann?.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        const label = ann?.label ? String(ann.label).trim() : "";
        const targetPath = paths[idx];
        const imgItem = state.images.find((it) => it?.path === targetPath) || null;
        if (!imgItem?.id) continue;
        const points = state.tripletRuleAnnotations.get(imgItem.id) || [];
        points.push({ x: clamp(x, 0, 1), y: clamp(y, 0, 1), label: clampText(label, 64) });
        state.tripletRuleAnnotations.set(imgItem.id, points);
      }
    }

    if (text) {
      setDirectorText(text, {
        kind: "extract_rule",
        source: event.source || null,
        model: event.model || null,
        at: Date.now(),
        paths,
      });
    }
    setStatus("Director: rule ready");
    showToast("Extract the Rule ready.", "tip", 2400);
    updatePortraitIdle();
    renderQuickActions();
    requestRender();
    processActionQueue().catch(() => {});
  } else if (event.type === DESKTOP_EVENT_TYPES.TRIPLET_RULE_FAILED) {
    state.pendingExtractRule = null;
    const msg = event.error ? `Extract the Rule failed: ${event.error}` : "Extract the Rule failed.";
    setStatus(`Director: ${msg}`, true);
    showToast(msg, "error", 3200);
    updatePortraitIdle();
    renderQuickActions();
    processActionQueue().catch(() => {});
  } else if (event.type === DESKTOP_EVENT_TYPES.TRIPLET_ODD_ONE_OUT) {
    state.pendingOddOneOut = null;
    const paths = Array.isArray(event.image_paths) ? event.image_paths : [];
    const oddIndex = typeof event.odd_index === "number" ? event.odd_index : null;
    const oddTag = typeof event.odd_image === "string" ? event.odd_image.trim().toUpperCase() : "";
    let oddPath = null;
    if (oddIndex !== null && oddIndex >= 0 && oddIndex < paths.length) {
      oddPath = paths[oddIndex];
    } else if (paths.length === 3) {
      if (oddTag === "A") oddPath = paths[0];
      if (oddTag === "B") oddPath = paths[1];
      if (oddTag === "C") oddPath = paths[2];
    }
    const oddItem = oddPath ? state.images.find((it) => it?.path === oddPath) || null : null;
    state.tripletOddOneOutId = oddItem?.id || null;
    state.tripletRuleAnnotations.clear();

    const textRaw = typeof event.text === "string" ? event.text.trim() : "";
    let text = textRaw;
    if (!text) {
      const pattern = typeof event.pattern === "string" ? event.pattern.trim() : "";
      const why = typeof event.explanation === "string" ? event.explanation.trim() : "";
      const lines = [];
      if (oddTag || oddIndex !== null) lines.push(`ODD ONE OUT: ${oddTag || String(oddIndex + 1)}`);
      if (pattern) {
        if (lines.length) lines.push("");
        lines.push("THE SHARED PATTERN:");
        lines.push(pattern);
      }
      if (why) {
        if (lines.length) lines.push("");
        lines.push("WHY IT BREAKS:");
        lines.push(why);
      }
      text = lines.join("\n").trim();
    }

    if (text) {
      setDirectorText(text, {
        kind: "odd_one_out",
        source: event.source || null,
        model: event.model || null,
        at: Date.now(),
        paths,
      });
    }
    setStatus("Director: odd one out ready");
    showToast("Odd One Out ready.", "tip", 2400);
    updatePortraitIdle();
    renderQuickActions();
    requestRender();
    processActionQueue().catch(() => {});
  } else if (event.type === DESKTOP_EVENT_TYPES.TRIPLET_ODD_ONE_OUT_FAILED) {
    state.pendingOddOneOut = null;
    const msg = event.error ? `Odd One Out failed: ${event.error}` : "Odd One Out failed.";
    setStatus(`Director: ${msg}`, true);
    showToast(msg, "error", 3200);
    updatePortraitIdle();
    renderQuickActions();
    processActionQueue().catch(() => {});
  } else if (event.type === DESKTOP_EVENT_TYPES.RECREATE_PROMPT_INFERRED) {
    const prompt = event.prompt;
    if (typeof prompt === "string") {
      state.lastRecreatePrompt = prompt;
      const ref = event.reference;
      if (typeof ref === "string" && ref) {
        for (const item of state.images) {
          if (item?.path === ref) {
            item.recreatePrompt = prompt;
            break;
          }
        }
      }
      setStatus("Engine: recreate (zero-prompt) runningâ€¦");
    }
    renderHudReadout();
  } else if (event.type === DESKTOP_EVENT_TYPES.RECREATE_ITERATION_UPDATE) {
    const iter = event.iteration;
    const sim = event.similarity;
    if (typeof iter === "number") {
      const pct = typeof sim === "number" ? `${Math.round(sim * 100)}%` : "â€”";
      setStatus(`Engine: recreate iter ${iter} (best ${pct})`);
    }
    renderHudReadout();
  } else if (event.type === DESKTOP_EVENT_TYPES.RECREATE_DONE) {
    state.pendingRecreate = null;
    setStatus("Engine: variations ready");
    setTip("Variations complete.");
    updatePortraitIdle();
    renderQuickActions();
    renderHudReadout();
    processActionQueue().catch(() => {});
  }
}

function hitTestEffectToken(ptCanvas) {
  if (!ptCanvas || state.canvasMode !== "multi") return null;
  if (effectsRuntime) {
    const runtimeHit = effectsRuntime.hitTestToken(ptCanvas);
    if (runtimeHit?.tokenId) {
      const imageId = String(runtimeHit.imageId || "").trim();
      const token = state.effectTokensById.get(String(runtimeHit.tokenId || "").trim()) || null;
      const rect = imageId ? state.multiRects.get(imageId) || null : null;
      if (token && imageId && rect) {
        return { tokenId: token.id, imageId, token, rect };
      }
    }
  }
  const transform = getMultiViewTransform();
  const x = (Number(ptCanvas.x) - transform.offsetX) / transform.scale;
  const y = (Number(ptCanvas.y) - transform.offsetY) / transform.scale;
  const order = Array.isArray(state.freeformZOrder) && state.freeformZOrder.length
    ? state.freeformZOrder
    : Array.from(state.multiRects.keys());
  for (let i = order.length - 1; i >= 0; i -= 1) {
    const imageId = String(order[i] || "").trim();
    if (!imageId) continue;
    const token = effectTokenForImageId(imageId);
    if (!token) continue;
    const rect = state.multiRects.get(imageId) || null;
    if (!rect) continue;
    const cx = rect.x + rect.w * 0.5;
    const cy = rect.y + rect.h * 0.5;
    const r = Math.max(14, Math.min(rect.w, rect.h) * 0.19);
    const dx = x - cx;
    const dy = y - cy;
    if (dx * dx + dy * dy > r * r) continue;
    return { tokenId: token.id, imageId, token, rect };
  }
  return null;
}

function renderMultiCanvas(wctx, octx, canvasW, canvasH) {
  state.motherOverlayUiHits = [];
  const items = state.images || [];
  const nowMs = performance.now ? performance.now() : Date.now();
  const dragPerfMode = isFreeformTransformPointerDragActive();
  for (const item of items) {
    ensureCanvasImageLoaded(item);
  }

  state.multiRects = computeFreeformRectsPx(canvasW, canvasH);
  const ms = Number(state.multiView?.scale) || 1;
  const mox = Number(state.multiView?.offsetX) || 0;
  const moy = Number(state.multiView?.offsetY) || 0;
  const hiddenOfferSeedIds = motherV2OfferingHiddenSeedIds();
  const dimOfferSeedIds = motherV2OfferingDimSeedIds();
  const isHiddenOfferSeedId = (rawId) => hiddenOfferSeedIds.has(String(rawId || "").trim());
  const isDimOfferSeedId = (rawId) => dimOfferSeedIds.has(String(rawId || "").trim());

  const dpr = getDpr();
  wctx.save();
  wctx.imageSmoothingEnabled = true;
  wctx.imageSmoothingQuality = dragPerfMode ? "medium" : "high";

  const drawOrder = Array.isArray(state.freeformZOrder) && state.freeformZOrder.length
    ? state.freeformZOrder
    : items.map((it) => it?.id).filter(Boolean);

  for (const imageId of drawOrder) {
    if (isHiddenOfferSeedId(imageId)) continue;
    const item = imageId ? state.imagesById.get(imageId) : null;
    const rect = imageId ? state.multiRects.get(imageId) : null;
    if (!rect) continue;
    const x = rect.x * ms + mox;
    const y = rect.y * ms + moy;
    const w = rect.w * ms;
    const h = rect.h * ms;
    const dimOfferSeed = isDimOfferSeedId(imageId);
    const effectToken = imageId ? effectTokenForImageId(imageId) : null;
    const rectTransform = readFreeformRectTransform(state.freeformRects.get(imageId) || null);
    const framePoints = transformedRectPolygonPoints({
      x,
      y,
      w,
      h,
      rotateDeg: rectTransform.rotateDeg,
      skewXDeg: rectTransform.skewXDeg,
    });
    if (effectToken) {
      // Token visuals are rendered by the Pixi effects runtime on a dedicated transparent layer.
    } else if (item?.img) {
      wctx.save();
      if (dimOfferSeed) wctx.globalAlpha = 0.62;
      drawImageRectWithTransform(wctx, item.img, {
        x,
        y,
        w,
        h,
        rotateDeg: rectTransform.rotateDeg,
        skewXDeg: rectTransform.skewXDeg,
      });
      if (dimOfferSeed) {
        wctx.globalAlpha = 1;
        wctx.fillStyle = "rgba(6, 10, 14, 0.26)";
        if (drawPolygonPath(wctx, framePoints)) wctx.fill();
      }
      wctx.restore();
    } else {
      const g = wctx.createLinearGradient(x, y, x, y + h);
      g.addColorStop(0, "rgba(18, 26, 37, 0.90)");
      g.addColorStop(1, "rgba(6, 8, 12, 0.96)");
      wctx.fillStyle = g;
      if (drawPolygonPath(wctx, framePoints)) wctx.fill();
      if (dimOfferSeed) {
        wctx.fillStyle = "rgba(6, 10, 14, 0.26)";
        if (drawPolygonPath(wctx, framePoints)) wctx.fill();
      }
      wctx.fillStyle = "rgba(230, 237, 243, 0.65)";
      wctx.font = `${Math.max(11, Math.round(12 * dpr))}px IBM Plex Mono`;
      wctx.fillText("LOADINGâ€¦", x + Math.round(12 * dpr), y + Math.round(22 * dpr));
    }

    if (!effectToken) {
      // Tile frame.
      wctx.save();
      const motherGenerated = isMotherGeneratedImageItem(item);
      wctx.lineWidth = Math.max(1, Math.round(1.5 * dpr));
      wctx.strokeStyle = motherGenerated ? "rgba(82, 255, 148, 0.90)" : "rgba(54, 76, 106, 0.58)";
      wctx.shadowColor = motherGenerated ? "rgba(82, 255, 148, 0.26)" : "rgba(0, 0, 0, 0.6)";
      wctx.shadowBlur = Math.round(10 * dpr);
      if (drawPolygonPath(wctx, framePoints)) wctx.stroke();
      wctx.restore();
    }
  }
  wctx.restore();

  const selectedIds = getSelectedIds().filter((id) => id && !isImageEffectTokenized(id) && !isHiddenOfferSeedId(id));
  const multiSelectMode = selectedIds.length > 1;
  const activeRect = state.activeId && !isImageEffectTokenized(state.activeId) && !isHiddenOfferSeedId(state.activeId)
    ? state.multiRects.get(state.activeId)
    : null;
  const activeItem = state.activeId && !isImageEffectTokenized(state.activeId) && !isHiddenOfferSeedId(state.activeId)
    ? state.imagesById.get(state.activeId) || null
    : null;

  if (multiSelectMode && selectedIds.length) {
    // Multi-select highlight: keep all selected borders identical (no "active" special casing).
    octx.save();
    octx.lineJoin = "round";
    octx.shadowBlur = 0;
    octx.strokeStyle = "rgba(255, 212, 0, 0.96)";
    octx.lineWidth = Math.max(1, Math.round(3.0 * dpr));
    for (const imageId of selectedIds) {
      const rect = state.multiRects.get(imageId) || null;
      if (!rect) continue;
      const x = rect.x * ms + mox;
      const y = rect.y * ms + moy;
      const w = rect.w * ms;
      const h = rect.h * ms;
      const rectTransform = readFreeformRectTransform(state.freeformRects.get(imageId) || null);
      const points = transformedRectPolygonPoints({
        x: x - 3,
        y: y - 3,
        w: w + 6,
        h: h + 6,
        rotateDeg: rectTransform.rotateDeg,
        skewXDeg: rectTransform.skewXDeg,
      });
      if (drawPolygonPath(octx, points)) octx.stroke();
    }
    octx.restore();
  } else {
    // Multi-select highlights (non-active).
    const multiSelected = getSelectedIds().filter(
      (id) => id && id !== state.activeId && !isImageEffectTokenized(id) && !isHiddenOfferSeedId(id)
    );
    if (multiSelected.length) {
      octx.save();
      octx.lineJoin = "round";
      octx.shadowBlur = 0;
      octx.strokeStyle = "rgba(255, 212, 0, 0.62)";
      octx.lineWidth = Math.max(1, Math.round(2.2 * dpr));
      for (const imageId of multiSelected) {
        const rect = state.multiRects.get(imageId) || null;
        if (!rect) continue;
        const x = rect.x * ms + mox;
        const y = rect.y * ms + moy;
        const w = rect.w * ms;
        const h = rect.h * ms;
        const rectTransform = readFreeformRectTransform(state.freeformRects.get(imageId) || null);
        const points = transformedRectPolygonPoints({
          x: x - 2,
          y: y - 2,
          w: w + 4,
          h: h + 4,
          rotateDeg: rectTransform.rotateDeg,
          skewXDeg: rectTransform.skewXDeg,
        });
        if (drawPolygonPath(octx, points)) octx.stroke();
      }
      octx.restore();
    }

    // Active highlight (single selection).
    if (activeRect) {
      octx.save();
      octx.lineJoin = "round";
      const activeMother = isMotherGeneratedImageItem(activeItem);
      const outerStroke = activeMother ? "rgba(82, 255, 148, 0.20)" : "rgba(255, 212, 0, 0.14)";
      const mainStroke = activeMother ? "rgba(82, 255, 148, 0.94)" : "rgba(255, 212, 0, 0.96)";
      const mainShadow = activeMother ? "rgba(82, 255, 148, 0.28)" : "rgba(255, 212, 0, 0.26)";
      const innerStroke = activeMother ? "rgba(208, 255, 226, 0.60)" : "rgba(255, 247, 210, 0.58)";
      const handleStroke = activeMother ? "rgba(82, 255, 148, 0.92)" : "rgba(255, 212, 0, 0.92)";

      const ax = activeRect.x * ms + mox;
      const ay = activeRect.y * ms + moy;
      const aw = activeRect.w * ms;
      const ah = activeRect.h * ms;
      const activeTransform = readFreeformRectTransform(state.freeformRects.get(state.activeId) || null);
      const activeBorderPoints = transformedRectPolygonPoints({
        x: ax,
        y: ay,
        w: aw,
        h: ah,
        rotateDeg: activeTransform.rotateDeg,
        skewXDeg: activeTransform.skewXDeg,
      });

      const activeBorderPerfMode = dragPerfMode && String(state.pointer?.imageId || "") === String(state.activeId || "");
      const outerLineWidth = activeBorderPerfMode ? Math.max(1, Math.round(6 * dpr)) : Math.max(1, Math.round(10 * dpr));
      const outerShadowBlur = activeBorderPerfMode ? Math.round(20 * dpr) : Math.round(44 * dpr);
      const mainShadowBlur = activeBorderPerfMode ? Math.round(14 * dpr) : Math.round(28 * dpr);

      // Outer glow stroke (wide + soft).
      octx.strokeStyle = outerStroke;
      octx.lineWidth = outerLineWidth;
      octx.shadowColor = mainShadow;
      octx.shadowBlur = outerShadowBlur;
      if (drawPolygonPath(octx, activeBorderPoints)) octx.stroke();

      // Main border stroke.
      octx.strokeStyle = mainStroke;
      octx.lineWidth = Math.max(1, Math.round(3.4 * dpr));
      octx.shadowColor = mainShadow;
      octx.shadowBlur = mainShadowBlur;
      if (drawPolygonPath(octx, activeBorderPoints)) octx.stroke();

      // Inner crisp stroke for definition.
      octx.shadowBlur = 0;
      octx.strokeStyle = innerStroke;
      octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
      if (drawPolygonPath(octx, activeBorderPoints)) octx.stroke();
      octx.restore();

      // Freeform resize handles (corner drag). Render only for the active image to keep the canvas clean.
      const showHandles = state.tool === "pan" || intentModeActive();
      if (showHandles) {
        const hs = Math.max(8, Math.round(8 * dpr));
        const r = Math.round(hs / 2);
        const corners = Array.isArray(activeBorderPoints) && activeBorderPoints.length === 4
          ? [
              { x: Number(activeBorderPoints[0].x) || ax, y: Number(activeBorderPoints[0].y) || ay, cursor: "nw" },
              { x: Number(activeBorderPoints[1].x) || (ax + aw), y: Number(activeBorderPoints[1].y) || ay, cursor: "ne" },
              { x: Number(activeBorderPoints[3].x) || ax, y: Number(activeBorderPoints[3].y) || (ay + ah), cursor: "sw" },
              { x: Number(activeBorderPoints[2].x) || (ax + aw), y: Number(activeBorderPoints[2].y) || (ay + ah), cursor: "se" },
            ]
          : [
              { x: ax, y: ay, cursor: "nw" },
              { x: ax + aw, y: ay, cursor: "ne" },
              { x: ax, y: ay + ah, cursor: "sw" },
              { x: ax + aw, y: ay + ah, cursor: "se" },
            ];
        octx.save();
        octx.shadowColor = "rgba(0, 0, 0, 0.55)";
        octx.shadowBlur = Math.round(8 * dpr);
        for (const c of corners) {
          octx.fillStyle = "rgba(8, 10, 14, 0.78)";
          octx.strokeStyle = handleStroke;
          octx.lineWidth = Math.max(1, Math.round(1.25 * dpr));
          _drawRoundedRect(octx, Math.round(c.x - r), Math.round(c.y - r), hs, hs, Math.max(2, Math.round(2 * dpr)));
          octx.fill();
          octx.stroke();
        }
        octx.restore();
        renderActiveImageTransformControls(octx, {
          anchorRect: { x: ax, y: ay, w: aw, h: ah },
          anchorPoints: activeBorderPoints,
          dpr,
          accent: handleStroke,
          targetId: state.activeId,
        });
      }
    }
  }

  if (multiSelectMode && activeRect) {
    // Keep handles for the active image even when multiple images are selected.
    const ax = activeRect.x * ms + mox;
    const ay = activeRect.y * ms + moy;
    const aw = activeRect.w * ms;
    const ah = activeRect.h * ms;
    const activeTransform = readFreeformRectTransform(state.freeformRects.get(state.activeId) || null);
    const activeBorderPoints = transformedRectPolygonPoints({
      x: ax,
      y: ay,
      w: aw,
      h: ah,
      rotateDeg: activeTransform.rotateDeg,
      skewXDeg: activeTransform.skewXDeg,
    });
    const activeMother = isMotherGeneratedImageItem(activeItem);
    const handleStroke = activeMother ? "rgba(82, 255, 148, 0.92)" : "rgba(255, 212, 0, 0.92)";
    const showHandles = state.tool === "pan" || intentModeActive();
    if (showHandles) {
      const hs = Math.max(8, Math.round(8 * dpr));
      const r = Math.round(hs / 2);
      const corners = Array.isArray(activeBorderPoints) && activeBorderPoints.length === 4
        ? [
            { x: Number(activeBorderPoints[0].x) || ax, y: Number(activeBorderPoints[0].y) || ay, cursor: "nw" },
            { x: Number(activeBorderPoints[1].x) || (ax + aw), y: Number(activeBorderPoints[1].y) || ay, cursor: "ne" },
            { x: Number(activeBorderPoints[3].x) || ax, y: Number(activeBorderPoints[3].y) || (ay + ah), cursor: "sw" },
            { x: Number(activeBorderPoints[2].x) || (ax + aw), y: Number(activeBorderPoints[2].y) || (ay + ah), cursor: "se" },
          ]
        : [
            { x: ax, y: ay, cursor: "nw" },
            { x: ax + aw, y: ay, cursor: "ne" },
            { x: ax, y: ay + ah, cursor: "sw" },
            { x: ax + aw, y: ay + ah, cursor: "se" },
          ];
      octx.save();
      octx.shadowColor = "rgba(0, 0, 0, 0.55)";
      octx.shadowBlur = Math.round(8 * dpr);
      for (const c of corners) {
        octx.fillStyle = "rgba(8, 10, 14, 0.78)";
        octx.strokeStyle = handleStroke;
        octx.lineWidth = Math.max(1, Math.round(1.25 * dpr));
        _drawRoundedRect(octx, Math.round(c.x - r), Math.round(c.y - r), hs, hs, Math.max(2, Math.round(2 * dpr)));
        octx.fill();
        octx.stroke();
      }
      octx.restore();
      renderActiveImageTransformControls(octx, {
        anchorRect: { x: ax, y: ay, w: aw, h: ah },
        anchorPoints: activeBorderPoints,
        dpr,
        accent: handleStroke,
        targetId: state.activeId,
      });
    }
  }

  if (activeRect && activeItem && isMotherGeneratedImageItem(activeItem)) {
    const ax = activeRect.x * ms + mox;
    const ay = activeRect.y * ms + moy;
    const aw = activeRect.w * ms;
    const ah = activeRect.h * ms;
    const activeId = String(activeItem.id || "").trim();
    motherRenderDetailsBadgeAndPopover(octx, {
      anchorRect: { x: ax, y: ay, w: aw, h: ah },
      dpr,
      open: Boolean(activeId && state.motherResultDetailsOpenId === activeId),
      details: motherV2ImageRunDetails(activeItem),
      toggleKind: "mother_result_details_toggle",
      panelKind: "mother_result_details_panel",
      targetId: activeId,
    });
  }

  renderMotherRoleGlyphs(octx, { ms, mox, moy });

  // Triplet insights overlays (Extract the Rule / Odd One Out).
  const oddId = state.tripletOddOneOutId;
  if (oddId && !isHiddenOfferSeedId(oddId)) {
    const rect = state.multiRects.get(oddId) || null;
    if (rect) {
      const x = rect.x * ms + mox;
      const y = rect.y * ms + moy;
      const w = rect.w * ms;
      const h = rect.h * ms;
      const rectTransform = readFreeformRectTransform(state.freeformRects.get(oddId) || null);
      const oddOutlinePoints = transformedRectPolygonPoints({
        x: x - 3,
        y: y - 3,
        w: w + 6,
        h: h + 6,
        rotateDeg: rectTransform.rotateDeg,
        skewXDeg: rectTransform.skewXDeg,
      });
      octx.save();
      octx.lineWidth = Math.max(1, Math.round(2.5 * dpr));
      octx.setLineDash([Math.round(10 * dpr), Math.round(8 * dpr)]);
      octx.strokeStyle = "rgba(255, 72, 72, 0.86)";
      octx.shadowColor = "rgba(255, 72, 72, 0.18)";
      octx.shadowBlur = Math.round(18 * dpr);
      if (drawPolygonPath(octx, oddOutlinePoints)) octx.stroke();
      octx.setLineDash([]);
      octx.restore();
    }
  }

  if (state.tripletRuleAnnotations && state.tripletRuleAnnotations.size) {
    octx.save();
    octx.lineWidth = Math.max(1, Math.round(2 * dpr));
    octx.font = `${Math.max(10, Math.round(11 * dpr))}px IBM Plex Mono`;
    const dotR = Math.max(3, Math.round(5 * dpr));
    for (const item of items) {
      if (!item?.id) continue;
      if (isHiddenOfferSeedId(item.id)) continue;
      const rect = state.multiRects.get(item.id) || null;
      if (!rect) continue;
      const points = state.tripletRuleAnnotations.get(item.id) || [];
      for (const pt of points.slice(0, 6)) {
        const xRaw = Number(pt?.x);
        const yRaw = Number(pt?.y);
        if (!Number.isFinite(xRaw) || !Number.isFinite(yRaw)) continue;
        const x = clamp(xRaw, 0, 1);
        const y = clamp(yRaw, 0, 1);
        const cx = rect.x + mox + rect.w * x;
        const cy = rect.y + moy + rect.h * y;
        octx.save();
        octx.shadowColor = "rgba(0, 221, 255, 0.20)";
        octx.shadowBlur = Math.round(14 * dpr);
        octx.beginPath();
        octx.arc(cx, cy, dotR, 0, Math.PI * 2);
        octx.fillStyle = "rgba(0, 221, 255, 0.14)";
        octx.strokeStyle = "rgba(0, 221, 255, 0.92)";
        octx.fill();
        octx.stroke();

        const label = pt?.label ? clampText(pt.label, 28) : "";
        if (label) {
          const padX = Math.round(7 * dpr);
          const padY = Math.round(5 * dpr);
          const textW = octx.measureText(label).width;
          const boxW = Math.round(textW + padX * 2);
          const boxH = Math.round(20 * dpr);
          const boxX = Math.round(cx + 10 * dpr);
          const boxY = Math.round(cy - boxH / 2);
          octx.fillStyle = "rgba(8, 10, 14, 0.78)";
          octx.fillRect(boxX, boxY, boxW, boxH);
          octx.strokeStyle = "rgba(0, 221, 255, 0.34)";
          octx.strokeRect(boxX, boxY, boxW, boxH);
          octx.fillStyle = "rgba(0, 221, 255, 0.92)";
          octx.fillText(label, boxX + padX, boxY + boxH - padY);
        }
        octx.restore();
      }
    }
    octx.restore();
  }
}

function motherV2RoleImageIds(roleKey) {
  return motherV2RoleIds(roleKey).filter((id) => state.imagesById.has(id));
}

function motherV2ReceiptFallbackRunId(receiptPath = "") {
  const path = String(receiptPath || "").trim();
  if (!path) return "";
  const match = path.match(/receipt[^/]*-([a-z0-9_-]+)\.json$/i);
  return match ? String(match[1] || "").trim() : "";
}

function motherV2FormatCostDeltaUsd(costUsd = null) {
  const value = Number(costUsd);
  if (!Number.isFinite(value)) return "n/a";
  const abs = Math.abs(value);
  const precision = abs < 1 ? 3 : 2;
  return `+$${value.toFixed(precision)}`;
}

function motherV2ProposalRunDetails(draft = null) {
  const idle = state.motherIdle || null;
  const meta = draft?.receiptMeta && typeof draft.receiptMeta === "object" ? draft.receiptMeta : null;
  const providerKey = String(meta?.provider || "").trim() || providerFromModel(idle?.lastDispatchModel || settings.imageModel);
  const model = String(meta?.model || idle?.lastDispatchModel || "").trim() || "unknown";
  const runId = String(
    draft?.versionId ||
      idle?.generatedVersionId ||
      motherV2ReceiptFallbackRunId(draft?.receiptPath)
  ).trim();
  const costUsd = Number.isFinite(Number(meta?.cost_total_usd)) ? Number(meta.cost_total_usd) : null;
  return {
    provider: providerDisplay(providerKey || "unknown"),
    model,
    runId: runId || "n/a",
    costLabel: motherV2FormatCostDeltaUsd(costUsd),
  };
}

function motherV2ImageRunDetails(item = null) {
  if (!item) return null;
  if (item.receiptPath && !item.receiptMetaChecked && !item.receiptMetaLoading) {
    ensureReceiptMeta(item).catch(() => {});
  }
  const meta = item.receiptMeta && typeof item.receiptMeta === "object" ? item.receiptMeta : null;
  const providerKey = String(meta?.provider || "").trim() || providerFromModel(settings.imageModel);
  const model = String(meta?.model || "").trim() || "unknown";
  const runId = String(
    item.motherVersionId ||
      item.versionId ||
      motherV2ReceiptFallbackRunId(item.receiptPath)
  ).trim();
  const costUsd = Number.isFinite(Number(meta?.cost_total_usd)) ? Number(meta.cost_total_usd) : null;
  return {
    provider: providerDisplay(providerKey || "unknown"),
    model,
    runId: runId || "n/a",
    costLabel: motherV2FormatCostDeltaUsd(costUsd),
    creativeCues: meta?.creative_cues && typeof meta.creative_cues === "object" ? meta.creative_cues : null,
    promptApiPayload: meta?.prompt_api_payload && typeof meta.prompt_api_payload === "object" ? meta.prompt_api_payload : null,
  };
}

function motherV2PromptPayloadDetailRows(promptApiPayload = null, { maxChars = 3200, maxLines = 18, lineChars = 92 } = {}) {
  if (!promptApiPayload || typeof promptApiPayload !== "object") return [];
  let text = "";
  try {
    text = JSON.stringify(promptApiPayload, null, 2);
  } catch {
    text = "";
  }
  if (!text) return [];
  let clipped = false;
  if (text.length > maxChars) {
    text = `${text.slice(0, Math.max(0, maxChars - 3))}...`;
    clipped = true;
  }
  const rawRows = [];
  for (const line of String(text).split("\n")) {
    const safe = String(line || "");
    if (safe.length <= lineChars) {
      rawRows.push(safe);
      continue;
    }
    for (let i = 0; i < safe.length; i += lineChars) {
      rawRows.push(safe.slice(i, i + lineChars));
    }
  }
  const rows = [];
  rows.push("Prompt Payload JSON:");
  for (const row of rawRows) {
    rows.push(`  ${row}`);
    if (rows.length >= maxLines) {
      clipped = true;
      break;
    }
  }
  if (clipped) rows.push("  ... (truncated)");
  return rows;
}

function motherPushOverlayUiHit(hit = null) {
  if (!hit?.rect) return;
  if (!Array.isArray(state.motherOverlayUiHits)) state.motherOverlayUiHits = [];
  state.motherOverlayUiHits.push(hit);
}

function hitTestMotherOverlayUi(ptCanvas) {
  if (!ptCanvas) return null;
  const hits = Array.isArray(state.motherOverlayUiHits) ? state.motherOverlayUiHits : [];
  for (let i = hits.length - 1; i >= 0; i -= 1) {
    const hit = hits[i];
    const rect = hit?.rect;
    if (!rect) continue;
    const x0 = Number(rect.x) || 0;
    const y0 = Number(rect.y) || 0;
    const w = Number(rect.w) || 0;
    const h = Number(rect.h) || 0;
    if (ptCanvas.x >= x0 && ptCanvas.x <= x0 + w && ptCanvas.y >= y0 && ptCanvas.y <= y0 + h) return hit;
  }
  return null;
}

function activeImageTransformPushUiHit(hit = null) {
  if (!hit?.rect) return;
  if (!Array.isArray(state.activeImageTransformUiHits)) state.activeImageTransformUiHits = [];
  state.activeImageTransformUiHits.push(hit);
}

function hitTestActiveImageTransformUi(ptCanvas) {
  if (!ptCanvas) return null;
  const hits = Array.isArray(state.activeImageTransformUiHits) ? state.activeImageTransformUiHits : [];
  for (let i = hits.length - 1; i >= 0; i -= 1) {
    const hit = hits[i];
    const rect = hit?.rect;
    if (!rect) continue;
    const x0 = Number(rect.x) || 0;
    const y0 = Number(rect.y) || 0;
    const w = Number(rect.w) || 0;
    const h = Number(rect.h) || 0;
    if (ptCanvas.x >= x0 && ptCanvas.x <= x0 + w && ptCanvas.y >= y0 && ptCanvas.y <= y0 + h) return hit;
  }
  return null;
}

function ensureFreeformRectForImageId(rawId = "") {
  const id = String(rawId || "").trim();
  if (!id) return null;
  let rect = state.freeformRects.get(id) || null;
  if (rect) return rect;
  const wrap = els.canvasWrap;
  const canvasCssW = Number(wrap?.clientWidth) || 0;
  const canvasCssH = Number(wrap?.clientHeight) || 0;
  if (canvasCssW > 0 && canvasCssH > 0) {
    ensureFreeformLayoutRectsCss(state.images || [], canvasCssW, canvasCssH);
    rect = state.freeformRects.get(id) || null;
  }
  return rect;
}

function renderActiveImageTransformControls(
  octx,
  { anchorRect = null, anchorPoints = null, dpr = 1, accent = "rgba(255, 212, 0, 0.92)", targetId = "" } = {}
) {
  if (!octx || !anchorRect) return;
  const id = String(targetId || state.activeId || "").trim();
  if (!id) return;

  const canvasW = Number(octx.canvas?.width) || 0;
  const canvasH = Number(octx.canvas?.height) || 0;
  if (canvasW <= 0 || canvasH <= 0) return;
  const ax = Number(anchorRect.x) || 0;
  const ay = Number(anchorRect.y) || 0;
  const aw = Math.max(1, Number(anchorRect.w) || 1);
  const ah = Math.max(1, Number(anchorRect.h) || 1);
  const fallbackPoints = [
    { x: ax, y: ay },
    { x: ax + aw, y: ay },
    { x: ax + aw, y: ay + ah },
    { x: ax, y: ay + ah },
  ];
  const points = Array.isArray(anchorPoints) && anchorPoints.length === 4
    ? anchorPoints.map((pt, idx) => ({
        x: Number(pt?.x),
        y: Number(pt?.y),
        fallback: fallbackPoints[idx],
      })).map((pt) => ({
        x: Number.isFinite(pt.x) ? pt.x : pt.fallback.x,
        y: Number.isFinite(pt.y) ? pt.y : pt.fallback.y,
      }))
    : fallbackPoints;
  const p0 = points[0] || fallbackPoints[0];
  const p1 = points[1] || fallbackPoints[1];
  const p2 = points[2] || fallbackPoints[2];
  const p3 = points[3] || fallbackPoints[3];
  const midpoint = (a, b) => ({
    x: ((Number(a?.x) || 0) + (Number(b?.x) || 0)) * 0.5,
    y: ((Number(a?.y) || 0) + (Number(b?.y) || 0)) * 0.5,
  });
  const center = {
    x: (Number(p0.x) + Number(p1.x) + Number(p2.x) + Number(p3.x)) / 4,
    y: (Number(p0.y) + Number(p1.y) + Number(p2.y) + Number(p3.y)) / 4,
  };
  const topMid = midpoint(p0, p1);
  const leftMid = midpoint(p3, p0);
  const rightMid = midpoint(p1, p2);
  const outwardDir = (origin, target, fallback) => {
    const dx = (Number(target?.x) || 0) - (Number(origin?.x) || 0);
    const dy = (Number(target?.y) || 0) - (Number(origin?.y) || 0);
    const len = Math.hypot(dx, dy);
    if (len > 0.0001) return { x: dx / len, y: dy / len };
    return fallback;
  };
  const topDir = outwardDir(center, topMid, { x: 0, y: -1 });
  const leftDir = outwardDir(center, leftMid, { x: -1, y: 0 });
  const rightDir = outwardDir(center, rightMid, { x: 1, y: 0 });
  const pivotX = Number(center.x) || (ax + aw * 0.5);
  const pivotY = Number(center.y) || (ay + ah * 0.5);
  const pad = Math.max(8, Math.round(9 * dpr));
  const rotateRadius = Math.max(6, Math.round(6 * dpr));
  const skewRadius = Math.max(5, Math.round(5 * dpr));
  const stemLen = Math.max(10, Math.round(12 * dpr));
  const sideOffset = Math.max(12, Math.round(14 * dpr));

  const currentTransform = readFreeformRectTransform(state.freeformRects.get(id) || null);
  const rotateActive = Math.abs(Number(currentTransform.rotateDeg) || 0) > 0.001;
  const skewActive = Math.abs(Number(currentTransform.skewXDeg) || 0) > 0.001;
  let rotateCx = topMid.x + topDir.x * (stemLen + rotateRadius);
  let rotateCy = topMid.y + topDir.y * (stemLen + rotateRadius);
  rotateCx = clamp(rotateCx, pad + rotateRadius, Math.max(pad + rotateRadius, canvasW - pad - rotateRadius));
  rotateCy = clamp(rotateCy, pad + rotateRadius, Math.max(pad + rotateRadius, canvasH - pad - rotateRadius));
  const rotateVecX = rotateCx - topMid.x;
  const rotateVecY = rotateCy - topMid.y;
  const rotateVecLen = Math.hypot(rotateVecX, rotateVecY);
  const rotateDir = rotateVecLen > 0.0001
    ? { x: rotateVecX / rotateVecLen, y: rotateVecY / rotateVecLen }
    : topDir;
  const stemEndX = rotateCx - rotateDir.x * rotateRadius;
  const stemEndY = rotateCy - rotateDir.y * rotateRadius;
  const leftCx = clamp(
    leftMid.x + leftDir.x * sideOffset,
    pad + skewRadius,
    Math.max(pad + skewRadius, canvasW - pad - skewRadius)
  );
  const leftCy = clamp(
    leftMid.y + leftDir.y * sideOffset,
    pad + skewRadius,
    Math.max(pad + skewRadius, canvasH - pad - skewRadius)
  );
  const rightCx = clamp(
    rightMid.x + rightDir.x * sideOffset,
    pad + skewRadius,
    Math.max(pad + skewRadius, canvasW - pad - skewRadius)
  );
  const rightCy = clamp(
    rightMid.y + rightDir.y * sideOffset,
    pad + skewRadius,
    Math.max(pad + skewRadius, canvasH - pad - skewRadius)
  );
  const anchorWidth = Math.max(1, Math.hypot((Number(rightMid.x) || 0) - (Number(leftMid.x) || 0), (Number(rightMid.y) || 0) - (Number(leftMid.y) || 0)));

  octx.save();
  octx.shadowColor = "rgba(0, 0, 0, 0.56)";
  octx.shadowBlur = Math.round(7 * dpr);

  // Photoshop-like rotate handle: stem + circular knob outside the transformed top edge.
  octx.beginPath();
  octx.moveTo(Math.round(topMid.x), Math.round(topMid.y));
  octx.lineTo(Math.round(stemEndX), Math.round(stemEndY));
  octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
  octx.strokeStyle = accent;
  octx.stroke();

  octx.beginPath();
  octx.arc(Math.round(rotateCx), Math.round(rotateCy), rotateRadius, 0, Math.PI * 2);
  octx.fillStyle = rotateActive ? "rgba(14, 30, 22, 0.9)" : "rgba(8, 10, 14, 0.84)";
  octx.fill();
  octx.lineWidth = Math.max(1, Math.round(1.3 * dpr));
  octx.strokeStyle = rotateActive ? "rgba(122, 220, 172, 0.9)" : accent;
  octx.stroke();

  // Photoshop-like skew side handles (left/right edge drag).
  const drawSkewHandle = (cx, cy, edge) => {
    octx.save();
    octx.translate(Math.round(cx), Math.round(cy));
    octx.rotate(Math.PI / 4);
    const size = skewRadius * 1.18;
    octx.beginPath();
    octx.rect(-size, -size, size * 2, size * 2);
    octx.fillStyle = skewActive ? "rgba(14, 30, 22, 0.9)" : "rgba(8, 10, 14, 0.84)";
    octx.fill();
    octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
    octx.strokeStyle = skewActive ? "rgba(122, 220, 172, 0.9)" : accent;
    octx.stroke();
    octx.restore();
    const hitPad = Math.max(4, Math.round(4 * dpr));
    activeImageTransformPushUiHit({
      kind: "skew",
      edge,
      cursor: "ew-resize",
      targetId: id,
      pivotX,
      pivotY,
      anchorWidth,
      rect: {
        x: Math.round(cx - skewRadius - hitPad),
        y: Math.round(cy - skewRadius - hitPad),
        w: Math.round((skewRadius + hitPad) * 2),
        h: Math.round((skewRadius + hitPad) * 2),
      },
    });
  };

  drawSkewHandle(leftCx, leftCy, "left");
  drawSkewHandle(rightCx, rightCy, "right");

  const rotateHitPad = Math.max(3, Math.round(4 * dpr));
  activeImageTransformPushUiHit({
    kind: "rotate",
    cursor: "grabbing",
    targetId: id,
    pivotX,
    pivotY,
    anchorWidth,
    rect: {
      x: Math.round(rotateCx - rotateRadius - rotateHitPad),
      y: Math.round(rotateCy - rotateRadius - rotateHitPad),
      w: Math.round((rotateRadius + rotateHitPad) * 2),
      h: Math.round((rotateRadius + rotateHitPad) * 2),
    },
  });
  octx.restore();
}

function beginActiveImageTransformDrag(event, { ptCanvas = null, ptCss = null, hit = null } = {}) {
  const transformKind = String(hit?.kind || "").trim().toLowerCase();
  if (transformKind !== "rotate" && transformKind !== "skew") return false;
  const id = String(hit?.targetId || state.activeId || "").trim();
  if (!id || !ptCanvas || !ptCss) return false;
  const rectCss = ensureFreeformRectForImageId(id);
  if (!rectCss) return false;
  const pivotX = Number(hit?.pivotX);
  const pivotY = Number(hit?.pivotY);
  if (!Number.isFinite(pivotX) || !Number.isFinite(pivotY)) return false;
  const transform = readFreeformRectTransform(rectCss);
  const startAngle = Math.atan2((Number(ptCanvas.y) || 0) - pivotY, (Number(ptCanvas.x) || 0) - pivotX);

  els.overlayCanvas.setPointerCapture(event.pointerId);
  state.pointer.active = true;
  state.pointer.kind = transformKind === "rotate" ? POINTER_KINDS.FREEFORM_ROTATE : POINTER_KINDS.FREEFORM_SKEW;
  state.pointer.imageId = id;
  state.pointer.corner = null;
  state.pointer.startX = Number(ptCanvas.x) || 0;
  state.pointer.startY = Number(ptCanvas.y) || 0;
  state.pointer.lastX = Number(ptCanvas.x) || 0;
  state.pointer.lastY = Number(ptCanvas.y) || 0;
  state.pointer.startCssX = Number(ptCss.x) || 0;
  state.pointer.startCssY = Number(ptCss.y) || 0;
  state.pointer.startRectCss = { ...rectCss };
  state.pointer.transformHandleEdge =
    transformKind === "skew" ? (String(hit?.edge || "").trim().toLowerCase() === "left" ? "left" : "right") : null;
  state.pointer.transformPivotX = pivotX;
  state.pointer.transformPivotY = pivotY;
  state.pointer.transformAnchorWidthPx = Math.max(1, Number(hit?.anchorWidth) || 1);
  state.pointer.transformStartAngleRad = Number.isFinite(startAngle) ? startAngle : 0;
  state.pointer.transformStartRotateDeg = Number(transform.rotateDeg) || 0;
  state.pointer.transformStartSkewXDeg = Number(transform.skewXDeg) || 0;
  state.pointer.wheelOnTap = false;
  state.pointer.moved = false;
  state.pointer.semanticInteractionEmitted = false;
  return true;
}

function motherCloseOverlayDetails() {
  if (state.motherIdle) state.motherIdle.offerDetailsOpen = false;
  state.motherResultDetailsOpenId = null;
}

function motherToggleOverlayDetails(hit = null) {
  const kind = String(hit?.kind || "").trim();
  const targetId = String(hit?.targetId || "").trim();
  if (kind === "mother_offer_details_toggle") {
    if (state.motherIdle) state.motherIdle.offerDetailsOpen = !Boolean(state.motherIdle.offerDetailsOpen);
    state.motherResultDetailsOpenId = null;
    return true;
  }
  if (kind === "mother_result_details_toggle") {
    state.motherResultDetailsOpenId = state.motherResultDetailsOpenId === targetId ? null : targetId;
    if (state.motherIdle) state.motherIdle.offerDetailsOpen = false;
    return true;
  }
  if (kind === "mother_offer_details_panel" || kind === "mother_result_details_panel") {
    return true;
  }
  return false;
}

function motherRenderDetailsBadgeAndPopover(
  octx,
  {
    anchorRect = null,
    dpr = 1,
    open = false,
    details = null,
    toggleKind = "mother_offer_details_toggle",
    panelKind = "mother_offer_details_panel",
    targetId = null,
  } = {}
) {
  if (!octx || !anchorRect) return;
  const canvasW = Number(octx.canvas?.width) || 0;
  const canvasH = Number(octx.canvas?.height) || 0;
  if (canvasW <= 0 || canvasH <= 0) return;

  const pad = Math.max(6, Math.round(7 * dpr));
  const badgeSize = Math.max(16, Math.round(18 * dpr));
  const badgeX = clamp(
    Math.round((Number(anchorRect.x) || 0) + (Number(anchorRect.w) || 0) - badgeSize - pad),
    pad,
    Math.max(pad, canvasW - badgeSize - pad)
  );
  const badgeY = clamp(
    Math.round((Number(anchorRect.y) || 0) + pad),
    pad,
    Math.max(pad, canvasH - badgeSize - pad)
  );

  octx.save();
  octx.shadowColor = "rgba(0, 0, 0, 0.5)";
  octx.shadowBlur = Math.round(10 * dpr);
  _drawRoundedRect(octx, badgeX, badgeY, badgeSize, badgeSize, Math.max(4, Math.round(5 * dpr)));
  octx.fillStyle = open ? "rgba(10, 32, 24, 0.92)" : "rgba(8, 10, 14, 0.86)";
  octx.fill();
  octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
  octx.strokeStyle = open ? "rgba(122, 238, 178, 0.88)" : "rgba(160, 188, 220, 0.66)";
  octx.stroke();
  octx.fillStyle = open ? "rgba(170, 255, 214, 0.98)" : "rgba(226, 235, 246, 0.96)";
  octx.font = `${Math.max(9, Math.round(11 * dpr))}px IBM Plex Mono`;
  octx.textAlign = "center";
  octx.textBaseline = "middle";
  octx.fillText("i", badgeX + badgeSize * 0.5, badgeY + badgeSize * 0.55);
  octx.restore();
  motherPushOverlayUiHit({
    kind: toggleKind,
    targetId: targetId || null,
    rect: { x: badgeX, y: badgeY, w: badgeSize, h: badgeSize },
  });

  if (!open) return;
  const detail = details && typeof details === "object" ? details : null;
  const rows = [
    `Provider: ${detail?.provider || "Unknown"}`,
    `Model: ${clampText(detail?.model || "unknown", 28)}`,
    `Run ID: ${clampText(detail?.runId || "n/a", 28)}`,
    `Cost: ${detail?.costLabel || "n/a"}`,
  ];
  const cues = detail?.creativeCues && typeof detail.creativeCues === "object" ? detail.creativeCues : null;
  if (cues?.shot_type) rows.push(`Shot: ${clampText(cues.shot_type, 52)}`);
  if (cues?.alternate_shot_type) rows.push(`Alt Shot: ${clampText(cues.alternate_shot_type, 52)}`);
  if (cues?.lighting_profile) rows.push(`Lighting: ${clampText(cues.lighting_profile, 52)}`);
  if (cues?.alternate_lighting_profile) rows.push(`Alt Light: ${clampText(cues.alternate_lighting_profile, 52)}`);
  if (cues?.lens_guidance) rows.push(`Lens: ${clampText(cues.lens_guidance, 52)}`);
  if (cues?.alternate_lens_guidance) rows.push(`Alt Lens: ${clampText(cues.alternate_lens_guidance, 52)}`);
  const promptPayloadRows = motherV2PromptPayloadDetailRows(detail?.promptApiPayload || null);
  if (promptPayloadRows.length) rows.push(...promptPayloadRows);

  octx.save();
  const fontPx = Math.max(8, Math.round(9 * dpr));
  const lineH = Math.max(11, Math.round(12 * dpr));
  const rowGap = Math.max(2, Math.round(3 * dpr));
  const panelPadX = Math.max(7, Math.round(8 * dpr));
  const panelPadY = Math.max(6, Math.round(7 * dpr));
  octx.font = `${fontPx}px IBM Plex Mono`;
  let maxLineW = 0;
  for (const row of rows) {
    maxLineW = Math.max(maxLineW, Math.ceil(octx.measureText(String(row)).width));
  }
  const panelW = Math.max(Math.round(150 * dpr), maxLineW + panelPadX * 2);
  const panelH = panelPadY * 2 + rows.length * lineH + Math.max(0, rows.length - 1) * rowGap;
  let panelX = Math.round(badgeX + badgeSize - panelW);
  panelX = clamp(panelX, pad, Math.max(pad, canvasW - panelW - pad));
  let panelY = Math.round(badgeY - panelH - Math.max(5, Math.round(6 * dpr)));
  if (panelY < pad) {
    panelY = Math.round(badgeY + badgeSize + Math.max(5, Math.round(6 * dpr)));
  }
  panelY = clamp(panelY, pad, Math.max(pad, canvasH - panelH - pad));

  octx.shadowColor = "rgba(0, 0, 0, 0.56)";
  octx.shadowBlur = Math.round(14 * dpr);
  _drawRoundedRect(octx, panelX, panelY, panelW, panelH, Math.max(6, Math.round(7 * dpr)));
  octx.fillStyle = "rgba(6, 10, 14, 0.94)";
  octx.fill();
  octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
  octx.strokeStyle = "rgba(122, 238, 178, 0.54)";
  octx.stroke();

  octx.fillStyle = "rgba(214, 255, 232, 0.96)";
  octx.textAlign = "left";
  octx.textBaseline = "top";
  let textY = panelY + panelPadY;
  for (const row of rows) {
    octx.fillText(String(row), panelX + panelPadX, textY);
    textY += lineH + rowGap;
  }
  octx.restore();
  motherPushOverlayUiHit({
    kind: panelKind,
    targetId: targetId || null,
    rect: { x: panelX, y: panelY, w: panelW, h: panelH },
  });
}

function hitTestMotherRoleGlyph(ptCanvas) {
  const idle = state.motherIdle;
  if (!idle || !ptCanvas) return null;
  const hits = Array.isArray(idle.roleGlyphHits) ? idle.roleGlyphHits : [];
  for (let i = hits.length - 1; i >= 0; i -= 1) {
    const hit = hits[i];
    const rect = hit?.rect;
    if (!rect) continue;
    const x0 = Number(rect.x) || 0;
    const y0 = Number(rect.y) || 0;
    const w = Number(rect.w) || 0;
    const h = Number(rect.h) || 0;
    if (ptCanvas.x >= x0 && ptCanvas.x <= x0 + w && ptCanvas.y >= y0 && ptCanvas.y <= y0 + h) return hit;
  }
  return null;
}

function renderMotherDraftKeyboardHints(octx, rectPx, { dpr = 1, details = null } = {}) {
  if (!octx || !rectPx || isReelSizeLocked()) return;
  const hints = [
    { key: "V", label: "DEPLOY" },
    { key: "M", label: "DISMISS" },
    { key: "R", label: "REROLL" },
  ];
  if (!hints.length) return;
  const margin = Math.max(8, Math.round(10 * dpr));
  const gap = Math.max(4, Math.round(6 * dpr));
  const chipPadX = Math.max(4, Math.round(6 * dpr));
  const chipPadY = Math.max(2, Math.round(4 * dpr));
  const keyW = Math.max(11, Math.round(13 * dpr));
  const keyH = Math.max(11, Math.round(13 * dpr));
  const keyGap = Math.max(4, Math.round(5 * dpr));
  const chipH = Math.max(keyH + chipPadY * 2, Math.round(20 * dpr));
  const fontPx = Math.max(8, Math.round(9 * dpr));
  const corner = Math.max(4, Math.round(6 * dpr));
  const canvasW = Number(octx.canvas?.width) || 0;
  const canvasH = Number(octx.canvas?.height) || 0;
  if (canvasW <= 0 || canvasH <= 0) return;

  octx.save();
  octx.font = `${fontPx}px IBM Plex Mono`;
  octx.textBaseline = "middle";
  octx.textAlign = "left";

  const chips = hints.map((hint) => {
    const label = String(hint.label || "").trim().toUpperCase();
    const key = String(hint.key || "").trim().toUpperCase();
    const labelW = Math.ceil(octx.measureText(label).width);
    const width = chipPadX + keyW + keyGap + labelW + chipPadX;
    return { key, label, width };
  });
  const totalW = chips.reduce((sum, chip) => sum + chip.width, 0) + Math.max(0, chips.length - 1) * gap;

  let x = Math.round((Number(rectPx.x) || 0) + ((Number(rectPx.w) || 0) - totalW) / 2);
  x = clamp(x, margin, Math.max(margin, canvasW - totalW - margin));
  let y = Math.round((Number(rectPx.y) || 0) - chipH - margin);
  if (y < margin) {
    y = Math.round((Number(rectPx.y) || 0) + (Number(rectPx.h) || 0) + margin);
  }
  y = clamp(y, margin, Math.max(margin, canvasH - chipH - margin));

  octx.shadowColor = "rgba(0, 0, 0, 0.52)";
  octx.shadowBlur = Math.round(10 * dpr);
  let cx = x;
  for (const chip of chips) {
    _drawRoundedRect(octx, cx, y, chip.width, chipH, corner);
    octx.fillStyle = "rgba(8, 10, 14, 0.84)";
    octx.fill();
    octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
    octx.strokeStyle = "rgba(82, 255, 148, 0.46)";
    octx.stroke();

    const keyX = cx + chipPadX;
    const keyY = y + Math.round((chipH - keyH) / 2);
    _drawRoundedRect(octx, keyX, keyY, keyW, keyH, Math.max(3, Math.round(3 * dpr)));
    octx.fillStyle = "rgba(18, 26, 37, 0.96)";
    octx.fill();
    octx.strokeStyle = "rgba(160, 188, 220, 0.62)";
    octx.stroke();

    octx.fillStyle = "rgba(230, 237, 243, 0.96)";
    octx.textAlign = "center";
    octx.fillText(chip.key, keyX + keyW * 0.5, y + chipH * 0.54);

    octx.textAlign = "left";
    octx.fillStyle = "rgba(210, 255, 228, 0.94)";
    octx.fillText(chip.label, keyX + keyW + keyGap, y + chipH * 0.54);

    cx += chip.width + gap;
  }
  octx.restore();

  const idle = state.motherIdle || null;
  const detailsOpen = Boolean(idle?.offerDetailsOpen);
  motherRenderDetailsBadgeAndPopover(octx, {
    anchorRect: { x, y, w: totalW, h: chipH },
    dpr,
    open: detailsOpen,
    details,
    toggleKind: "mother_offer_details_toggle",
    panelKind: "mother_offer_details_panel",
    targetId: "proposal",
  });
}

function renderMotherRoleGlyphs(octx, { ms = 1, mox = 0, moy = 0 } = {}) {
  const idle = state.motherIdle;
  if (!idle) return;
  const phase = idle.phase || motherIdleInitialState();
  if (phase !== MOTHER_IDLE_STATES.OFFERING) {
    idle.offerDetailsOpen = false;
  }
  if (!(phase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING || phase === MOTHER_IDLE_STATES.OFFERING)) {
    idle.roleGlyphHits = [];
    return;
  }
  if (state.canvasMode !== "multi") {
    idle.roleGlyphHits = [];
    return;
  }
  const showOfferPreview = phase === MOTHER_IDLE_STATES.OFFERING;
  const advancedVisible = motherV2IsAdvancedVisible();
  const hintsVisible = motherV2HintsVisible();
  if (!advancedVisible && !hintsVisible) {
    if (!showOfferPreview) {
      idle.roleGlyphHits = [];
      return;
    }
  }
  const showRoleGlyphs = advancedVisible || hintsVisible;
  const dpr = getDpr();
  const hintLevel = Number(idle.hintLevel) || 1;
  const glyphSize = advancedVisible
    ? Math.max(24, Math.round(54 * dpr))
    : Math.max(10, Math.round((hintLevel > 1 ? 15 : 11) * dpr));
  const gap = Math.max(2, Math.round(4 * dpr));
  const yInset = Math.max(4, Math.round(8 * dpr));
  const hits = [];
  const roleAnchors = new Map();
  const hiddenOfferSeedIds = motherV2OfferingHiddenSeedIds();

  for (const item of state.images || []) {
    const imageId = String(item?.id || "").trim();
    if (!imageId) continue;
    if (hiddenOfferSeedIds.has(imageId)) continue;
    const rect = state.multiRects.get(imageId) || null;
    if (!rect) continue;
    const roles = showRoleGlyphs ? MOTHER_V2_ROLE_KEYS.filter((key) => motherV2RoleImageIds(key).includes(imageId)) : [];
    if (!roles.length) continue;
    const rx = rect.x * ms + mox;
    const ry = rect.y * ms + moy;
    const rw = rect.w * ms;
    const rh = rect.h * ms;
    const totalW = roles.length * glyphSize + (roles.length - 1) * gap;
    const x0 = Math.round(rx + (rw - totalW) / 2);
    const y = Math.round(ry + rh - glyphSize - yInset);
    for (let i = 0; i < roles.length; i += 1) {
      const role = roles[i];
      const x = x0 + i * (glyphSize + gap);
      const drag = idle.roleGlyphDrag;
      const hot = Boolean(drag && String(drag.role || "") === role && String(drag.imageId || "") === imageId);
      octx.save();
      octx.globalAlpha = advancedVisible ? (hot ? 1 : 0.9) : hintLevel > 1 ? 0.76 : 0.52;
      octx.fillStyle = advancedVisible ? "rgba(8, 10, 14, 0.88)" : "rgba(8, 10, 14, 0.66)";
      octx.strokeStyle = advancedVisible ? "rgba(230, 237, 243, 0.92)" : "rgba(230, 237, 243, 0.58)";
      octx.lineWidth = Math.max(1, Math.round((advancedVisible ? 1.3 : 1.1) * dpr));
      octx.beginPath();
      octx.roundRect(Math.round(x), Math.round(y), glyphSize, glyphSize, Math.round((advancedVisible ? 8 : 6) * dpr));
      octx.fill();
      octx.stroke();
      octx.fillStyle = "rgba(230, 237, 243, 0.96)";
      octx.font = advancedVisible
        ? `${Math.max(8, Math.round(11 * dpr))}px IBM Plex Mono`
        : `${Math.max(9, Math.round(10 * dpr))}px IBM Plex Mono`;
      octx.textAlign = "center";
      octx.textBaseline = "middle";
      octx.fillText(
        advancedVisible ? (MOTHER_V2_ROLE_LABEL[role] || role.toUpperCase()) : (MOTHER_V2_ROLE_GLYPH[role] || "â€¢"),
        x + glyphSize * 0.5,
        y + glyphSize * 0.53
      );
      octx.restore();
      if (advancedVisible) {
        hits.push({
          kind: "mother_role_glyph",
          role,
          imageId,
          rect: { x, y, w: glyphSize, h: glyphSize },
        });
      }
      if (!roleAnchors.has(role)) {
        roleAnchors.set(role, {
          x: x + glyphSize * 0.5,
          y: y + glyphSize * 0.5,
        });
      }
    }
  }

  if (showRoleGlyphs && !advancedVisible) {
    const subjectAnchor = roleAnchors.get("subject");
    const modelAnchor = roleAnchors.get("model");
    if (subjectAnchor && modelAnchor) {
      octx.save();
      octx.globalAlpha = hintLevel > 1 ? 0.42 : 0.28;
      octx.strokeStyle = "rgba(230, 237, 243, 0.7)";
      octx.lineWidth = Math.max(1, Math.round(1.1 * dpr));
      octx.setLineDash([Math.max(2, Math.round(4 * dpr)), Math.max(2, Math.round(4 * dpr))]);
      octx.beginPath();
      octx.moveTo(subjectAnchor.x, subjectAnchor.y);
      octx.lineTo(modelAnchor.x, modelAnchor.y);
      octx.stroke();
      octx.setLineDash([]);
      octx.restore();
    }
  }

  // Offer-stage ghost preview (staged only; no mutation).
  if (phase === MOTHER_IDLE_STATES.OFFERING) {
    const draft = motherV2CurrentDraft();
    const policy = String(idle.intent?.placement_policy || "adjacent");
    const targets = Array.isArray(idle.intent?.target_ids) ? idle.intent.target_ids : [];
    const targetId = targets.length ? String(targets[0] || "") : state.activeId ? String(state.activeId) : null;
    const rectCss = motherV2OfferPreviewRectCss({ policy, targetId, draftIndex: 0 });
    if (rectCss) {
      const px = {
        x: (Number(rectCss.x) || 0) * dpr * ms + mox,
        y: (Number(rectCss.y) || 0) * dpr * ms + moy,
        w: (Number(rectCss.w) || 1) * dpr * ms,
        h: (Number(rectCss.h) || 1) * dpr * ms,
      };
      octx.save();
      octx.globalAlpha = 0.36;
      if (draft?.img) {
        octx.imageSmoothingEnabled = true;
        octx.imageSmoothingQuality = "high";
        octx.drawImage(draft.img, Math.round(px.x), Math.round(px.y), Math.round(px.w), Math.round(px.h));
      } else {
        octx.fillStyle = "rgba(82, 255, 148, 0.18)";
        octx.fillRect(Math.round(px.x), Math.round(px.y), Math.round(px.w), Math.round(px.h));
      }
      octx.globalAlpha = 0.92;
      octx.strokeStyle = "rgba(82, 255, 148, 0.88)";
      octx.lineWidth = Math.max(1, Math.round(2 * dpr));
      octx.strokeRect(Math.round(px.x), Math.round(px.y), Math.round(px.w), Math.round(px.h));
      octx.globalAlpha = 0.42;
      octx.setLineDash([Math.max(2, Math.round(6 * dpr)), Math.max(2, Math.round(4 * dpr))]);
      octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
      octx.strokeStyle = "rgba(182, 255, 216, 0.84)";
      octx.strokeRect(Math.round(px.x - 3), Math.round(px.y - 3), Math.round(px.w + 6), Math.round(px.h + 6));
      octx.setLineDash([]);
      octx.restore();
      renderMotherDraftKeyboardHints(octx, px, {
        dpr,
        details: motherV2ProposalRunDetails(draft),
      });
    }
  }

  idle.roleGlyphHits = showRoleGlyphs && advancedVisible ? hits : [];
}

function hitTestIntentUi(ptCanvas) {
  const intent = state.intent;
  if (!intent || !ptCanvas) return null;
  const hits = Array.isArray(intent.uiHits) ? intent.uiHits : [];
  for (let i = hits.length - 1; i >= 0; i -= 1) {
    const hit = hits[i];
    const rect = hit?.rect;
    if (!rect) continue;
    const x0 = Number(rect.x) || 0;
    const y0 = Number(rect.y) || 0;
    const w = Number(rect.w) || 0;
    const h = Number(rect.h) || 0;
    if (ptCanvas.x >= x0 && ptCanvas.x <= x0 + w && ptCanvas.y >= y0 && ptCanvas.y <= y0 + h) return hit;
  }
  return null;
}

function hitTestAmbientIntentNudge(ptCanvas) {
  if (!INTENT_AMBIENT_ICON_PLACEMENT_ENABLED) return null;
  if (state.mother?.running) return null;
  const ambient = state.intentAmbient;
  if (!ambient || !ptCanvas) return null;
  const hits = Array.isArray(ambient.uiHits) ? ambient.uiHits : [];
  for (let i = hits.length - 1; i >= 0; i -= 1) {
    const hit = hits[i];
    const rect = hit?.rect;
    if (!rect) continue;
    const x0 = Number(rect.x) || 0;
    const y0 = Number(rect.y) || 0;
    const w = Number(rect.w) || 0;
    const h = Number(rect.h) || 0;
    if (ptCanvas.x >= x0 && ptCanvas.x <= x0 + w && ptCanvas.y >= y0 && ptCanvas.y <= y0 + h) return hit;
  }
  return null;
}

function activateAmbientIntentNudge(hit) {
  if (!INTENT_AMBIENT_ICON_PLACEMENT_ENABLED) return false;
  const ambient = state.intentAmbient;
  if (!ambient || !hit) return false;

  const branchId = String(hit.branchId || "").trim();
  const assetKey = String(hit.assetKey || "").trim();
  const anchorIds = Array.isArray(hit.anchorImageIds)
    ? hit.anchorImageIds.map((id) => String(id || "").trim()).filter(Boolean)
    : [];

  let selectedId = "";
  for (const id of anchorIds) {
    if (state.imagesById.has(id)) {
      selectedId = id;
      break;
    }
  }
  if (!selectedId && state.activeId && state.imagesById.has(state.activeId)) {
    selectedId = String(state.activeId);
  }

  if (selectedId) {
    selectCanvasImage(selectedId, { toggle: false }).catch(() => {});
  }
  rememberAmbientTouchedImageIds(selectedId ? [selectedId] : anchorIds);
  scheduleAmbientIntentInference({
    immediate: true,
    reason: "composition_change",
    imageIds: selectedId ? [selectedId] : anchorIds,
  });

  const usecase = assetKey || _intentUseCaseKeyFromBranchId(branchId);
  const title = _intentUseCaseTitle(usecase);
  if (title) {
    showToast(`Mother nudge: ${title}`, "tip", 1300);
  }
  return true;
}

function _sevenSegSegmentsForDigit(ch) {
  const d = String(ch || "");
  const map = {
    "0": ["A", "B", "C", "D", "E", "F"],
    "1": ["B", "C"],
    "2": ["A", "B", "G", "E", "D"],
    "3": ["A", "B", "G", "C", "D"],
    "4": ["F", "G", "B", "C"],
    "5": ["A", "F", "G", "C", "D"],
    "6": ["A", "F", "G", "E", "C", "D"],
    "7": ["A", "B", "C"],
    "8": ["A", "B", "C", "D", "E", "F", "G"],
    "9": ["A", "B", "C", "D", "F", "G"],
  };
  return map[d] || [];
}

function _drawRoundedRect(ctx, x, y, w, h, r) {
  const rr = Math.max(0, Math.min(Number(r) || 0, Math.min(w, h) / 2));
  ctx.beginPath();
  ctx.moveTo(x + rr, y);
  ctx.arcTo(x + w, y, x + w, y + h, rr);
  ctx.arcTo(x + w, y + h, x, y + h, rr);
  ctx.arcTo(x, y + h, x, y, rr);
  ctx.arcTo(x, y, x + w, y, rr);
  ctx.closePath();
}

function _drawIntentBumperPlate(ctx, rect, { active = false, loading = false, alpha = 1 } = {}) {
  if (!ctx || !rect) return;
  const x = Math.round(Number(rect.x) || 0);
  const y = Math.round(Number(rect.y) || 0);
  const w = Math.round(Number(rect.w) || 0);
  const h = Math.round(Number(rect.h) || 0);
  if (w <= 2 || h <= 2) return;

  const dpr = getDpr();
  const a = clamp(Number(alpha) || 1, 0.05, 1);
  const cut = Math.max(10, Math.round(14 * dpr));
  const inset = Math.max(1, Math.round(1.2 * dpr));
  const edge = Math.max(1, Math.round(1.4 * dpr));

  const path = () => {
    const c = Math.max(0, Math.min(cut, Math.floor(Math.min(w, h) / 2) - 1));
    ctx.beginPath();
    ctx.moveTo(x + c, y);
    ctx.lineTo(x + w - c, y);
    ctx.lineTo(x + w, y + c);
    ctx.lineTo(x + w, y + h - c);
    ctx.lineTo(x + w - c, y + h);
    ctx.lineTo(x + c, y + h);
    ctx.lineTo(x, y + h - c);
    ctx.lineTo(x, y + c);
    ctx.closePath();
  };

  ctx.save();
  ctx.globalAlpha = a;
  ctx.shadowColor = "rgba(0, 0, 0, 0.78)";
  ctx.shadowBlur = Math.round(18 * dpr);
  ctx.shadowOffsetY = Math.round(6 * dpr);

  // Base fill.
  path();
  ctx.fillStyle = "rgba(8, 10, 14, 0.90)";
  ctx.fill();

  // Clip for texture/gradients.
  ctx.save();
  path();
  ctx.clip();

  // Metal-ish vertical gradient.
  const grad = ctx.createLinearGradient(0, y, 0, y + h);
  grad.addColorStop(0, "rgba(255, 255, 255, 0.08)");
  grad.addColorStop(0.35, "rgba(255, 255, 255, 0.02)");
  grad.addColorStop(1, "rgba(0, 0, 0, 0.62)");
  ctx.fillStyle = grad;
  ctx.fillRect(x, y, w, h);

  // Soft cyan bloom on the left (matches bumpers/HUD vibe without reading as a "screen").
  const rg = ctx.createRadialGradient(x + w * 0.22, y + h * 0.12, 0, x + w * 0.22, y + h * 0.12, Math.max(w, h) * 0.75);
  rg.addColorStop(0, "rgba(100, 210, 255, 0.10)");
  rg.addColorStop(0.6, "rgba(0, 221, 255, 0.03)");
  rg.addColorStop(1, "rgba(0, 0, 0, 0)");
  ctx.fillStyle = rg;
  ctx.fillRect(x, y, w, h);

  // Subtle scanline texture.
  ctx.save();
  ctx.globalAlpha = 0.11;
  ctx.fillStyle = "rgba(255, 255, 255, 0.14)";
  const step = Math.max(7, Math.round(9 * dpr));
  const lineH = Math.max(1, Math.round(1 * dpr));
  for (let yy = y + Math.round(step / 2); yy < y + h; yy += step) {
    ctx.fillRect(x, yy, w, lineH);
  }
  ctx.restore();

  ctx.restore(); // end clip

  // Outer edge.
  path();
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  ctx.lineWidth = edge;
  ctx.strokeStyle = "rgba(54, 76, 106, 0.62)";
  ctx.stroke();

  // Inset bevel highlight.
  ctx.save();
  ctx.globalAlpha = a * 0.9;
  const ix = x + inset;
  const iy = y + inset;
  const iw = Math.max(1, w - inset * 2);
  const ih = Math.max(1, h - inset * 2);
  const icut = Math.max(8, Math.round(cut * 0.7));
  const c = Math.max(0, Math.min(icut, Math.floor(Math.min(iw, ih) / 2) - 1));
  ctx.beginPath();
  ctx.moveTo(ix + c, iy);
  ctx.lineTo(ix + iw - c, iy);
  ctx.lineTo(ix + iw, iy + c);
  ctx.lineTo(ix + iw, iy + ih - c);
  ctx.lineTo(ix + iw - c, iy + ih);
  ctx.lineTo(ix + c, iy + ih);
  ctx.lineTo(ix, iy + ih - c);
  ctx.lineTo(ix, iy + c);
  ctx.closePath();
  ctx.lineWidth = Math.max(1, Math.round(1.1 * dpr));
  ctx.strokeStyle = "rgba(255, 255, 255, 0.10)";
  ctx.stroke();
  ctx.restore();

  // Accent sliver (quiet, hardware-ish).
  const accent = loading
    ? "rgba(0, 221, 255, 0.30)"
    : active
      ? "rgba(82, 255, 148, 0.28)"
      : "rgba(54, 76, 106, 0.22)";
  ctx.save();
  ctx.globalAlpha = a;
  ctx.strokeStyle = accent;
  ctx.lineWidth = Math.max(1, Math.round(2.2 * dpr));
  ctx.lineCap = "round";
  const sl = Math.max(18, Math.round(Math.min(w, 260) * 0.22));
  ctx.beginPath();
  ctx.moveTo(x + cut + Math.round(12 * dpr), y + Math.round(6 * dpr));
  ctx.lineTo(x + cut + Math.round(12 * dpr) + sl, y + Math.round(6 * dpr));
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x + w - cut - Math.round(12 * dpr) - sl, y + Math.round(6 * dpr));
  ctx.lineTo(x + w - cut - Math.round(12 * dpr), y + Math.round(6 * dpr));
  ctx.stroke();
  ctx.restore();

  ctx.restore();
}

const LED_5X7 = {
  " ": [0, 0, 0, 0, 0, 0, 0],
  "-": [0, 0, 0, 0b11111, 0, 0, 0],
  "_": [0, 0, 0, 0, 0, 0, 0b11111],
  "/": [0b00001, 0b00010, 0b00100, 0b01000, 0b10000, 0, 0],
  ":": [0, 0b00100, 0b00100, 0, 0b00100, 0b00100, 0],
  "?": [0b01110, 0b10001, 0b00010, 0b00100, 0b00100, 0, 0b00100],
  "0": [0b01110, 0b10001, 0b10011, 0b10101, 0b11001, 0b10001, 0b01110],
  "1": [0b00100, 0b01100, 0b00100, 0b00100, 0b00100, 0b00100, 0b01110],
  "2": [0b01110, 0b10001, 0b00001, 0b00010, 0b00100, 0b01000, 0b11111],
  "3": [0b11110, 0b00001, 0b00001, 0b01110, 0b00001, 0b00001, 0b11110],
  "4": [0b00010, 0b00110, 0b01010, 0b10010, 0b11111, 0b00010, 0b00010],
  "5": [0b11111, 0b10000, 0b10000, 0b11110, 0b00001, 0b00001, 0b11110],
  "6": [0b00111, 0b01000, 0b10000, 0b11110, 0b10001, 0b10001, 0b01110],
  "7": [0b11111, 0b00001, 0b00010, 0b00100, 0b01000, 0b01000, 0b01000],
  "8": [0b01110, 0b10001, 0b10001, 0b01110, 0b10001, 0b10001, 0b01110],
  "9": [0b01110, 0b10001, 0b10001, 0b01111, 0b00001, 0b00010, 0b11100],
  A: [0b01110, 0b10001, 0b10001, 0b11111, 0b10001, 0b10001, 0b10001],
  B: [0b11110, 0b10001, 0b10001, 0b11110, 0b10001, 0b10001, 0b11110],
  C: [0b01111, 0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b01111],
  D: [0b11110, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b11110],
  E: [0b11111, 0b10000, 0b10000, 0b11110, 0b10000, 0b10000, 0b11111],
  F: [0b11111, 0b10000, 0b10000, 0b11110, 0b10000, 0b10000, 0b10000],
  G: [0b01111, 0b10000, 0b10000, 0b10111, 0b10001, 0b10001, 0b01111],
  H: [0b10001, 0b10001, 0b10001, 0b11111, 0b10001, 0b10001, 0b10001],
  I: [0b11111, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b11111],
  J: [0b00111, 0b00010, 0b00010, 0b00010, 0b00010, 0b10010, 0b01100],
  K: [0b10001, 0b10010, 0b10100, 0b11000, 0b10100, 0b10010, 0b10001],
  L: [0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b10000, 0b11111],
  M: [0b10001, 0b11011, 0b10101, 0b10101, 0b10001, 0b10001, 0b10001],
  N: [0b10001, 0b11001, 0b10101, 0b10011, 0b10001, 0b10001, 0b10001],
  O: [0b01110, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01110],
  P: [0b11110, 0b10001, 0b10001, 0b11110, 0b10000, 0b10000, 0b10000],
  Q: [0b01110, 0b10001, 0b10001, 0b10001, 0b10101, 0b10010, 0b01101],
  R: [0b11110, 0b10001, 0b10001, 0b11110, 0b10100, 0b10010, 0b10001],
  S: [0b01111, 0b10000, 0b10000, 0b01110, 0b00001, 0b00001, 0b11110],
  T: [0b11111, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100, 0b00100],
  U: [0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01110],
  V: [0b10001, 0b10001, 0b10001, 0b10001, 0b10001, 0b01010, 0b00100],
  W: [0b10001, 0b10001, 0b10001, 0b10101, 0b10101, 0b10101, 0b01010],
  X: [0b10001, 0b10001, 0b01010, 0b00100, 0b01010, 0b10001, 0b10001],
  Y: [0b10001, 0b10001, 0b01010, 0b00100, 0b00100, 0b00100, 0b00100],
  Z: [0b11111, 0b00001, 0b00010, 0b00100, 0b01000, 0b10000, 0b11111],
};

function _led5x7Rows(ch) {
  const key = String(ch || "").toUpperCase();
  return LED_5X7[key] || LED_5X7["?"] || LED_5X7[" "];
}

function _led5x7TextDims(text, dot, gap, charGap) {
  const d = Math.max(1, Math.round(Number(dot) || 0));
  const g = Math.max(0, Math.round(Number(gap) || 0));
  const cg = Math.max(0, Math.round(Number(charGap) || 0));
  const chars = String(text || "");
  const h = 7 * d + 6 * g;
  const cw = 5 * d + 4 * g;
  if (!chars) return { w: 0, h };
  const w = chars.length * cw + Math.max(0, chars.length - 1) * cg;
  return { w, h };
}

function _drawLed5x7Text(
  ctx,
  x,
  y,
  text,
  { dot = 10, gap = 2, charGap = 6, on = "rgba(0, 245, 160, 0.92)", off = "rgba(0, 245, 160, 0.07)", glow = null, alpha = 1 } = {}
) {
  if (!ctx) return { w: 0, h: 0 };
  const d = Math.max(1, Math.round(Number(dot) || 0));
  const g = Math.max(0, Math.round(Number(gap) || 0));
  const cg = Math.max(0, Math.round(Number(charGap) || 0));
  const a = clamp(Number(alpha) || 1, 0.05, 1);
  const chars = String(text || "").toUpperCase();
  const step = d + g;
  const r = Math.max(0, Math.round(d * 0.22));
  let cx = Math.round(Number(x) || 0);
  const cy = Math.round(Number(y) || 0);

  ctx.save();
  ctx.globalAlpha = a;

  // Optional dim "off" grid so it reads as an LED module.
  if (off) {
    ctx.save();
    ctx.shadowBlur = 0;
    ctx.fillStyle = off;
    for (const ch of chars) {
      const rows = _led5x7Rows(ch);
      for (let ry = 0; ry < 7; ry += 1) {
        for (let rx = 0; rx < 5; rx += 1) {
          const px = cx + rx * step;
          const py = cy + ry * step;
          _drawRoundedRect(ctx, px, py, d, d, r);
          ctx.fill();
        }
      }
      cx += 5 * step - g + cg;
    }
    ctx.restore();
  }

  // Lit segments with glow, then a crisp pass.
  const drawLit = ({ withGlow }) => {
    ctx.save();
    ctx.fillStyle = on;
    if (withGlow && glow) {
      ctx.shadowColor = glow;
      ctx.shadowBlur = Math.round(d * 1.15);
    } else {
      ctx.shadowBlur = 0;
    }
    let tx = Math.round(Number(x) || 0);
    for (const ch of chars) {
      const rows = _led5x7Rows(ch);
      for (let ry = 0; ry < 7; ry += 1) {
        const mask = Number(rows[ry]) || 0;
        for (let rx = 0; rx < 5; rx += 1) {
          const bit = (mask >> (4 - rx)) & 1;
          if (!bit) continue;
          const px = tx + rx * step;
          const py = cy + ry * step;
          _drawRoundedRect(ctx, px, py, d, d, r);
          ctx.fill();
        }
      }
      tx += 5 * step - g + cg;
    }
    ctx.restore();
  };

  drawLit({ withGlow: true });
  drawLit({ withGlow: false });

  ctx.restore();
  return _led5x7TextDims(chars, d, g, cg);
}

function _drawSevenSegDigit(ctx, x, y, digitW, digitH, ch, { on, off } = {}) {
  const segs = _sevenSegSegmentsForDigit(ch);
  const seg = Math.max(2, Math.round(digitH * 0.13));
  const gap = Math.max(1, Math.round(seg * 0.55));
  const innerW = Math.max(1, digitW - seg);
  const halfH = Math.round(digitH / 2);

  const rects = {
    A: { x: x + gap, y: y, w: innerW - gap * 2, h: seg },
    D: { x: x + gap, y: y + digitH - seg, w: innerW - gap * 2, h: seg },
    G: { x: x + gap, y: y + halfH - Math.round(seg / 2), w: innerW - gap * 2, h: seg },
    F: { x: x, y: y + gap, w: seg, h: halfH - gap - Math.round(seg / 2) },
    E: { x: x, y: y + halfH + Math.round(seg / 2), w: seg, h: halfH - gap - Math.round(seg / 2) },
    B: { x: x + digitW - seg, y: y + gap, w: seg, h: halfH - gap - Math.round(seg / 2) },
    C: { x: x + digitW - seg, y: y + halfH + Math.round(seg / 2), w: seg, h: halfH - gap - Math.round(seg / 2) },
  };

  const drawSeg = (key, active) => {
    const r = rects[key];
    if (!r || r.w <= 0 || r.h <= 0) return;
    ctx.fillStyle = active ? on : off;
    _drawRoundedRect(ctx, Math.round(r.x), Math.round(r.y), Math.round(r.w), Math.round(r.h), Math.round(seg * 0.38));
    ctx.fill();
  };

  const onSet = new Set(segs);
  for (const key of ["A", "B", "C", "D", "E", "F", "G"]) {
    drawSeg(key, onSet.has(key));
  }
}

function _normalizeIntentKey(value) {
  return String(value || "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+/, "")
    .replace(/_+$/, "");
}

function _intentUseCaseKeyFromBranchId(branchId) {
  const key = _normalizeIntentKey(branchId);
  if (!key) return null;
  if (key === "primary") return null;
  return key;
}

function _intentUseCaseTitle(useCaseKey) {
  const key = _intentUseCaseKeyFromBranchId(useCaseKey);
  if (!key) return "";
  return key
    .toUpperCase()
    .replace(/[^A-Z0-9/]+/g, " ")
    .trim();
}

function _drawIntentYesNoIcon(ctx, kind, cx, cy, r, { alpha = 1 } = {}) {
  const k = String(kind || "").trim().toUpperCase();
  const isYes = k === "YES";
  const img = isYes ? intentUiIcons.tokenYes : intentUiIcons.tokenNo;
  if (img && img.complete && img.naturalWidth > 0) {
    const rr = Math.max(1, Number(r) || 0);
    const size = Math.max(1, Math.round(rr * 2));
    ctx.save();
    ctx.globalAlpha = clamp(Number(alpha) || 1, 0.05, 1);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, Math.round(cx - size / 2), Math.round(cy - size / 2), size, size);
    ctx.restore();
    return;
  }
  const fg = isYes ? "rgba(82, 255, 148, 0.92)" : "rgba(255, 95, 95, 0.92)";
  const stroke = isYes ? "rgba(82, 255, 148, 0.34)" : "rgba(255, 95, 95, 0.34)";
  ctx.save();
  ctx.globalAlpha = clamp(Number(alpha) || 1, 0.05, 1);
  ctx.fillStyle = "rgba(8, 10, 14, 0.82)";
  ctx.strokeStyle = stroke;
  ctx.lineWidth = Math.max(1, Math.round(r * 0.18));
  ctx.shadowColor = "rgba(0, 0, 0, 0.55)";
  ctx.shadowBlur = Math.round(r * 0.7);
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.strokeStyle = fg;
  ctx.lineWidth = Math.max(1, Math.round(r * 0.18));
  ctx.lineCap = "round";
  if (isYes) {
    ctx.beginPath();
    ctx.moveTo(cx - r * 0.45, cy + r * 0.05);
    ctx.lineTo(cx - r * 0.15, cy + r * 0.35);
    ctx.lineTo(cx + r * 0.55, cy - r * 0.35);
    ctx.stroke();
  } else {
    ctx.beginPath();
    ctx.moveTo(cx - r * 0.42, cy - r * 0.42);
    ctx.lineTo(cx + r * 0.42, cy + r * 0.42);
    ctx.moveTo(cx + r * 0.42, cy - r * 0.42);
    ctx.lineTo(cx - r * 0.42, cy + r * 0.42);
    ctx.stroke();
  }
  ctx.restore();
}

function _drawIntentUseCaseGlyph(ctx, useCaseKey, cx, cy, size, { alpha = 1 } = {}) {
  const key = String(useCaseKey || "").trim();
  if (!key) return;
  const img = intentUiIcons.usecases ? intentUiIcons.usecases[key] : null;
  if (img && img.complete && img.naturalWidth > 0) {
    const s = Math.max(8, Number(size) || 0);
    ctx.save();
    ctx.globalAlpha = clamp(Number(alpha) || 1, 0.05, 1);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, Math.round(cx - s / 2), Math.round(cy - s / 2), Math.round(s), Math.round(s));
    ctx.restore();
    return;
  }
  const s = Math.max(12, Number(size) || 0);
  const lw = Math.max(1, Math.round(s * 0.07));
  const fg = "rgba(230, 237, 243, 0.90)";
  const monogram = (() => {
    const normalized = _normalizeIntentKey(key);
    if (!normalized) return "?";
    const parts = normalized.split("_").filter(Boolean);
    if (!parts.length) return "?";
    if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
    return `${parts[0].slice(0, 1)}${parts[1].slice(0, 1)}`.toUpperCase();
  })();
  const x = cx - s / 2;
  const y = cy - s / 2;
  const radius = Math.max(2, Math.round(s * 0.2));
  const fontPx = Math.max(9, Math.round(s * 0.34));
  ctx.save();
  ctx.globalAlpha = clamp(Number(alpha) || 1, 0.05, 1);
  ctx.fillStyle = "rgba(8, 10, 14, 0.82)";
  ctx.strokeStyle = "rgba(82, 255, 148, 0.36)";
  ctx.lineWidth = lw;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  _drawRoundedRect(ctx, x, y, s, s, radius);
  ctx.fill();
  ctx.stroke();
  ctx.fillStyle = fg;
  ctx.font = `600 ${fontPx}px "SF Mono", "Menlo", "Monaco", ui-monospace, monospace`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(monogram, Math.round(cx), Math.round(cy + fontPx * 0.04));

  ctx.restore();
}

function _drawIntentLoadingDots(ctx, cx, cy, { dotR = 3, color = "rgba(82, 255, 148, 0.92)", t = 0 } = {}) {
  const r = Math.max(1, Number(dotR) || 0);
  const gap = Math.max(4, Math.round(r * 2.1));
  for (let i = 0; i < 3; i += 1) {
    const pulse = 0.25 + 0.75 * Math.abs(Math.sin(t + i * 0.85));
    ctx.save();
    ctx.globalAlpha = pulse;
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(cx + (i - 1) * gap, cy, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

function renderIntentOverlay(octx, canvasW, canvasH) {
  const intent = state.intent;
  if (!intent) return;

  if (!intentModeActive()) {
    intent.uiHits = [];
    return;
  }

  const dpr = getDpr();
  const now = Date.now();
  const hits = [];
  const margin = Math.round(18 * dpr);

  const loading = Boolean(intent.pending || intentInferenceTimer || intent.rtState === "connecting");

  let iconState = null;
  if (intent.iconState && typeof intent.iconState === "object") {
    iconState = ensureIntentFallbackIconState("render");
  } else if (intent.disabledReason || intent.rtState === "failed") {
    iconState = ensureIntentFallbackIconState("failed");
  }

  const suggestedBranchId = iconState ? pickSuggestedIntentBranchId(iconState) : null;
  if (suggestedBranchId && !intent.uiHideSuggestion) intent.focusBranchId = suggestedBranchId;
  const useCaseKey = _intentUseCaseKeyFromBranchId(suggestedBranchId);

  // Optional force-choice overlay (disabled by default).
  if (INTENT_FORCE_CHOICE_ENABLED && intent.forceChoice) {
    octx.save();
    octx.fillStyle = "rgba(0, 0, 0, 0.42)";
    octx.fillRect(0, 0, canvasW, canvasH);
    octx.restore();
  }

  // START button (top-right): locks current intent (same as YES).
  const canAccept = Boolean(iconState && suggestedBranchId && !loading && !intent.uiHideSuggestion);
  const startR = Math.max(14, Math.round(17 * dpr * INTENT_UI_START_ICON_SCALE));
  const startSize = Math.max(1, Math.round(startR * 2.15));
  const startCx = Math.round(canvasW - margin - startSize / 2);
  const startCy = Math.round(margin + startSize / 2);
  const startRect = { x: startCx - startSize / 2, y: startCy - startSize / 2, w: startSize, h: startSize };

  // Backplate circle (keeps the button legible over bright pixels).
  octx.save();
  octx.shadowColor = "rgba(0, 0, 0, 0.62)";
  octx.shadowBlur = Math.round(14 * dpr);
  octx.fillStyle = "rgba(8, 10, 14, 0.78)";
  octx.strokeStyle = canAccept ? "rgba(82, 255, 148, 0.44)" : "rgba(54, 76, 106, 0.38)";
  octx.lineWidth = Math.max(1, Math.round(1.4 * dpr));
  octx.beginPath();
  octx.arc(startCx, startCy, startR, 0, Math.PI * 2);
  octx.fill();
  octx.stroke();
  octx.restore();

  const startImg = intentUiIcons.startLock;
  if (startImg && startImg.complete && startImg.naturalWidth > 0) {
    octx.save();
    octx.globalAlpha = canAccept ? 1 : 0.45;
    octx.imageSmoothingEnabled = true;
    octx.imageSmoothingQuality = "high";
    octx.drawImage(startImg, Math.round(startRect.x), Math.round(startRect.y), Math.round(startRect.w), Math.round(startRect.h));
    octx.restore();
  } else {
    // Fallback: procedural play glyph.
    octx.save();
    octx.globalAlpha = canAccept ? 1 : 0.45;
    octx.fillStyle = canAccept ? "rgba(82, 255, 148, 0.92)" : "rgba(230, 237, 243, 0.45)";
    octx.beginPath();
    octx.moveTo(startCx - startR * 0.22, startCy - startR * 0.32);
    octx.lineTo(startCx - startR * 0.22, startCy + startR * 0.32);
    octx.lineTo(startCx + startR * 0.42, startCy);
    octx.closePath();
    octx.fill();
    octx.restore();
  }

  if (canAccept) hits.push({ kind: "intent_lock", id: "start", rect: startRect });

  // Bottom choice controls (no container strip): [NO] [SUGGESTION] [YES].
  const tokenR = Math.max(14, Math.round(18 * dpr * INTENT_UI_CHOICE_ICON_SCALE));
  const glyphSize = Math.max(30, Math.round(42 * dpr * INTENT_UI_CHOICE_ICON_SCALE));
  const gap = Math.round(22 * dpr * Math.min(2.2, Math.max(1, INTENT_UI_CHOICE_ICON_SCALE * 0.55)));

  const groupH = Math.max(tokenR * 2, glyphSize);
  const cy = Math.round(canvasH - margin - groupH / 2);

  const groupW = tokenR * 2 + gap + glyphSize + gap + tokenR * 2;
  const maxGroupW = Math.max(1, canvasW - margin * 2);
  const useVerticalLayout = groupW > maxGroupW;

  let noCx = 0;
  let yesCx = 0;
  let glyphCx = 0;
  let glyphCy = cy;
  let tokenCy = cy;
  if (!useVerticalLayout) {
    const groupX0 = Math.round((canvasW - groupW) / 2);
    noCx = groupX0 + tokenR;
    glyphCx = groupX0 + tokenR * 2 + gap + glyphSize / 2;
    yesCx = groupX0 + tokenR * 2 + gap + glyphSize + gap + tokenR;
  } else {
    // If the giant 3x row doesn't fit, stack the suggestion above the YES/NO pair.
    const vGap = Math.round(14 * dpr * Math.min(2.2, Math.max(1, INTENT_UI_CHOICE_ICON_SCALE * 0.45)));
    tokenCy = Math.round(canvasH - margin - tokenR);
    glyphCy = Math.round(tokenCy - tokenR - vGap - glyphSize / 2);
    glyphCx = Math.round(canvasW / 2);
    const pairGap = Math.round(18 * dpr * Math.min(2.2, Math.max(1, INTENT_UI_CHOICE_ICON_SCALE * 0.45)));
    noCx = Math.round(canvasW / 2 - tokenR - pairGap);
    yesCx = Math.round(canvasW / 2 + tokenR + pairGap);
  }

  const canReject = Boolean(iconState && suggestedBranchId && !loading);
  const noAlpha = canReject ? 1 : 0.45;
  const yesAlpha = canAccept ? 1 : 0.45;

  // Hardware-like bumper/strip behind the choice UI (complements the normal HUD/bumpers).
  const tokenX0 = Math.min(noCx - tokenR, yesCx - tokenR);
  const tokenX1 = Math.max(noCx + tokenR, yesCx + tokenR);
  const tokenY0 = tokenCy - tokenR;
  const tokenY1 = tokenCy + tokenR;
  let glyphX0 = tokenX0;
  let glyphX1 = tokenX1;
  let glyphY0 = tokenY0;
  let glyphY1 = tokenY1;
  if (useCaseKey || loading) {
    glyphX0 = glyphCx - glyphSize / 2;
    glyphX1 = glyphCx + glyphSize / 2;
    glyphY0 = glyphCy - glyphSize / 2;
    glyphY1 = glyphCy + glyphSize / 2;
  }
  const minX = Math.min(tokenX0, glyphX0);
  const maxX = Math.max(tokenX1, glyphX1);
  const minY = Math.min(tokenY0, glyphY0);
  const maxY = Math.max(tokenY1, glyphY1);
  const platePad = Math.round(18 * dpr);
  let plate = {
    x: Math.round(minX - platePad),
    y: Math.round(minY - platePad),
    w: Math.round((maxX - minX) + platePad * 2),
    h: Math.round((maxY - minY) + platePad * 2),
  };
  const maxPlateW = Math.max(1, Math.round(canvasW - margin * 2));
  if (plate.w > maxPlateW) {
    plate.w = maxPlateW;
    plate.x = margin;
  } else {
    plate.x = clamp(plate.x, margin, Math.round(canvasW - margin - plate.w));
  }

  // Title text inside the plate (big blocky LED matrix).
  // Do NOT show the literal word "INTENT" - show only the inferred intent/use-case when ready.
  const titleLines = [];
  const title1 = !loading && !intent.uiHideSuggestion && useCaseKey ? _intentUseCaseTitle(useCaseKey) : "";
  if (title1) titleLines.push(title1);
  const titlePadX = Math.round(24 * dpr);
  const titlePadY = Math.round(14 * dpr);
  const titleMaxW = Math.max(1, plate.w - titlePadX * 2);
  const longestTitle = titleLines.reduce((best, cur) => (String(cur).length > String(best).length ? String(cur) : String(best)), "");
  let ledDot = Math.max(6, Math.round(4.2 * dpr * Math.min(1.9, Math.max(1, INTENT_UI_CHOICE_ICON_SCALE * 0.55))));
  const minDot = Math.max(3, Math.round(2.6 * dpr));
  let ledGap = Math.max(1, Math.round(ledDot * 0.22));
  let ledCharGap = Math.max(2, Math.round(ledDot * 0.9));
  while (ledDot > minDot) {
    const dims = _led5x7TextDims(longestTitle, ledDot, ledGap, ledCharGap);
    if (dims.w <= titleMaxW) break;
    ledDot -= 1;
    ledGap = Math.max(1, Math.round(ledDot * 0.22));
    ledCharGap = Math.max(2, Math.round(ledDot * 0.9));
  }
  const ledLineDims = _led5x7TextDims("A", ledDot, ledGap, ledCharGap);
  const ledLineH = Math.max(1, ledLineDims.h);
  const ledLineGap = Math.max(1, Math.round(ledDot * 0.9));
  const titleBlockH = titleLines.length > 0 ? titleLines.length * ledLineH + Math.max(0, titleLines.length - 1) * ledLineGap : 0;
  const titleGapBelow = Math.round(6 * dpr);
  const titleReserve = titleBlockH ? titlePadY + titleBlockH + titleGapBelow : 0;
  if (titleReserve) {
    plate.y = Math.round(plate.y - titleReserve);
    plate.h = Math.round(plate.h + titleReserve);
  }

  const maxPlateH = Math.max(1, Math.round(canvasH - margin * 2));
  if (plate.h > maxPlateH) {
    plate.h = maxPlateH;
    plate.y = margin;
  } else {
    plate.y = clamp(plate.y, margin, Math.round(canvasH - margin - plate.h));
  }
  _drawIntentBumperPlate(octx, plate, {
    active: canAccept,
    loading,
    alpha: iconState ? 1 : 0.82,
  });

  if (titleBlockH) {
    const glow = loading
      ? "rgba(0, 221, 255, 0.70)"
      : canAccept
        ? "rgba(0, 245, 160, 0.62)"
        : "rgba(100, 210, 255, 0.48)";
    const off = "rgba(0, 221, 255, 0.06)";
    const on = loading ? "rgba(0, 221, 255, 0.92)" : "rgba(0, 245, 160, 0.92)";
    let ty = Math.round(plate.y + titlePadY);
    for (let i = 0; i < titleLines.length; i += 1) {
      const line = String(titleLines[i] || "").trim().toUpperCase();
      if (!line) continue;
      const dims = _led5x7TextDims(line, ledDot, ledGap, ledCharGap);
      const tx = Math.round(plate.x + (plate.w - dims.w) / 2);
      _drawLed5x7Text(octx, tx, ty, line, {
        dot: ledDot,
        gap: ledGap,
        charGap: ledCharGap,
        on,
        off,
        glow,
        alpha: 1,
      });
      ty += ledLineH + ledLineGap;
    }
  }

  _drawIntentYesNoIcon(octx, "NO", noCx, tokenCy, tokenR, { alpha: noAlpha });
  _drawIntentYesNoIcon(octx, "YES", yesCx, tokenCy, tokenR, { alpha: yesAlpha });

  const glyphAlpha = intent.uiHideSuggestion ? 0 : loading ? 0.35 : 1;
  if (useCaseKey && glyphAlpha > 0.01) {
    _drawIntentUseCaseGlyph(octx, useCaseKey, glyphCx, glyphCy, glyphSize, { alpha: glyphAlpha });
  }
  if (loading) {
    _drawIntentLoadingDots(octx, glyphCx, glyphCy, { dotR: Math.max(2, Math.round(3.2 * dpr)), t: now / 240 });
  }

  if (canReject) hits.push({ kind: "intent_token", id: `${suggestedBranchId}::NO_TOKEN`, rect: { x: noCx - tokenR, y: tokenCy - tokenR, w: tokenR * 2, h: tokenR * 2 } });
  if (canAccept) hits.push({ kind: "intent_token", id: `${suggestedBranchId}::YES_TOKEN`, rect: { x: yesCx - tokenR, y: tokenCy - tokenR, w: tokenR * 2, h: tokenR * 2 } });

  intent.uiHits = hits;
}

function _ambientWorldRectToCanvasRect(rectWorld) {
  if (!rectWorld) return null;
  const x = Number(rectWorld.x);
  const y = Number(rectWorld.y);
  const w = Number(rectWorld.w);
  const h = Number(rectWorld.h);
  if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(w) || !Number.isFinite(h)) return null;
  if (w <= 0 || h <= 0) return null;
  const dpr = getDpr();

  if (state.canvasMode === "multi") {
    const s = Math.max(0.0001, Number(state.multiView?.scale) || 1);
    const ox = Number(state.multiView?.offsetX) || 0;
    const oy = Number(state.multiView?.offsetY) || 0;
    // Ambient world rects are in CSS-space; map to canvas/device space before rendering and hit testing.
    return { x: x * dpr * s + ox, y: y * dpr * s + oy, w: w * dpr * s, h: h * dpr * s };
  }

  const s = Math.max(0.0001, Number(state.view?.scale) || 1);
  const ox = Number(state.view?.offsetX) || 0;
  const oy = Number(state.view?.offsetY) || 0;
  return { x: x * s + ox, y: y * s + oy, w: w * s, h: h * s };
}

function renderAmbientIntentNudges(octx, canvasW, canvasH) {
  const ambient = state.intentAmbient;
  if (!INTENT_AMBIENT_ICON_PLACEMENT_ENABLED) {
    if (ambient) ambient.uiHits = [];
    return;
  }
  if (!ambient || !intentAmbientActive()) return;
  if (state.mother?.running) {
    ambient.uiHits = [];
    return;
  }
  const suggestions = Array.isArray(ambient.suggestions) ? ambient.suggestions : [];
  if (!suggestions.length) {
    ambient.uiHits = [];
    return;
  }

  const dpr = getDpr();
  const minPx = Math.max(28, Math.round(72 * dpr));
  const maxPx = Math.max(minPx, Math.round(164 * dpr));
  const edge = Math.round(8 * dpr);
  const now = Date.now();
  let needsFadeTick = false;
  const hits = [];

  for (const suggestion of suggestions.slice(0, INTENT_AMBIENT_MAX_NUDGES)) {
    if (!suggestion || typeof suggestion !== "object") continue;
    const mapped = _ambientWorldRectToCanvasRect(suggestion.world_rect);
    if (!mapped) continue;

    const cx = mapped.x + mapped.w * 0.5;
    const cy = mapped.y + mapped.h * 0.5;
    const drawSize = clamp(Math.min(mapped.w, mapped.h), minPx, maxPx);
    if (drawSize <= 2) continue;

    let x = cx - drawSize * 0.5;
    let y = cy - drawSize * 0.5;
    x = clamp(x, edge, Math.max(edge, canvasW - drawSize - edge));
    y = clamp(y, edge, Math.max(edge, canvasH - drawSize - edge));

    const createdAt = Number(suggestion.created_at_ms) || now;
    const updatedAt = Number(suggestion.updated_at_ms) || createdAt;
    const fade = clamp((now - createdAt) / INTENT_AMBIENT_FADE_IN_MS, 0.12, 1);
    if (fade < 0.999) needsFadeTick = true;
    const refresh = 1 - clamp((now - updatedAt) / 1100, 0, 1);
    const alpha = clamp(0.26 + 0.62 * fade * (0.84 + refresh * 0.16), 0.18, 0.9);

    const conf = typeof suggestion.confidence === "number" && Number.isFinite(suggestion.confidence)
      ? clamp(Number(suggestion.confidence), 0, 1)
      : null;
    const assetType = String(suggestion.asset_type || "icon");
    const assetKey = suggestion.asset_key ? String(suggestion.asset_key) : "";
    const iconImg = assetType === "icon" ? intentUiIcons.usecases?.[assetKey] || null : null;

    octx.save();
    octx.globalAlpha = alpha;
    octx.shadowColor = "rgba(0, 0, 0, 0.44)";
    octx.shadowBlur = Math.round(12 * dpr);
    octx.fillStyle = "rgba(8, 10, 14, 0.62)";
    octx.strokeStyle = "rgba(82, 255, 148, 0.24)";
    octx.lineWidth = Math.max(1, Math.round(1.1 * dpr));
    octx.beginPath();
    octx.arc(x + drawSize * 0.5, y + drawSize * 0.5, drawSize * 0.52, 0, Math.PI * 2);
    octx.fill();
    octx.stroke();
    octx.shadowBlur = 0;

    if (assetType === "icon" && iconImg && iconImg.complete && iconImg.naturalWidth > 0) {
      octx.imageSmoothingEnabled = true;
      octx.imageSmoothingQuality = "high";
      octx.drawImage(iconImg, Math.round(x), Math.round(y), Math.round(drawSize), Math.round(drawSize));
    } else if (assetType === "icon") {
      _drawIntentUseCaseGlyph(octx, assetKey, x + drawSize * 0.5, y + drawSize * 0.5, drawSize * 0.78, { alpha: 0.9 });
    } else {
      // Placeholder for upcoming generated-image nudges.
      octx.strokeStyle = "rgba(100, 210, 255, 0.68)";
      octx.lineWidth = Math.max(1, Math.round(1.4 * dpr));
      octx.strokeRect(
        Math.round(x + drawSize * 0.18),
        Math.round(y + drawSize * 0.18),
        Math.round(drawSize * 0.64),
        Math.round(drawSize * 0.64)
      );
    }

    if (conf !== null) {
      const barW = Math.max(10, Math.round(drawSize * 0.58));
      const barH = Math.max(1, Math.round(2 * dpr));
      const barX = Math.round(x + (drawSize - barW) * 0.5);
      const barY = Math.round(y + drawSize + Math.max(2, Math.round(3 * dpr)));
      octx.fillStyle = "rgba(8, 10, 14, 0.62)";
      octx.fillRect(barX, barY, barW, barH);
      octx.fillStyle = "rgba(82, 255, 148, 0.68)";
      octx.fillRect(barX, barY, Math.round(barW * conf), barH);
    }

    hits.push({
      kind: "ambient_nudge",
      id: String(suggestion.id || ""),
      rect: { x, y, w: drawSize, h: drawSize },
      branchId: suggestion.branch_id ? String(suggestion.branch_id) : "",
      assetKey: assetKey || "",
      anchorImageIds: Array.isArray(suggestion.anchor?.image_ids) ? suggestion.anchor.image_ids.slice(0, 3) : [],
    });

    octx.restore();
  }

  ambient.uiHits = hits;
  if (needsFadeTick) requestRender();
}

function reelTouchPulseFromCanvasPoint(pt, { down = false, lingerMs = REEL_TOUCH_MOVE_VISIBLE_MS } = {}) {
  if (!isReelSizeLocked()) return;
  const touch = state.reelTouch;
  if (!touch || !pt) return;
  const now = Date.now();
  touch.x = Number(pt.x) || 0;
  touch.y = Number(pt.y) || 0;
  touch.visibleUntil = Math.max(Number(touch.visibleUntil) || 0, now + Math.max(20, Number(lingerMs) || 0));
  if (down) {
    touch.down = true;
    touch.downUntil = Math.max(Number(touch.downUntil) || 0, now + REEL_TOUCH_TAP_VISIBLE_MS);
  } else if (now >= (Number(touch.downUntil) || 0)) {
    touch.down = false;
  }
}

function clearReelTouchPulse() {
  const touch = state.reelTouch;
  if (!touch) return;
  touch.visibleUntil = 0;
  touch.downUntil = 0;
  touch.down = false;
}

function resolvePendingPromptGenerateAnchorCss(pendingPromptGenerate = null) {
  const pending = pendingPromptGenerate || state.pendingPromptGenerate;
  if (!pending) return currentPromptGenerateAnchorCss();
  const rawWorld = pending.anchorWorldCss;
  const rawScreen = pending.anchorCss;

  if (
    state.canvasMode === "multi" &&
    rawWorld &&
    Number.isFinite(Number(rawWorld.x)) &&
    Number.isFinite(Number(rawWorld.y))
  ) {
    return clampCanvasCssPoint(canvasWorldCssToScreenCss(rawWorld));
  }
  if (rawScreen && Number.isFinite(Number(rawScreen.x)) && Number.isFinite(Number(rawScreen.y))) {
    return clampCanvasCssPoint(rawScreen);
  }
  if (rawWorld && Number.isFinite(Number(rawWorld.x)) && Number.isFinite(Number(rawWorld.y))) {
    return clampCanvasCssPoint(rawWorld);
  }
  return currentPromptGenerateAnchorCss();
}

function renderPromptGeneratePlaceholder(octx, canvasW, canvasH) {
  const pending = state.pendingPromptGenerate;
  if (!pending || !octx) return;

  const dpr = getDpr();
  const canvasCssW = (Number(canvasW) || 0) / Math.max(dpr, 0.0001);
  const canvasCssH = (Number(canvasH) || 0) / Math.max(dpr, 0.0001);
  if (!(canvasCssW > 0 && canvasCssH > 0)) return;

  const centerCss = resolvePendingPromptGenerateAnchorCss(pending);
  const tileCss = freeformDefaultTileCss(canvasCssW, canvasCssH, {
    count: Math.max(1, (state.images?.length || 0) + 1),
  });
  const canvasScale = state.canvasMode === "multi" ? Math.max(0.2, Number(state.multiView?.scale) || 1) : 1;
  const drawCss = clamp(
    Math.round(tileCss * canvasScale),
    Math.max(44, Math.round(52 / Math.max(canvasScale, 0.001))),
    Math.max(44, Math.round(Math.min(canvasCssW, canvasCssH) * 0.86))
  );

  const xCss = (Number(centerCss.x) || 0) - drawCss * 0.5;
  const yCss = (Number(centerCss.y) || 0) - drawCss * 0.5;
  const x = Math.round(xCss * dpr);
  const y = Math.round(yCss * dpr);
  const w = Math.max(1, Math.round(drawCss * dpr));
  const h = Math.max(1, Math.round(drawCss * dpr));

  const now = Date.now();
  const startedAt = Number(pending.startedAt) || now;
  const elapsedMs = Math.max(0, now - startedAt);
  const shimmerProgress = (elapsedMs % PROMPT_GENERATE_SHIMMER_LOOP_MS) / PROMPT_GENERATE_SHIMMER_LOOP_MS;
  const pulse = 0.5 + 0.5 * Math.sin((elapsedMs / 1000) * Math.PI * 2 * 0.78);
  const sweepCenter = x + (w + h * 1.4) * shimmerProgress - h * 0.7;

  octx.save();
  octx.globalCompositeOperation = "source-over";
  octx.fillStyle = `rgba(18, 32, 52, ${(0.28 + pulse * 0.1).toFixed(3)})`;
  octx.fillRect(x, y, w, h);
  octx.lineWidth = Math.max(1, Math.round(2 * dpr));
  octx.strokeStyle = `rgba(116, 222, 255, ${(0.66 + pulse * 0.2).toFixed(3)})`;
  octx.strokeRect(x, y, w, h);
  octx.restore();

  octx.save();
  octx.beginPath();
  octx.rect(x, y, w, h);
  octx.clip();
  const shimmer = octx.createLinearGradient(sweepCenter - h * 0.8, y, sweepCenter + h * 0.8, y + h);
  shimmer.addColorStop(0, "rgba(110, 214, 255, 0)");
  shimmer.addColorStop(0.45, "rgba(170, 240, 255, 0.12)");
  shimmer.addColorStop(0.5, "rgba(232, 252, 255, 0.56)");
  shimmer.addColorStop(0.55, "rgba(170, 240, 255, 0.12)");
  shimmer.addColorStop(1, "rgba(110, 214, 255, 0)");
  octx.fillStyle = shimmer;
  octx.fillRect(x - h, y, w + h * 2, h);
  octx.restore();

  octx.save();
  octx.strokeStyle = `rgba(166, 236, 255, ${(0.42 + pulse * 0.18).toFixed(3)})`;
  octx.lineWidth = Math.max(1, Math.round(1.25 * dpr));
  octx.setLineDash([Math.max(2, Math.round(8 * dpr)), Math.max(2, Math.round(6 * dpr))]);
  octx.lineDashOffset = -Math.round(shimmerProgress * Math.max(10, 40 * dpr));
  octx.strokeRect(
    x - Math.max(1, Math.round(2 * dpr)),
    y - Math.max(1, Math.round(2 * dpr)),
    w + Math.max(2, Math.round(4 * dpr)),
    h + Math.max(2, Math.round(4 * dpr))
  );
  octx.setLineDash([]);
  octx.restore();

  octx.save();
  const cx = x + w * 0.5;
  const cy = y + h * 0.5;
  const mark = Math.max(8, Math.round(14 * dpr));
  octx.lineWidth = Math.max(1, Math.round(1.6 * dpr));
  octx.strokeStyle = "rgba(226, 252, 255, 0.9)";
  octx.beginPath();
  octx.moveTo(Math.round(cx - mark * 0.6), Math.round(cy));
  octx.lineTo(Math.round(cx + mark * 0.6), Math.round(cy));
  octx.moveTo(Math.round(cx), Math.round(cy - mark * 0.6));
  octx.lineTo(Math.round(cx), Math.round(cy + mark * 0.6));
  octx.stroke();
  octx.restore();

  requestRender();
}

function renderReelTouchIndicator(octx, canvasW, canvasH) {
  if (!isReelSizeLocked()) return;
  const touch = state.reelTouch;
  if (!touch || !octx) return;
  const now = Date.now();
  const visibleUntil = Number(touch.visibleUntil) || 0;
  const downUntil = Number(touch.downUntil) || 0;
  const active = Boolean(state.pointer?.active) || now < visibleUntil || now < downUntil;
  if (!active) return;

  const x = clamp(Number(touch.x) || 0, 6, Math.max(6, Number(canvasW) - 6));
  const y = clamp(Number(touch.y) || 0, 6, Math.max(6, Number(canvasH) - 6));
  const downProgress = downUntil > now ? 1 - clamp((downUntil - now) / REEL_TOUCH_TAP_VISIBLE_MS, 0, 1) : 0;
  const tail = clamp((visibleUntil - now) / REEL_TOUCH_MOVE_VISIBLE_MS, 0, 1);
  const alpha = clamp(0.36 + 0.56 * Math.max(tail, downProgress), 0.2, 0.96);
  const coreR = 8 - downProgress * 1.2;
  const ringR = 15 - downProgress * 1.6;

  octx.save();
  octx.globalCompositeOperation = "source-over";
  octx.shadowColor = "rgba(0, 0, 0, 0.44)";
  octx.shadowBlur = 18;

  octx.beginPath();
  octx.arc(x, y, ringR, 0, Math.PI * 2);
  octx.fillStyle = `rgba(220, 236, 255, ${Math.max(0.10, alpha * 0.18).toFixed(3)})`;
  octx.fill();

  octx.shadowBlur = 10;
  octx.beginPath();
  octx.arc(x, y, coreR, 0, Math.PI * 2);
  octx.fillStyle = `rgba(245, 250, 255, ${Math.max(0.2, alpha).toFixed(3)})`;
  octx.fill();

  octx.shadowBlur = 0;
  octx.lineWidth = 1.5;
  octx.strokeStyle = `rgba(90, 120, 150, ${Math.max(0.24, alpha * 0.42).toFixed(3)})`;
  octx.beginPath();
  octx.arc(x, y, coreR + 0.5, 0, Math.PI * 2);
  octx.stroke();

  if (downUntil > now) {
    const pulse = 10 + downProgress * 18;
    const pulseAlpha = Math.max(0, 0.42 * (1 - downProgress));
    octx.lineWidth = 2;
    octx.strokeStyle = `rgba(240, 248, 255, ${pulseAlpha.toFixed(3)})`;
    octx.beginPath();
    octx.arc(x, y, pulse, 0, Math.PI * 2);
    octx.stroke();
  }
  octx.restore();

  if (now < visibleUntil || now < downUntil) requestRender();
}

function render() {
  const work = els.workCanvas;
  const overlay = els.overlayCanvas;
  if (!work || !overlay) return;
  // Keep CSS-only intent effects (cursor/border) in sync with realtime activity.
  syncIntentRealtimeClass();
  const wctx = work.getContext("2d");
  const octx = overlay.getContext("2d");
  if (!wctx || !octx) return;

  wctx.clearRect(0, 0, work.width, work.height);
  octx.clearRect(0, 0, overlay.width, overlay.height);
  state.motherOverlayUiHits = [];
  state.activeImageTransformUiHits = [];

  const item = getActiveImage();

  if (state.canvasMode === "multi") {
    renderMultiCanvas(wctx, octx, work.width, work.height);
  } else {
    const img = item?.img;
    if (img) {
      const singleTransform = readFreeformRectTransform(state.freeformRects.get(String(item?.id || "")) || null);
      const singleW = img.naturalWidth || item?.width || 1;
      const singleH = img.naturalHeight || item?.height || 1;
      wctx.save();
      wctx.setTransform(state.view.scale, 0, 0, state.view.scale, state.view.offsetX, state.view.offsetY);
      wctx.imageSmoothingEnabled = true;
      wctx.imageSmoothingQuality = isFreeformTransformPointerDragActive() ? "medium" : "high";
      drawImageRectWithTransform(wctx, img, {
        x: 0,
        y: 0,
        w: singleW,
        h: singleH,
        rotateDeg: singleTransform.rotateDeg,
        skewXDeg: singleTransform.skewXDeg,
      });
      wctx.restore();

      // Keep single-view active selection clearly visible, matching multi-view behavior.
      const dpr = getDpr();
      const motherGenerated = isMotherGeneratedImageItem(item);
      const outerStroke = motherGenerated ? "rgba(82, 255, 148, 0.20)" : "rgba(255, 212, 0, 0.14)";
      const mainStroke = motherGenerated ? "rgba(82, 255, 148, 0.94)" : "rgba(255, 212, 0, 0.96)";
      const mainShadow = motherGenerated ? "rgba(82, 255, 148, 0.28)" : "rgba(255, 212, 0, 0.26)";
      const innerStroke = motherGenerated ? "rgba(208, 255, 226, 0.60)" : "rgba(255, 247, 210, 0.58)";
      const singleDragPerfMode = isFreeformTransformPointerDragActive() && String(state.pointer?.imageId || "") === String(item?.id || "");
      const singleOuterLineWidth = singleDragPerfMode ? Math.max(1, Math.round(6 * dpr)) : Math.max(1, Math.round(10 * dpr));
      const singleOuterShadowBlur = singleDragPerfMode ? Math.round(20 * dpr) : Math.round(44 * dpr);
      const singleMainShadowBlur = singleDragPerfMode ? Math.round(14 * dpr) : Math.round(28 * dpr);
      const ix = state.view.offsetX;
      const iy = state.view.offsetY;
      const iw = (img.naturalWidth || item.width || 1) * state.view.scale;
      const ih = (img.naturalHeight || item.height || 1) * state.view.scale;
      const singleBorderPoints = transformedRectPolygonPoints({
        x: ix,
        y: iy,
        w: iw,
        h: ih,
        rotateDeg: singleTransform.rotateDeg,
        skewXDeg: singleTransform.skewXDeg,
      });

      octx.save();
      octx.lineJoin = "round";
      octx.strokeStyle = outerStroke;
      octx.lineWidth = singleOuterLineWidth;
      octx.shadowColor = mainShadow;
      octx.shadowBlur = singleOuterShadowBlur;
      if (drawPolygonPath(octx, singleBorderPoints)) octx.stroke();

      octx.strokeStyle = mainStroke;
      octx.lineWidth = Math.max(1, Math.round(3.4 * dpr));
      octx.shadowColor = mainShadow;
      octx.shadowBlur = singleMainShadowBlur;
      if (drawPolygonPath(octx, singleBorderPoints)) octx.stroke();

	      octx.shadowBlur = 0;
	      octx.strokeStyle = innerStroke;
	      octx.lineWidth = Math.max(1, Math.round(1.2 * dpr));
	      if (drawPolygonPath(octx, singleBorderPoints)) octx.stroke();
	      octx.restore();
	      if (state.tool === "pan" || intentModeActive()) {
	        const handleStroke = motherGenerated ? "rgba(82, 255, 148, 0.92)" : "rgba(255, 212, 0, 0.92)";
	        renderActiveImageTransformControls(octx, {
	          anchorRect: { x: ix, y: iy, w: iw, h: ih },
            anchorPoints: singleBorderPoints,
	          dpr,
	          accent: handleStroke,
	          targetId: item.id,
	        });
	      }
	    }
	  }
  syncEffectsRuntimeScene();
  updateImageFxRect();

  const pts = state.selection?.points || state.lassoDraft;
  if (pts && pts.length >= 2) {
    octx.save();
    octx.lineWidth = Math.max(1, Math.round(2 * getDpr()));
    octx.strokeStyle = "rgba(255, 179, 0, 0.95)";
    octx.fillStyle = "rgba(255, 179, 0, 0.12)";
    octx.beginPath();
    const c0 = imageToCanvas(pts[0]);
    octx.moveTo(c0.x, c0.y);
    for (let i = 1; i < pts.length; i += 1) {
      const c = imageToCanvas(pts[i]);
      octx.lineTo(c.x, c.y);
    }
    if (state.selection && state.selection.closed) {
      octx.closePath();
      octx.fill();
    }
    octx.stroke();
    octx.restore();
  }

  const annotateBox = state.annotateDraft || state.annotateBox;
  if (annotateBox && item?.id && annotateBox.imageId === item.id) {
    const dpr = getDpr();
    const a = imageToCanvas({ x: Number(annotateBox.x0) || 0, y: Number(annotateBox.y0) || 0 });
    const b = imageToCanvas({ x: Number(annotateBox.x1) || 0, y: Number(annotateBox.y1) || 0 });
    const x = Math.min(a.x, b.x);
    const y = Math.min(a.y, b.y);
    const w = Math.max(1, Math.abs(a.x - b.x));
    const h = Math.max(1, Math.abs(a.y - b.y));
    octx.save();
    octx.lineWidth = Math.max(1, Math.round(2 * dpr));
    octx.strokeStyle = "rgba(82, 255, 148, 0.92)";
    octx.fillStyle = "rgba(82, 255, 148, 0.10)";
    if (state.annotateDraft) {
      octx.setLineDash([Math.round(8 * dpr), Math.round(6 * dpr)]);
    }
    octx.fillRect(x, y, w, h);
    octx.strokeRect(x, y, w, h);
    octx.setLineDash([]);
    octx.restore();
  }

  if (item?.id) {
    const dpr = getDpr();
    const circles = _getCircles(item.id);
    const draft = state.circleDraft && state.circleDraft.imageId === item.id ? state.circleDraft : null;
    const activeCircleId = state.activeCircle?.imageId === item.id ? state.activeCircle.id : null;

    const drawCircle = (circle, { isDraft = false } = {}) => {
      if (!circle) return;
      const geom = circleImageToCanvasGeom(circle);
      if (!geom.r || geom.r < 1) return;
      const color = circle.color || "rgba(255, 95, 95, 0.92)";
      const fill = "rgba(255, 95, 95, 0.08)";
      const isActive = !isDraft && activeCircleId && circle.id === activeCircleId;

      octx.save();
      octx.lineWidth = Math.max(1, Math.round((isActive ? 2.8 : 2) * dpr));
      octx.strokeStyle = color;
      octx.fillStyle = fill;
      if (isActive) {
        octx.shadowColor = "rgba(255, 95, 95, 0.22)";
        octx.shadowBlur = Math.round(16 * dpr);
      }
      if (isDraft) {
        octx.setLineDash([Math.round(10 * dpr), Math.round(8 * dpr)]);
      }
      octx.beginPath();
      octx.arc(geom.cx, geom.cy, geom.r, 0, Math.PI * 2);
      octx.stroke();
      if (!isDraft) octx.fill();
      octx.setLineDash([]);

      const label = String(circle.label || "").trim();
	      if (label) {
	        octx.shadowBlur = 0;
	        octx.font = `${Math.max(10, Math.round(11 * dpr))}px IBM Plex Mono`;
	        octx.textBaseline = "middle";
	        octx.fillStyle = color;
	        const x = geom.cx + geom.r + Math.round(10 * dpr);
	        const y = geom.cy;
	        // Tiny dark underlay for legibility against bright pixels.
	        octx.globalAlpha = 0.85;
        octx.fillStyle = "rgba(0, 0, 0, 0.62)";
        octx.fillText(label, x + Math.round(1 * dpr), y + Math.round(1 * dpr));
	        octx.globalAlpha = 1;
	        octx.fillStyle = color;
	        octx.fillText(label, x, y);
	      }
      octx.restore();
    };

    for (const circle of circles.slice(-24)) {
      drawCircle(circle, { isDraft: false });
    }
    if (draft) {
      drawCircle(draft, { isDraft: true });
    }
  }

  renderIntentOverlay(octx, work.width, work.height);
  renderAmbientIntentNudges(octx, work.width, work.height);
  renderPromptGeneratePlaceholder(octx, work.width, work.height);
  renderReelTouchIndicator(octx, work.width, work.height);
  renderMotherRolePreview();
  if (!effectsRuntime && !document.hidden && shouldAnimateEffectVisuals()) {
    requestRender();
  }
}

function startSpawnTimer() {
  clearInterval(state.spawnTimer);
  state.spawnTimer = setInterval(() => {
    const idleForMs = Date.now() - state.lastInteractionAt;
    if (idleForMs < 18000) return;
    if (!state.activeId) return;
    if (state.tool === "lasso" && state.lassoDraft.length > 0) return;
    chooseSpawnNodes();
  }, 5000);
}

function installCanvasHandlers() {
  if (!els.overlayCanvas) return;

  let lastOverlayCursor = null;
  const setOverlayCursor = (value) => {
    const next = isReelSizeLocked() ? "none" : value || INTENT_IMPORT_CURSOR;
    if (next === lastOverlayCursor) return;
    lastOverlayCursor = next;
    els.overlayCanvas.style.cursor = next;
  };

  // Keep a stable baseline cursor so the browser arrow does not flash between move events.
  const resetCanvasCursor = () => {
    if (!els.overlayCanvas) return;
    if (!state.pointer?.active) {
      setOverlayCursor(INTENT_IMPORT_CURSOR);
    }
  };
  resetCanvasCursor();
  const handlePointerEnter = (event) => {
    resetCanvasCursor();
    rememberPromptGenerateHoverCss(canvasCssPointFromEvent(event));
    if (!isReelSizeLocked()) return;
    reelTouchPulseFromCanvasPoint(canvasPointFromEvent(event), { down: false, lingerMs: REEL_TOUCH_MOVE_VISIBLE_MS });
    requestRender();
  };
  const handlePointerLeave = () => {
    resetCanvasCursor();
    if (!isReelSizeLocked()) return;
    clearReelTouchPulse();
    requestRender();
  };

  const handleOverlayKeyDown = (event) => {
    const key = String(event?.key || "");
    if (key !== "Enter" && key !== " ") return;
    const viewportOnlyMotion =
      state.pointer.kind === POINTER_KINDS.FREEFORM_IMPORT ||
      state.pointer.kind === POINTER_KINDS.FREEFORM_WHEEL ||
      (state.tool === "pan" && !state.pointer.kind);
    bumpInteraction({ semantic: !viewportOnlyMotion });
    event.preventDefault();
    // Keyboard-accessible primary action.
    // - Normal mode: import at a sensible default point (center).
    // - Forced-choice intent gate: do NOT allow importing (it bypasses the gate). Treat Enter/Space
    //   as "Lock Intent" (YES_TOKEN) on the current focus branch.
    if (intentModeActive()) {
      const intent = state.intent;
      const total = Math.max(1, Number(intent?.totalRounds) || 3);
      const round = Math.max(1, Number(intent?.round) || 1);
      const lockGate =
        Boolean(INTENT_FORCE_CHOICE_ENABLED) &&
        (Boolean(intent?.forceChoice) || (INTENT_ROUNDS_ENABLED ? round >= total : false));
      if (lockGate) {
	        if (!intent?.iconState) {
	          showToast("Intent updatingâ€¦", "tip", 1600);
	          requestRender();
	          return;
	        }
	        lockIntentFromUi({ source: "keyboard" });
	        return;
	      }
	    }
		    importPhotosAtCanvasPoint(canvasScreenCssToWorldCss(_defaultImportPointCss())).catch((err) => console.error(err));
		  };

  const handleContextMenu = (event) => {
    bumpInteraction();
    closeMotherWheelMenu({ immediate: false });
    if (!getActiveImage()) return;
    event.preventDefault();

    let hit = null;
    if (state.canvasMode === "multi") {
      const p = canvasPointFromEvent(event);
      hit = hitTestMulti(p);
    } else {
      hit = state.activeId;
    }
    if (!hit) return;
    showImageMenuAt(canvasCssPointFromEvent(event), hit);
    // Prevent global "click outside" handlers from immediately closing the menu.
    event.stopPropagation();
  };

  const handlePointerDown = (event) => {
					    closeMotherWheelMenu({ immediate: false });
        state.pointer.wheelOnTap = false;
        state.pointer.semanticInteractionEmitted = false;
		    if (state.canvasMode === "multi") {
		      const canvas = els.workCanvas;
		      if (canvas && state.multiRects.size === 0) {
		        state.multiRects = computeFreeformRectsPx(canvas.width, canvas.height);
		      }

	      const p = canvasPointFromEvent(event);
          if (isReelSizeLocked()) {
            reelTouchPulseFromCanvasPoint(p, { down: event.button === 0, lingerMs: REEL_TOUCH_TAP_VISIBLE_MS });
            requestRender();
          }
          const pCss = canvasCssPointFromEvent(event);
          rememberPromptGenerateHoverCss(pCss);
          const intentActive = intentModeActive();
          const wheelModifier = Boolean(event.metaKey || event.ctrlKey);
          const motherOverlayHit = hitTestMotherOverlayUi(p);
          if (motherOverlayHit && event.button === 0) {
            bumpInteraction({ semantic: false });
            if (motherToggleOverlayDetails(motherOverlayHit)) {
              requestRender();
              return;
            }
          }
          if (event.button === 0 && (state.motherIdle?.offerDetailsOpen || state.motherResultDetailsOpenId)) {
            motherCloseOverlayDetails();
          }
          const motherRoleHit = motherV2InInteractivePhase() && motherV2IsAdvancedVisible() ? hitTestMotherRoleGlyph(p) : null;

          if (motherRoleHit && event.button === 0) {
            bumpInteraction({ semantic: false });
            els.overlayCanvas.setPointerCapture(event.pointerId);
            state.pointer.active = true;
            state.pointer.kind = POINTER_KINDS.MOTHER_ROLE_DRAG;
            state.pointer.imageId = String(motherRoleHit.imageId || "");
            state.pointer.role = String(motherRoleHit.role || "");
            state.pointer.startX = p.x;
            state.pointer.startY = p.y;
            state.pointer.lastX = p.x;
            state.pointer.lastY = p.y;
            state.pointer.startCssX = pCss.x;
            state.pointer.startCssY = pCss.y;
            state.pointer.moved = false;
            if (state.motherIdle) {
              state.motherIdle.roleGlyphDrag = {
                role: String(motherRoleHit.role || ""),
                imageId: String(motherRoleHit.imageId || ""),
                moved: false,
                targetImageId: String(motherRoleHit.imageId || ""),
              };
            }
            requestRender();
            return;
          }
          const effectTokenHit = hitTestEffectToken(p);
          if (effectTokenHit && event.button === 0) {
            const token = state.effectTokensById.get(String(effectTokenHit.tokenId || "").trim()) || null;
            if (!token || !beginEffectTokenDrag(token, { x: p.x, y: p.y })) {
              requestRender();
              return;
            }
            bumpInteraction({ semantic: false });
            els.overlayCanvas.setPointerCapture(event.pointerId);
            state.pointer.active = true;
            state.pointer.kind = POINTER_KINDS.EFFECT_TOKEN_DRAG;
            state.pointer.imageId = String(effectTokenHit.imageId || "");
            state.pointer.startX = p.x;
            state.pointer.startY = p.y;
            state.pointer.lastX = p.x;
            state.pointer.lastY = p.y;
            state.pointer.startCssX = pCss.x;
            state.pointer.startCssY = pCss.y;
            state.pointer.moved = false;
            state.effectTokenDrag = {
              tokenId: String(effectTokenHit.tokenId || ""),
              sourceImageId: String(effectTokenHit.imageId || ""),
              targetImageId: "",
              moved: false,
              x: p.x,
              y: p.y,
            };
            requestRender();
            return;
          }
          const transformUiHit = hitTestActiveImageTransformUi(p);
          if (transformUiHit && event.button === 0) {
            bumpInteraction({ semantic: false });
            if (beginActiveImageTransformDrag(event, { ptCanvas: p, ptCss: pCss, hit: transformUiHit })) {
              requestRender();
              return;
            }
          }
          // Initial pointer-down in multi-canvas is often a focus change (selection). Treat as
          // non-semantic; real arrangement changes are still marked semantic during pointermove.
          bumpInteraction({ semantic: false });
          const ambientHit = intentAmbientActive() ? hitTestAmbientIntentNudge(p) : null;

          if (ambientHit) {
            activateAmbientIntentNudge(ambientHit);
            requestRender();
            return;
          }

		          if (intentActive) {
	            const uiHit = hitTestIntentUi(p);
	            if (uiHit) {
	              const kind = String(uiHit.kind || "");
	              if (kind === "intent_branch") {
	                state.intent.focusBranchId = String(uiHit.id || "");
	                scheduleIntentStateWrite({ immediate: true });
	                requestRender();
	                return;
		              }
		              if (kind === "intent_lock") {
		                lockIntentFromUi({ source: "start_button" });
		                return;
		              }
	              if (kind === "intent_token") {
	                const raw = String(uiHit.id || "");
	                const [bid, tok] = raw.split("::");
	                if (bid && tok) applyIntentSelection(bid, tok);
	                return;
              }
            }
            // Optional gate (disabled by default): block canvas interactions until the user locks an intent.
            if (INTENT_FORCE_CHOICE_ENABLED && state.intent.forceChoice) {
              requestRender();
              return;
            }
          }
		      let hit = hitTestMulti(p);
          let corner = null;
          if (state.tool === "pan") {
            const handleHit = hitTestAnyFreeformCornerHandle(p, { padPx: Math.round(12 * getDpr()) });
            if (handleHit?.id && handleHit.corner) {
              hit = handleHit.id;
              corner = handleHit.corner;
            }
          }
			      if (!hit && canvas) {
			        state.multiRects = computeFreeformRectsPx(canvas.width, canvas.height);
	            hit = hitTestMulti(p);
	            corner = null;
	            if (state.tool === "pan") {
	              const handleHit = hitTestAnyFreeformCornerHandle(p, { padPx: Math.round(12 * getDpr()) });
	              if (handleHit?.id && handleHit.corner) {
	                hit = handleHit.id;
	                corner = handleHit.corner;
	              }
	            }
			      }

            // Avoid accidental click-to-import when the user is trying to grab a tile edge/handle.
	            if (!hit && intentActive) {
	              const paddedHit = hitTestMultiWithPad(p, Math.round(10 * getDpr()));
	              if (paddedHit) hit = paddedHit;
	            }

	      if (hit) {
	              const toggle = Boolean((event.shiftKey || event.metaKey || event.ctrlKey) && state.tool !== "annotate");
	              selectCanvasImage(hit, { toggle }).catch(() => {});
	              // Modifier-click (Shift/Cmd/Ctrl) is reserved for multi-select toggling; don't start a drag/tool action.
	              if (toggle) return;
	            }

            if (!intentActive && wheelModifier && event.button === 0) {
              els.overlayCanvas.setPointerCapture(event.pointerId);
              state.pointer.active = true;
              state.pointer.imageId = null;
              state.pointer.corner = null;
              state.pointer.startX = p.x;
              state.pointer.startY = p.y;
              state.pointer.lastX = p.x;
              state.pointer.lastY = p.y;
              state.pointer.startCssX = pCss.x;
              state.pointer.startCssY = pCss.y;
              state.pointer.startOffsetX = state.multiView.offsetX;
              state.pointer.startOffsetY = state.multiView.offsetY;
              state.pointer.importPointCss = { x: pCss.x, y: pCss.y };
              state.pointer.kind = POINTER_KINDS.FREEFORM_WHEEL;
              state.pointer.wheelOnTap = true;
              state.pointer.moved = false;
              requestRender();
              return;
            }

	          if (!hit) {
	            if (event.button !== 0) return;
	            els.overlayCanvas.setPointerCapture(event.pointerId);
	            state.pointer.active = true;
	            state.pointer.imageId = null;
	            state.pointer.corner = null;
	            state.pointer.startX = p.x;
	            state.pointer.startY = p.y;
	            state.pointer.lastX = p.x;
	            state.pointer.lastY = p.y;
	            state.pointer.startCssX = pCss.x;
	            state.pointer.startCssY = pCss.y;
	            state.pointer.startOffsetX = state.multiView.offsetX;
	            state.pointer.startOffsetY = state.multiView.offsetY;
	            state.pointer.importPointCss = { x: pCss.x, y: pCss.y };
              state.pointer.wheelOnTap = false;
	            state.pointer.moved = false;
	            if (intentActive) {
	              // Keep legacy import behavior in forced intent mode.
	              state.pointer.kind = POINTER_KINDS.FREEFORM_IMPORT;
	              if (!state.intent.startedAt) {
	                state.intent.rtState = "connecting";
	              }
	            } else {
	              // Empty-space click-drag pans the multi-canvas working set.
	              state.pointer.kind = POINTER_KINDS.SINGLE_PAN;
	            }
	            requestRender();
	            return;
	          }

		      if (state.tool === "pan") {
		        const rectPx = state.multiRects.get(hit) || null;
		        const rectCss = state.freeformRects.get(hit) || null;
		        const cornerHit = corner || (rectPx
              ? hitTestFreeformCornerHandleWithPad(p, rectPx, Math.round(12 * getDpr()), rectCss)
              : null);

		        // Bring the active (dragged) image to the top for intuitive hit-testing and stacking.
		        const z = state.freeformZOrder || [];
		        const zIdx = z.indexOf(hit);
		        if (zIdx >= 0) {
		          z.splice(zIdx, 1);
		          z.push(hit);
		        }

		        els.overlayCanvas.setPointerCapture(event.pointerId);
		        state.pointer.active = true;
		        state.pointer.kind = cornerHit ? POINTER_KINDS.FREEFORM_RESIZE : POINTER_KINDS.FREEFORM_MOVE;
		        state.pointer.imageId = hit;
		        state.pointer.corner = cornerHit;
		        state.pointer.startX = p.x;
		        state.pointer.startY = p.y;
		        state.pointer.lastX = p.x;
		        state.pointer.lastY = p.y;
		        state.pointer.startCssX = pCss.x;
		        state.pointer.startCssY = pCss.y;
		        state.pointer.startRectCss = rectCss ? { ...rectCss } : null;
		        state.pointer.wheelOnTap = false;
		        state.pointer.moved = false;
		        requestRender();
		        return;
		      }

		      if (!hit) return;

	      const img = state.imagesById.get(hit) || getActiveImage();
	      if (!img) return;
	      if (!img.img && (!img.width || !img.height)) {
	        ensureCanvasImageLoaded(img);
	        showToast("Loading imageâ€¦", "info", 1400);
	        return;
	      }

			      if (state.tool === "annotate") {
		        const imgPt = canvasToImage(p);
		        if (event.shiftKey) {
		          hideAnnotatePanel();
		          hideMarkPanel();
		          state.annotateBox = null;
		          state.annotateDraft = null;
		          els.overlayCanvas.setPointerCapture(event.pointerId);
		          state.pointer.active = true;
		          state.pointer.startX = p.x;
		          state.pointer.startY = p.y;
		          state.pointer.lastX = p.x;
		          state.pointer.lastY = p.y;
		          state.circleDraft = {
		            imageId: img.id,
		            cx: imgPt.x,
		            cy: imgPt.y,
		            r: 0,
		            color: "rgba(255, 95, 95, 0.92)",
		            at: Date.now(),
		          };
		          requestRender();
		          return;
		        }

		        const circles = _getCircles(img.id);
		        const hitCircle = hitTestCircleMarks(p, circles);
		        if (hitCircle) {
		          hideAnnotatePanel();
		          showMarkPanelForCircle(hitCircle);
		          requestRender();
		          return;
		        }

		        hideMarkPanel();
		        els.overlayCanvas.setPointerCapture(event.pointerId);
		        state.pointer.active = true;
		        state.pointer.startX = p.x;
		        state.pointer.startY = p.y;
		        state.pointer.lastX = p.x;
		        state.pointer.lastY = p.y;
		        state.annotateBox = null;
		        hideAnnotatePanel();
		        state.annotateDraft = {
		          imageId: img.id,
		          x0: imgPt.x,
		          y0: imgPt.y,
		          x1: imgPt.x,
		          y1: imgPt.y,
		          at: Date.now(),
		        };
		        requestRender();
		        return;
		      }

	      if (state.tool === "lasso") {
	        els.overlayCanvas.setPointerCapture(event.pointerId);
	        state.pointer.active = true;
	        state.pointer.startX = p.x;
        state.pointer.startY = p.y;
        state.pointer.lastX = p.x;
        state.pointer.lastY = p.y;
        state.pointer.startOffsetX = state.multiView.offsetX;
        state.pointer.startOffsetY = state.multiView.offsetY;
        state.selection = null;
        state.lassoDraft = [canvasToImage(p)];
	        requestRender();
	        return;
	      }
	      return;
		    }
        bumpInteraction();
		    const img = getActiveImage();
		    if (!img) return;
        const p = canvasPointFromEvent(event);
        const pCss = canvasCssPointFromEvent(event);
        rememberPromptGenerateHoverCss(pCss);
        const wheelModifier = Boolean(event.metaKey || event.ctrlKey);
        if (isReelSizeLocked()) {
          reelTouchPulseFromCanvasPoint(p, { down: event.button === 0, lingerMs: REEL_TOUCH_TAP_VISIBLE_MS });
          requestRender();
        }
        const transformUiHit = hitTestActiveImageTransformUi(p);
        if (transformUiHit && event.button === 0) {
          bumpInteraction({ semantic: false });
          if (beginActiveImageTransformDrag(event, { ptCanvas: p, ptCss: pCss, hit: transformUiHit })) {
            requestRender();
            return;
          }
        }
        if (wheelModifier && event.button === 0) {
          els.overlayCanvas.setPointerCapture(event.pointerId);
          state.pointer.active = true;
          state.pointer.kind = POINTER_KINDS.FREEFORM_WHEEL;
          state.pointer.imageId = null;
          state.pointer.corner = null;
          state.pointer.startX = p.x;
          state.pointer.startY = p.y;
          state.pointer.lastX = p.x;
          state.pointer.lastY = p.y;
          state.pointer.startCssX = pCss.x;
          state.pointer.startCssY = pCss.y;
          state.pointer.startOffsetX = state.view.offsetX;
          state.pointer.startOffsetY = state.view.offsetY;
          state.pointer.importPointCss = { x: pCss.x, y: pCss.y };
          state.pointer.wheelOnTap = true;
          state.pointer.moved = false;
          requestRender();
          return;
        }
        if (state.tool === "annotate" && !event.shiftKey) {
          const circles = _getCircles(img.id);
          const hitCircle = hitTestCircleMarks(p, circles);
          if (hitCircle) {
            hideAnnotatePanel();
            showMarkPanelForCircle(hitCircle);
            requestRender();
            return;
          }
        }

	    els.overlayCanvas.setPointerCapture(event.pointerId);
	    state.pointer.active = true;
	    state.pointer.kind = state.tool === "pan" ? POINTER_KINDS.SINGLE_PAN : null;
	    state.pointer.importPointCss = { x: pCss.x, y: pCss.y };
	    state.pointer.wheelOnTap = false;
	    state.pointer.startX = p.x;
	    state.pointer.startY = p.y;
		    state.pointer.startCssX = pCss.x;
		    state.pointer.startCssY = pCss.y;
		    state.pointer.lastX = p.x;
		    state.pointer.lastY = p.y;
    state.pointer.startOffsetX = state.view.offsetX;
		    state.pointer.startOffsetY = state.view.offsetY;

		    if (state.tool === "annotate") {
		      const imgPt = canvasToImage(p);
          if (event.shiftKey) {
            hideAnnotatePanel();
            hideMarkPanel();
            state.annotateBox = null;
            state.annotateDraft = null;
            state.circleDraft = {
              imageId: img.id,
              cx: imgPt.x,
              cy: imgPt.y,
              r: 0,
              color: "rgba(255, 95, 95, 0.92)",
              at: Date.now(),
            };
            requestRender();
            return;
          }

          hideMarkPanel();
          state.circleDraft = null;
		      state.annotateBox = null;
		      hideAnnotatePanel();
		      state.annotateDraft = {
		        imageId: img.id,
		        x0: imgPt.x,
	        y0: imgPt.y,
	        x1: imgPt.x,
	        y1: imgPt.y,
	        at: Date.now(),
	      };
		      requestRender();
		      return;
		    }

	    if (state.tool === "lasso") {
	      state.selection = null;
	      state.lassoDraft = [canvasToImage(p)];
	      requestRender();
    }
	  };

  const handlePointerMove = (event) => {
    const p = canvasPointFromEvent(event);
    const pCss = canvasCssPointFromEvent(event);
    rememberPromptGenerateHoverCss(pCss);
    if (isReelSizeLocked()) {
      const down = Boolean(state.pointer?.active && (Number(event?.buttons) & 1));
      reelTouchPulseFromCanvasPoint(p, {
        down,
        lingerMs: down ? REEL_TOUCH_TAP_VISIBLE_MS : REEL_TOUCH_MOVE_VISIBLE_MS,
      });
      requestRender();
    }
    if (!state.pointer.active && state.motherIdle?.phase === MOTHER_IDLE_STATES.WAITING_FOR_USER) {
      const now = Date.now();
      if (now - (Number(state.lastInteractionAt) || 0) > 120) {
        state.lastInteractionAt = now;
      }
    }

    if (!state.pointer.active) {
      const motherOverlayHit = hitTestMotherOverlayUi(p);
      if (motherOverlayHit) {
        setOverlayCursor("pointer");
        return;
      }
      const roleHit = motherV2InInteractivePhase() && motherV2IsAdvancedVisible() ? hitTestMotherRoleGlyph(p) : null;
      if (roleHit) {
        setOverlayCursor("pointer");
        return;
      }
      const effectTokenHit = hitTestEffectToken(p);
      if (effectTokenHit) {
        setOverlayCursor("grab");
        return;
      }
      const transformUiHit = hitTestActiveImageTransformUi(p);
      if (transformUiHit) {
        setOverlayCursor(String(transformUiHit.cursor || "pointer"));
        return;
      }
      const ambientHit = intentAmbientActive() ? hitTestAmbientIntentNudge(p) : null;
      if (ambientHit) {
        setOverlayCursor("pointer");
        return;
      }
	      const intentActive = intentModeActive();
	      if (intentActive) {
        const uiHit = hitTestIntentUi(p);
        if (uiHit) {
          setOverlayCursor(INTENT_IMPORT_CURSOR);
          return;
        }
      }
      // Hover cursor feedback (click-to-upload + freeform arrange).
      if (state.canvasMode === "multi") {
        const canvas = els.workCanvas;
        if (canvas && state.multiRects.size === 0) {
          state.multiRects = computeFreeformRectsPx(canvas.width, canvas.height);
        }
        if (state.tool === "pan") {
          const handleHit = hitTestAnyFreeformCornerHandle(p, { padPx: Math.round(12 * getDpr()) });
          if (handleHit?.corner) {
            setOverlayCursor(handleHit.corner === "nw" || handleHit.corner === "se" ? "nwse-resize" : "nesw-resize");
            return;
          }
        }

        const hit = hitTestMulti(p);
        // Intent Mode uses an RTS-like pointer; reserve grab/drag cursors for the active drag.
        if (intentActive) {
          setOverlayCursor(INTENT_IMPORT_CURSOR);
          return;
        }
        if (!hit) {
          setOverlayCursor(INTENT_IMPORT_CURSOR);
          return;
        }
        if (state.tool === "pan") {
          setOverlayCursor("grab");
          return;
        }
        setOverlayCursor(INTENT_IMPORT_CURSOR);
        return;
      }
      if (intentActive) {
        setOverlayCursor(INTENT_IMPORT_CURSOR);
        return;
      }
      setOverlayCursor(INTENT_IMPORT_CURSOR);
      return;
    }

    // Keep move/resize affordances during active drags.
    if (state.pointer.kind === POINTER_KINDS.FREEFORM_RESIZE) {
      const corner = state.pointer.corner;
      if (corner) {
        setOverlayCursor(corner === "nw" || corner === "se" ? "nwse-resize" : "nesw-resize");
      }
    } else if (state.pointer.kind === POINTER_KINDS.FREEFORM_MOVE) {
      setOverlayCursor("grabbing");
    } else if (state.pointer.kind === POINTER_KINDS.FREEFORM_ROTATE) {
      setOverlayCursor("grabbing");
    } else if (state.pointer.kind === POINTER_KINDS.FREEFORM_SKEW) {
      setOverlayCursor("ew-resize");
    } else if (state.pointer.kind === POINTER_KINDS.EFFECT_TOKEN_DRAG) {
      setOverlayCursor("grabbing");
    } else if (state.pointer.kind === POINTER_KINDS.FREEFORM_IMPORT || state.pointer.kind === POINTER_KINDS.FREEFORM_WHEEL) {
      setOverlayCursor(INTENT_IMPORT_CURSOR);
    }

	    const dx = p.x - state.pointer.startX;
		    const dy = p.y - state.pointer.startY;
		    state.pointer.lastX = p.x;
		    state.pointer.lastY = p.y;

    if (state.pointer.kind === POINTER_KINDS.MOTHER_ROLE_DRAG) {
      bumpInteraction({ semantic: false });
	      const drag = state.motherIdle?.roleGlyphDrag || null;
	      const dist = Math.hypot(dx, dy);
	      if (dist > 4) state.pointer.moved = true;
      if (drag) {
        drag.moved = Boolean(state.pointer.moved);
        const hit = hitTestMulti(p);
        drag.targetImageId = hit ? String(hit) : "";
      }
	      requestRender();
	      return;
	    }
    if (state.pointer.kind === POINTER_KINDS.EFFECT_TOKEN_DRAG) {
      bumpInteraction({ semantic: false });
      const drag = state.effectTokenDrag;
      const dist = Math.hypot(dx, dy);
      if (dist > 4) state.pointer.moved = true;
      if (drag) {
        const token = state.effectTokensById.get(String(drag.tokenId || "").trim()) || null;
        drag.moved = Boolean(state.pointer.moved);
        drag.x = p.x;
        drag.y = p.y;
        const dropHit = hitTestMulti(p);
        const sourceId = String(drag.sourceImageId || "");
        const targetId = dropHit ? String(dropHit) : "";
        drag.targetImageId = isValidEffectDrop(sourceId, targetId) ? targetId : "";
        if (token) {
          updateEffectTokenDrag(token, {
            x: p.x,
            y: p.y,
            targetImageId: drag.targetImageId,
          });
        }
      }
      requestRender();
      return;
    }

    if (
      state.pointer.kind === POINTER_KINDS.FREEFORM_MOVE ||
      state.pointer.kind === POINTER_KINDS.FREEFORM_RESIZE ||
      state.pointer.kind === POINTER_KINDS.FREEFORM_ROTATE ||
      state.pointer.kind === POINTER_KINDS.FREEFORM_SKEW
    ) {
      const dragDistCss = Math.hypot(
        (Number(pCss.x) || 0) - state.pointer.startCssX,
        (Number(pCss.y) || 0) - state.pointer.startCssY
      );
      const hasSemanticDrag =
        Boolean(state.pointer.moved) || dragDistCss > MOTHER_SELECTION_SEMANTIC_DRAG_PX;
      const emitSemanticInteraction = hasSemanticDrag && !Boolean(state.pointer.semanticInteractionEmitted);
      bumpInteraction({
        motherHot: false,
        semantic: emitSemanticInteraction,
        proposalLiveRefresh: emitSemanticInteraction,
      });
      if (emitSemanticInteraction) state.pointer.semanticInteractionEmitted = true;
    } else {
      bumpInteraction();
    }

	    // Freeform interactions (multi canvas + pan tool).
    if (state.pointer.kind === POINTER_KINDS.FREEFORM_IMPORT || state.pointer.kind === POINTER_KINDS.FREEFORM_WHEEL) {
      const dist = Math.hypot((Number(pCss.x) || 0) - state.pointer.startCssX, (Number(pCss.y) || 0) - state.pointer.startCssY);
      if (dist > 6) state.pointer.moved = true;
      return;
    }
    if (state.pointer.kind === POINTER_KINDS.FREEFORM_MOVE && state.pointer.imageId) {
      const id = state.pointer.imageId;
      const startRect = state.pointer.startRectCss || state.freeformRects.get(id) || null;
      if (!startRect) return;
      const wrap = els.canvasWrap;
      const canvasCssW = wrap?.clientWidth || 0;
      const canvasCssH = wrap?.clientHeight || 0;
      const clampOpts = freeformWorkspaceClampOptions(canvasCssW, canvasCssH, { minSize: 44 });
      const ms = state.multiView?.scale || 1;
      const dxCss = (Number(pCss.x) || 0) - state.pointer.startCssX;
      const dyCss = (Number(pCss.y) || 0) - state.pointer.startCssY;
      const dragDistCss = Math.hypot(dxCss, dyCss);
      if (!state.pointer.moved && dragDistCss <= MOTHER_SELECTION_SEMANTIC_DRAG_PX) return;
      const dxWorld = dxCss / Math.max(ms, 0.0001);
      const dyWorld = dyCss / Math.max(ms, 0.0001);
      const next = clampFreeformRectCss(
        {
          x: (Number(startRect.x) || 0) + dxWorld,
          y: (Number(startRect.y) || 0) + dyWorld,
          w: Number(startRect.w) || 1,
          h: Number(startRect.h) || 1,
          autoAspect: false,
          rotateDeg: startRect.rotateDeg,
          skewXDeg: startRect.skewXDeg,
        },
        canvasCssW,
        canvasCssH,
        clampOpts
      );
      state.freeformRects.set(id, next);
      state.pointer.moved = true;
      scheduleVisualPromptWrite();
      requestRender();
      return;
    }
    if (state.pointer.kind === POINTER_KINDS.FREEFORM_RESIZE && state.pointer.imageId) {
      const id = state.pointer.imageId;
      const startRect = state.pointer.startRectCss || state.freeformRects.get(id) || null;
      if (!startRect) return;
      const wrap = els.canvasWrap;
      const canvasCssW = wrap?.clientWidth || 0;
      const canvasCssH = wrap?.clientHeight || 0;
      const clampOpts = freeformWorkspaceClampOptions(canvasCssW, canvasCssH, { minSize: 44 });
      const ms = state.multiView?.scale || 1;
      const dpr = getDpr();
      const mxCss = (Number(state.multiView?.offsetX) || 0) / Math.max(dpr, 0.0001);
      const myCss = (Number(state.multiView?.offsetY) || 0) / Math.max(dpr, 0.0001);
      const dxCss = (Number(pCss.x) || 0) - state.pointer.startCssX;
      const dyCss = (Number(pCss.y) || 0) - state.pointer.startCssY;
      const dragDistCss = Math.hypot(dxCss, dyCss);
      if (!state.pointer.moved && dragDistCss <= MOTHER_SELECTION_SEMANTIC_DRAG_PX) return;
      const worldPointerCss = {
        x: ((Number(pCss.x) || 0) - mxCss) / Math.max(ms, 0.0001),
        y: ((Number(pCss.y) || 0) - myCss) / Math.max(ms, 0.0001),
      };
      const startTransform = readFreeformRectTransform(startRect);
      const pointerRectSpace = untransformPointForRect(worldPointerCss, {
        x: Number(startRect.x) || 0,
        y: Number(startRect.y) || 0,
        w: Math.max(1, Number(startRect.w) || 1),
        h: Math.max(1, Number(startRect.h) || 1),
        rotateDeg: startTransform.rotateDeg,
        skewXDeg: startTransform.skewXDeg,
      });
      const next = resizeFreeformRectFromCorner(
        startRect,
        state.pointer.corner,
        pointerRectSpace,
        canvasCssW,
        canvasCssH,
        clampOpts
      );
      state.freeformRects.set(id, next);
      state.pointer.moved = true;
      scheduleVisualPromptWrite();
      requestRender();
      return;
    }
    if (state.pointer.kind === POINTER_KINDS.FREEFORM_ROTATE && state.pointer.imageId) {
      const id = state.pointer.imageId;
      const startRect = state.pointer.startRectCss || state.freeformRects.get(id) || null;
      if (!startRect) return;
      const pivotX = Number(state.pointer.transformPivotX);
      const pivotY = Number(state.pointer.transformPivotY);
      if (!Number.isFinite(pivotX) || !Number.isFinite(pivotY)) return;
      const startAngleRad = Number(state.pointer.transformStartAngleRad) || 0;
      const currentAngleRad = Math.atan2((Number(p.y) || 0) - pivotY, (Number(p.x) || 0) - pivotX);
      if (!Number.isFinite(currentAngleRad)) return;
      let deltaDeg = ((currentAngleRad - startAngleRad) * 180) / Math.PI;
      while (deltaDeg > 180) deltaDeg -= 360;
      while (deltaDeg < -180) deltaDeg += 360;
      if (!state.pointer.moved && Math.abs(deltaDeg) <= 0.75) return;
      const wrap = els.canvasWrap;
      const canvasCssW = Number(wrap?.clientWidth) || 0;
      const canvasCssH = Number(wrap?.clientHeight) || 0;
      let next = {
        ...startRect,
        autoAspect: false,
        rotateDeg: normalizeFreeformRotateDeg((Number(state.pointer.transformStartRotateDeg) || 0) + deltaDeg),
        skewXDeg: normalizeFreeformSkewDeg(state.pointer.transformStartSkewXDeg),
      };
      if (canvasCssW > 0 && canvasCssH > 0) {
        next = clampFreeformRectCss(
          next,
          canvasCssW,
          canvasCssH,
          freeformWorkspaceClampOptions(canvasCssW, canvasCssH, { minSize: 44 })
        );
      }
      state.freeformRects.set(id, next);
      state.pointer.moved = true;
      scheduleVisualPromptWrite();
      requestRender();
      return;
    }
    if (state.pointer.kind === POINTER_KINDS.FREEFORM_SKEW && state.pointer.imageId) {
      const id = state.pointer.imageId;
      const startRect = state.pointer.startRectCss || state.freeformRects.get(id) || null;
      if (!startRect) return;
      const edge = String(state.pointer.transformHandleEdge || "").trim().toLowerCase() === "left" ? "left" : "right";
      const dir = edge === "left" ? -1 : 1;
      const anchorWidthPx = Math.max(40, Number(state.pointer.transformAnchorWidthPx) || 0);
      const dxPx = ((Number(p.x) || 0) - (Number(state.pointer.startX) || 0)) * dir;
      const deltaDeg = (dxPx / anchorWidthPx) * 52;
      if (!state.pointer.moved && Math.abs(deltaDeg) <= 0.5) return;
      const wrap = els.canvasWrap;
      const canvasCssW = Number(wrap?.clientWidth) || 0;
      const canvasCssH = Number(wrap?.clientHeight) || 0;
      let next = {
        ...startRect,
        autoAspect: false,
        rotateDeg: normalizeFreeformRotateDeg(state.pointer.transformStartRotateDeg),
        skewXDeg: normalizeFreeformSkewDeg((Number(state.pointer.transformStartSkewXDeg) || 0) + deltaDeg),
      };
      if (canvasCssW > 0 && canvasCssH > 0) {
        next = clampFreeformRectCss(
          next,
          canvasCssW,
          canvasCssH,
          freeformWorkspaceClampOptions(canvasCssW, canvasCssH, { minSize: 44 })
        );
      }
      state.freeformRects.set(id, next);
      state.pointer.moved = true;
      scheduleVisualPromptWrite();
      requestRender();
      return;
    }

    // Existing tools (single canvas + edit tools).
			    if (state.tool === "annotate") {
			      const img = getActiveImage();
			      if (!img) return;
          if (state.circleDraft && state.circleDraft.imageId === img.id) {
            const imgPt = canvasToImage(p);
            const dxImg = (Number(imgPt.x) || 0) - (Number(state.circleDraft.cx) || 0);
            const dyImg = (Number(imgPt.y) || 0) - (Number(state.circleDraft.cy) || 0);
            state.circleDraft.r = Math.max(0, Math.hypot(dxImg, dyImg));
            requestRender();
            return;
          }
			      if (!state.annotateDraft || state.annotateDraft.imageId !== img.id) return;
			      const imgPt = canvasToImage(p);
			      state.annotateDraft.x1 = imgPt.x;
			      state.annotateDraft.y1 = imgPt.y;
			      requestRender();
			      return;
			    }
    if (state.pointer.kind === POINTER_KINDS.SINGLE_PAN || state.tool === "pan") {
      if (state.pointer.kind === POINTER_KINDS.SINGLE_PAN) {
        const dist = Math.hypot((Number(pCss.x) || 0) - state.pointer.startCssX, (Number(pCss.y) || 0) - state.pointer.startCssY);
        if (!state.pointer.moved && dist <= 6) return;
        state.pointer.moved = true;
      }
      if (state.canvasMode === "multi") {
        state.multiView.offsetX = state.pointer.startOffsetX + dx;
        state.multiView.offsetY = state.pointer.startOffsetY + dy;
      } else {
        state.view.offsetX = state.pointer.startOffsetX + dx;
        state.view.offsetY = state.pointer.startOffsetY + dy;
      }
      scheduleVisualPromptWrite();
      requestRender();
      return;
    }
    if (state.tool === "lasso") {
      const imgPt = canvasToImage(p);
		      const last = state.lassoDraft[state.lassoDraft.length - 1];
		      const dist2 = (imgPt.x - last.x) ** 2 + (imgPt.y - last.y) ** 2;
		      let scale = state.view.scale;
		      if (state.canvasMode === "multi") {
		        const ms = state.multiView?.scale || 1;
		        const img = getActiveImage();
		        const rect = img?.id ? state.multiRects.get(img.id) : null;
		        if (img && rect) {
		          const iw = img?.img?.naturalWidth || img?.width || rect.w || 1;
		          const ih = img?.img?.naturalHeight || img?.height || rect.h || 1;
		          const sx = rect.w / Math.max(1, iw);
		          const sy = rect.h / Math.max(1, ih);
		          scale = Math.min(sx, sy) * ms;
		        } else {
		          scale = ms;
		        }
		      }
      const minDist = 4 / Math.max(scale, 0.02);
      if (dist2 >= minDist * minDist) {
        state.lassoDraft.push(imgPt);
        requestRender();
      }
    }
  };

		  function finalizePointer(event) {
		    if (!state.pointer.active) return;
		    const kind = state.pointer.kind;
		    const imageId = state.pointer.imageId;
        const roleKey = state.pointer.role;
		    const startRectCss = state.pointer.startRectCss;
		    const corner = state.pointer.corner;
        const transformHandleEdge = state.pointer.transformHandleEdge;
        const transformStartRotateDeg = Number(state.pointer.transformStartRotateDeg) || 0;
        const transformStartSkewXDeg = Number(state.pointer.transformStartSkewXDeg) || 0;
        const importPt = state.pointer.importPointCss;
        const wheelOnTap = Boolean(state.pointer.wheelOnTap);
		    const moved = Boolean(state.pointer.moved);
		    state.pointer.active = false;
		    state.pointer.kind = null;
		    state.pointer.imageId = null;
        state.pointer.role = null;
		    state.pointer.corner = null;
		    state.pointer.startRectCss = null;
        state.pointer.transformHandleEdge = null;
        state.pointer.transformPivotX = 0;
        state.pointer.transformPivotY = 0;
        state.pointer.transformAnchorWidthPx = 0;
        state.pointer.transformStartAngleRad = 0;
        state.pointer.transformStartRotateDeg = 0;
        state.pointer.transformStartSkewXDeg = 0;
		    state.pointer.importPointCss = null;
        state.pointer.wheelOnTap = false;
		    state.pointer.moved = false;
        state.pointer.semanticInteractionEmitted = false;
        setOverlayCursor(INTENT_IMPORT_CURSOR);
        if (isReelSizeLocked()) {
          const p = canvasPointFromEvent(event);
          reelTouchPulseFromCanvasPoint(p, { down: false, lingerMs: REEL_TOUCH_RELEASE_VISIBLE_MS });
          if (state.reelTouch) {
            state.reelTouch.down = false;
            state.reelTouch.downUntil = Date.now() + REEL_TOUCH_RELEASE_VISIBLE_MS;
          }
          requestRender();
        }
        // Arm Mother idle timers against the settled interaction state (pointer no longer active).
        const motherRoleDrag = isMotherRolePath(kind);
        const effectTokenDrag = isEffectTokenPath(kind);
        if (!motherRoleDrag && !effectTokenDrag) {
          const selectionOnly =
            (kind === POINTER_KINDS.FREEFORM_MOVE ||
              kind === POINTER_KINDS.FREEFORM_RESIZE ||
              kind === POINTER_KINDS.FREEFORM_ROTATE ||
              kind === POINTER_KINDS.FREEFORM_SKEW) &&
            !moved;
          bumpInteraction({
            semantic: !selectionOnly,
            proposalLiveRefresh: Boolean(
              moved &&
              (kind === POINTER_KINDS.FREEFORM_MOVE ||
                kind === POINTER_KINDS.FREEFORM_RESIZE ||
                kind === POINTER_KINDS.FREEFORM_ROTATE ||
                kind === POINTER_KINDS.FREEFORM_SKEW)
            ),
          });
        }

		    if (moved && (kind === POINTER_KINDS.FREEFORM_MOVE || kind === POINTER_KINDS.FREEFORM_RESIZE) && imageId) {
		      const start = startRectCss && typeof startRectCss === "object" ? startRectCss : null;
		      const end = state.freeformRects.get(imageId) || null;
		      if (start && end) {
		        recordUserEvent(kind === POINTER_KINDS.FREEFORM_MOVE ? "image_move" : "image_resize", {
		          image_id: String(imageId),
		          corner: corner ? String(corner) : null,
		          start: {
		            x: Math.round(Number(start.x) || 0),
		            y: Math.round(Number(start.y) || 0),
		            w: Math.round(Number(start.w) || 0),
		            h: Math.round(Number(start.h) || 0),
		          },
		          end: {
		            x: Math.round(Number(end.x) || 0),
		            y: Math.round(Number(end.y) || 0),
		            w: Math.round(Number(end.w) || 0),
		            h: Math.round(Number(end.h) || 0),
			          },
			        });
		      }
          markAlwaysOnVisionDirty(kind === POINTER_KINDS.FREEFORM_MOVE ? "image_move" : "image_resize");
          scheduleAlwaysOnVision();
		    }
        if (moved && (kind === POINTER_KINDS.FREEFORM_ROTATE || kind === POINTER_KINDS.FREEFORM_SKEW) && imageId) {
          const end = state.freeformRects.get(imageId) || null;
          if (end) {
            recordUserEvent("image_transform", {
              image_id: String(imageId),
              action: kind === POINTER_KINDS.FREEFORM_ROTATE ? "rotate_drag" : "skew_drag",
              edge: kind === POINTER_KINDS.FREEFORM_SKEW ? String(transformHandleEdge || "right") : null,
              rotate_deg: Number(end.rotateDeg) || 0,
              skew_x_deg: Number(end.skewXDeg) || 0,
              rotate_start_deg: transformStartRotateDeg,
              skew_start_deg: transformStartSkewXDeg,
            });
          }
          markAlwaysOnVisionDirty("image_transform");
          scheduleAlwaysOnVision();
        }
        if (
          moved &&
          imageId &&
          intentAmbientActive() &&
          (
            kind === POINTER_KINDS.FREEFORM_MOVE ||
            kind === POINTER_KINDS.FREEFORM_RESIZE ||
            kind === POINTER_KINDS.FREEFORM_ROTATE ||
            kind === POINTER_KINDS.FREEFORM_SKEW
          )
        ) {
          if (kind === POINTER_KINDS.FREEFORM_MOVE) {
            scheduleAmbientIntentInference({ reason: "move", imageIds: [imageId] });
          } else if (kind === POINTER_KINDS.FREEFORM_RESIZE) {
            scheduleAmbientIntentInference({ reason: "resize", imageIds: [imageId] });
          } else {
            scheduleAmbientIntentInference({ reason: "composition_change", imageIds: [imageId] });
          }
        }

			    if (kind === POINTER_KINDS.FREEFORM_IMPORT) {
			      if (!moved && importPt) {
              const worldPt = canvasScreenCssToWorldCss(importPt);
			        recordUserEvent("canvas_import_click", {
			          x: Math.round(Number(worldPt.x) || 0),
			          y: Math.round(Number(worldPt.y) || 0),
			        });
			        importPhotosAtCanvasPoint(worldPt).catch((err) => console.error(err));
			      }
			    }
			    if (kind === POINTER_KINDS.FREEFORM_WHEEL) {
			      if (!moved && importPt) {
              const opened = openMotherWheelMenuAt(importPt);
              if (opened) {
                recordUserEvent("mother_wheel_open", {
                  x: Math.round(Number(importPt.x) || 0),
                  y: Math.round(Number(importPt.y) || 0),
                });
              }
			      }
			    }
          if (kind === POINTER_KINDS.SINGLE_PAN && wheelOnTap) {
            if (!moved && importPt) {
              const opened = openMotherWheelMenuAt(importPt);
              if (opened) {
                recordUserEvent("mother_wheel_open", {
                  x: Math.round(Number(importPt.x) || 0),
                  y: Math.round(Number(importPt.y) || 0),
                });
              }
            }
          }
          if (isMotherRolePath(kind)) {
            bumpInteraction({ semantic: false });
            const idle = state.motherIdle;
            const role = String(roleKey || idle?.roleGlyphDrag?.role || "").trim();
            const fromImageId = String(imageId || idle?.roleGlyphDrag?.imageId || "").trim();
            const dropHit = hitTestMulti(canvasPointFromEvent(event));
            const toImageId = dropHit ? String(dropHit) : "";
            if (role && MOTHER_V2_ROLE_KEYS.includes(role)) {
              let nextIds = motherV2RoleIds(role);
              // Drag to another image reassigns. Click/tap toggles off.
              if ((moved && toImageId && toImageId !== fromImageId) || (!moved && toImageId && toImageId !== fromImageId)) {
                nextIds = [toImageId];
              } else {
                nextIds = nextIds.filter((id) => id !== fromImageId);
              }
              motherV2SetRoleIds(role, nextIds);
              if (idle?.intent && typeof idle.intent === "object") {
                idle.intent.roles = motherV2RoleMapClone();
              }
              motherV2InvalidateOfferingForStructureEdit("glyph_edit");
              appendMotherTraceLog({
                kind: "glyph_edit",
                traceId: idle?.telemetry?.traceId || null,
                actionVersion: Number(idle?.actionVersion) || 0,
                role,
                from_image_id: fromImageId || null,
                to_image_id: toImageId || null,
              }).catch(() => {});
            }
            if (idle) idle.roleGlyphDrag = null;
            renderMotherReadout();
            requestRender();
          }
          if (isEffectTokenPath(kind)) {
            bumpInteraction({ semantic: false });
            const drag = state.effectTokenDrag || null;
            const tokenId = String(drag?.tokenId || "").trim();
            const sourceImageId = String(drag?.sourceImageId || "").trim();
            const token = state.effectTokensById.get(tokenId) || null;
            const dropHit = hitTestMulti(canvasPointFromEvent(event));
            const toImageId = isValidEffectDrop(sourceImageId, dropHit ? String(dropHit || "").trim() : "")
              ? String(dropHit || "").trim()
              : "";
            state.effectTokenDrag = null;
            if (!tokenId || !sourceImageId || !token) {
              requestRender();
            } else if (toImageId) {
              const dispatchId = beginEffectTokenApply(token, toImageId, Date.now());
              if (!dispatchId) {
                requestRender();
                return;
              }
              state.effectTokenApplyLocks.set(tokenId, {
                dispatchId,
                targetImageId: toImageId,
                queued: false,
                startedAt: Date.now(),
              });
              requestRender();
              void animateThenApplyEffectToken({
                tokenId,
                targetImageId: toImageId,
                dispatchId,
                fromX: Number(drag?.x) || 0,
                fromY: Number(drag?.y) || 0,
              });
            } else {
              cancelEffectTokenDrag(token);
              const sourceRect = state.multiRects.get(sourceImageId) || null;
              if (effectsRuntime && sourceRect) {
                const transform = getMultiViewTransform();
                const sourceScreenRect = multiRectToScreenRect(sourceRect, transform);
                const effectType = effectTypeFromTokenType(token.type);
                void effectsRuntime.playCancelToSource({
                  tokenId,
                  effectType,
                  fromX: Number(drag?.x) || 0,
                  fromY: Number(drag?.y) || 0,
                  targetRect: sourceScreenRect,
                  size: effectTokenDisplaySizeForRect(sourceScreenRect, effectType),
                  data: token,
                });
              }
              if (moved) {
                showToast("Drop the token onto another image to apply.", "tip", 1800);
              }
              requestRender();
            }
          }
			    if (state.tool === "annotate") {
			      const img = getActiveImage();
	          if (img && state.circleDraft && state.circleDraft.imageId === img.id) {
	            const draft = state.circleDraft;
	            state.circleDraft = null;
            const r = Math.max(0, Number(draft?.r) || 0);
            if (r >= 6) {
              const entry = {
                id: `c-${Date.now()}-${Math.random().toString(16).slice(2)}`,
                imageId: img.id,
                cx: Number(draft?.cx) || 0,
                cy: Number(draft?.cy) || 0,
                r,
                color: draft?.color ? String(draft.color) : "rgba(255, 95, 95, 0.92)",
                label: "",
                at: Date.now(),
              };
              const list = _getCircles(img.id).slice();
              list.push(entry);
              state.circlesByImageId.set(img.id, list);
              showMarkPanelForCircle(entry);
              scheduleVisualPromptWrite();
	            } else {
	              hideMarkPanel();
	            }
	            requestRender();
	          }
		      const draft = state.annotateDraft;
		      state.annotateDraft = null;
		      if (img && draft && draft.imageId === img.id) {
		        const normalized = _normalizeAnnotateBox(draft, img);
	        const w = Math.abs((normalized?.x1 || 0) - (normalized?.x0 || 0));
	        const h = Math.abs((normalized?.y1 || 0) - (normalized?.y0 || 0));
	        if (normalized && w >= 8 && h >= 8) {
		          state.annotateBox = normalized;
		          showAnnotatePanelForBox();
              scheduleVisualPromptWrite();
		        } else {
		          state.annotateBox = null;
		          hideAnnotatePanel();
              scheduleVisualPromptWrite();
		        }
		      }
		      requestRender();
		    }
	    if (state.tool === "lasso") {
	      if (state.lassoDraft.length >= 3) {
	        state.selection = { points: state.lassoDraft.slice(), closed: true, at: Date.now() };
	      } else {
	        state.selection = null;
	      }
	      state.lassoDraft = [];
	      renderSelectionMeta();
	      chooseSpawnNodes();
        scheduleVisualPromptWrite();
	      requestRender();
	    }
	    try {
	      els.overlayCanvas.releasePointerCapture(event.pointerId);
	    } catch {
      // ignore
    }
  }

  installCanvasPointerHandlers(els.overlayCanvas, {
    onPointerEnter: handlePointerEnter,
    onPointerLeave: handlePointerLeave,
    onContextMenu: handleContextMenu,
    onPointerDown: handlePointerDown,
    onPointerMove: handlePointerMove,
    onPointerUp: finalizePointer,
    onPointerCancel: finalizePointer,
  });
  installCanvasKeyboardHandlers(els.overlayCanvas, {
    onKeyDown: handleOverlayKeyDown,
  });

  const handleOverlayWheel = (event) => {
      bumpInteraction({ motherHot: false, semantic: false });
      if (!state.images || state.images.length === 0) return;
		      event.preventDefault();
	
	      const dpr = getDpr();
	      // UX: two-finger swipe up/down zooms (not pan). Horizontal swipe pans.
	      // Holding Option (Alt) forces pan (both axes) for when you want to scroll around.
	      let dx = Number(event.deltaX) || 0;
	      let dy = Number(event.deltaY) || 0;
	      // Mouse wheels often emit horizontal scroll as Shift+deltaY.
	      if (event.shiftKey && Math.abs(dx) < 0.001 && Math.abs(dy) > 0.001) {
	        dx = dy;
	        dy = 0;
	      }
	      // Normalize deltaMode into CSS pixels.
	      if (event.deltaMode === 1) {
	        dx *= 16;
	        dy *= 16;
	      } else if (event.deltaMode === 2) {
	        const wrap = els.canvasWrap;
	        dx *= wrap?.clientWidth || 1;
	        dy *= wrap?.clientHeight || 1;
	      }
	
	      const absDx = Math.abs(dx);
	      const absDy = Math.abs(dy);
	      const panX = dx * dpr;
	      const panY = dy * dpr;
	
	      if (wheelForcePanHeld) {
	        if (state.canvasMode === "multi") {
	          state.multiView.offsetX = (Number(state.multiView?.offsetX) || 0) - panX;
	          state.multiView.offsetY = (Number(state.multiView?.offsetY) || 0) - panY;
	        } else {
	          state.view.offsetX = (Number(state.view?.offsetX) || 0) - panX;
	          state.view.offsetY = (Number(state.view?.offsetY) || 0) - panY;
	        }
	        renderHudReadout();
	        requestRender();
	        return;
	      }
	
	      // Horizontal trackpad scroll pans left/right.
	      if (absDx > 0.01) {
	        if (state.canvasMode === "multi") {
	          state.multiView.offsetX = (Number(state.multiView?.offsetX) || 0) - panX;
	        } else {
	          state.view.offsetX = (Number(state.view?.offsetX) || 0) - panX;
	        }
	      }
	
	      // Ignore tiny vertical noise during a mostly-horizontal gesture.
	      if (absDy <= 0.01 || absDx > absDy * 1.1) {
	        renderHudReadout();
	        requestRender();
	        return;
	      }
	
	      // Wheel / trackpad pinch: zoom the view (single + freeform multi).
	      const p = canvasPointFromEvent(event);
	      const factor = Math.exp(-dy * 0.0012);
	      if (state.canvasMode === "multi") {
	        const before = {
	          x: (p.x - (state.multiView?.offsetX || 0)) / Math.max(state.multiView?.scale || 1, 0.0001),
	          y: (p.y - (state.multiView?.offsetY || 0)) / Math.max(state.multiView?.scale || 1, 0.0001),
	        };
	        const next = clamp((state.multiView?.scale || 1) * factor, 0.05, 40);
	        state.multiView.scale = next;
	        state.multiView.offsetX = p.x - before.x * state.multiView.scale;
	        state.multiView.offsetY = p.y - before.y * state.multiView.scale;
	      } else {
	        const before = canvasToImage(p);
	        const next = clamp(state.view.scale * factor, 0.05, 40);
	        state.view.scale = next;
	        state.view.offsetX = p.x - before.x * state.view.scale;
	        state.view.offsetY = p.y - before.y * state.view.scale;
	      }
		      renderHudReadout();
		      scheduleVisualPromptWrite();
		      requestRender();
		    };
  installCanvasWheelHandlers(els.overlayCanvas, {
    onWheel: handleOverlayWheel,
  });

    // WKWebView/Safari trackpad pinch-to-zoom is exposed via non-standard gesture events.
    // If we only listen for wheel+ctrlKey, users can lose pinch zoom.
    if (!state.gestureZoom) state.gestureZoom = { active: false, lastScale: 1 };
    const shouldHandleGesture = (event) => {
      if (!els.overlayCanvas) return false;
      const cx = Number(event?.clientX);
      const cy = Number(event?.clientY);
      if (!Number.isFinite(cx) || !Number.isFinite(cy)) return false;
      const rect = els.overlayCanvas.getBoundingClientRect();
      if (!rect?.width || !rect?.height) return false;
      return cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;
    };
    const onGestureStart = (event) => {
      if (!shouldHandleGesture(event)) return;
      if (!state.images || state.images.length === 0) return;
      bumpInteraction({ motherHot: false, semantic: false });
      event.preventDefault();
      state.gestureZoom.active = true;
      const s = Number(event?.scale);
      state.gestureZoom.lastScale = Number.isFinite(s) && s > 0 ? s : 1;
    };
    const onGestureChange = (event) => {
      if (!state.gestureZoom?.active) return;
      if (!shouldHandleGesture(event)) return;
      if (!state.images || state.images.length === 0) return;
      bumpInteraction({ motherHot: false, semantic: false });
      event.preventDefault();

      const scaleEvent = Number(event?.scale);
      const nextScaleEvent = Number.isFinite(scaleEvent) && scaleEvent > 0 ? scaleEvent : 1;
      const lastScaleEvent = Math.max(0.0001, Number(state.gestureZoom?.lastScale) || 1);
      state.gestureZoom.lastScale = nextScaleEvent;
      const factor = nextScaleEvent / lastScaleEvent;

      const p = canvasPointFromEvent(event);
      if (state.canvasMode === "multi") {
        const before = {
          x: (p.x - (state.multiView?.offsetX || 0)) / Math.max(state.multiView?.scale || 1, 0.0001),
          y: (p.y - (state.multiView?.offsetY || 0)) / Math.max(state.multiView?.scale || 1, 0.0001),
        };
        const next = clamp((state.multiView?.scale || 1) * factor, 0.05, 40);
        state.multiView.scale = next;
        state.multiView.offsetX = p.x - before.x * state.multiView.scale;
        state.multiView.offsetY = p.y - before.y * state.multiView.scale;
      } else {
        const before = canvasToImage(p);
        const next = clamp(state.view.scale * factor, 0.05, 40);
        state.view.scale = next;
        state.view.offsetX = p.x - before.x * state.view.scale;
        state.view.offsetY = p.y - before.y * state.view.scale;
      }
      renderHudReadout();
      scheduleVisualPromptWrite();
      requestRender();
    };
    const onGestureEnd = (event) => {
      if (!state.gestureZoom?.active) return;
      if (!shouldHandleGesture(event)) return;
      bumpInteraction({ motherHot: false, semantic: false });
      event.preventDefault();
      state.gestureZoom.active = false;
      state.gestureZoom.lastScale = 1;
    };
	    try {
      installCanvasGestureHandlers(els.overlayCanvas, {
        onGestureStart,
        onGestureChange,
        onGestureEnd,
      });
	    } catch {
	      // ignore
	    }
		}

function installDnD() {
  if (!els.canvasWrap) return;

  // Even when drag/drop import is disabled, we must still prevent the WebView's
  // default file-drop navigation (which can wipe the current session/run).
  const preventNav = (event) => {
    if (!event) return;
    event.preventDefault();
  };

  const canvasWorldPointFromClient = (clientX, clientY) => {
    const wrapRect = els.canvasWrap?.getBoundingClientRect?.();
    if (!wrapRect || !Number.isFinite(clientX) || !Number.isFinite(clientY)) return null;
    if (clientX < wrapRect.left || clientX > wrapRect.right || clientY < wrapRect.top || clientY > wrapRect.bottom) {
      return null;
    }
    const overlayRect = els.overlayCanvas?.getBoundingClientRect?.() || wrapRect;
    const css = { x: clientX - overlayRect.left, y: clientY - overlayRect.top };
    return canvasScreenCssToWorldCss(css);
  };

  const tryImportInternalDragAtClient = async (clientX, clientY, { source = "browser_drag_fallback" } = {}) => {
    const path = normalizeLocalFsPath(state.fileBrowser?.draggingPath || "");
    if (!path || !isBrowserImagePath(path)) return false;
    const world = canvasWorldPointFromClient(clientX, clientY);
    if (!world) return false;
    const result = await importLocalPathsAtCanvasPoint([path], world, {
      source,
      idPrefix: "dockdrop",
      enforceIntentLimit: true,
      focusImported: true,
    });
    if (!result?.ok) {
      showToast("Could not import dropped image.", "error", 2600);
      return false;
    }
    fileBrowserSetDragPath(null);
    return true;
  };

  let lastInternalImportAt = 0;
  try {
    window.addEventListener("dragover", preventNav, { passive: false });
    window.addEventListener(
      "drop",
      (event) => {
        preventNav(event);
        const now = Date.now();
        if (now - lastInternalImportAt < 500) {
          fileBrowserSetDragPath(null);
          return;
        }
        const clientX = Number(event?.clientX);
        const clientY = Number(event?.clientY);
        if (!Number.isFinite(clientX) || !Number.isFinite(clientY)) {
          fileBrowserSetDragPath(null);
          return;
        }
        tryImportInternalDragAtClient(clientX, clientY, { source: "browser_drag_window" }).catch(() => {});
      },
      { passive: false }
    );
  } catch {
    // ignore
  }

  function stop(event) {
    preventNav(event);
    event?.stopPropagation?.();
  }

  let browserDragDepth = 0;
  const setBrowserDragHover = (on) => {
    els.canvasWrap.classList.toggle("is-browser-drag-over", Boolean(on));
  };
  const clearBrowserDragHover = () => {
    browserDragDepth = 0;
    setBrowserDragHover(false);
  };

  try {
    window.addEventListener("dragend", clearBrowserDragHover, { passive: true });
    window.addEventListener(
      "dragend",
      (event) => {
        const clientX = Number(event?.clientX);
        const clientY = Number(event?.clientY);
        if (!Number.isFinite(clientX) || !Number.isFinite(clientY)) {
          fileBrowserClearDragPathDeferred(120);
          return;
        }
        tryImportInternalDragAtClient(clientX, clientY, { source: "browser_drag_end" })
          .catch(() => {})
          .finally(() => {
            fileBrowserClearDragPathDeferred(120);
          });
      },
      { passive: true }
    );
    window.addEventListener("drop", clearBrowserDragHover, { passive: false });
  } catch {
    // ignore
  }

  const handleDragEnter = (event) => {
    stop(event);
    const internalPath = fileBrowserReadInternalDragPath(event?.dataTransfer);
    if (internalPath) {
      browserDragDepth += 1;
      setBrowserDragHover(true);
    }
  };
  const handleDragLeave = (event) => {
    stop(event);
    const internalPath = fileBrowserReadInternalDragPath(event?.dataTransfer);
    if (!internalPath) return;
    browserDragDepth = Math.max(0, browserDragDepth - 1);
    if (!browserDragDepth) setBrowserDragHover(false);
  };
  const handleDragOver = (event) => {
    stop(event);
    const internalPath = fileBrowserReadInternalDragPath(event?.dataTransfer);
    if (internalPath) {
      if (event?.dataTransfer) event.dataTransfer.dropEffect = "copy";
      setBrowserDragHover(true);
    }
  };

  let disabledToastAt = 0;
  const handleDrop = async (event) => {
    stop(event);
    clearBrowserDragHover();
    bumpInteraction();
    const internalPath = fileBrowserReadInternalDragPath(event?.dataTransfer);
    if (internalPath) {
      const world = canvasScreenCssToWorldCss(canvasCssPointFromEvent(event));
      lastInternalImportAt = Date.now();
      const result = await importLocalPathsAtCanvasPoint([internalPath], world, {
        source: "browser_drag",
        idPrefix: "dockdrop",
        enforceIntentLimit: true,
        focusImported: true,
      });
      if (!result?.ok) {
        showToast("Could not import dropped image.", "error", 2600);
      }
      fileBrowserSetDragPath(null);
      return;
    }
    fileBrowserSetDragPath(null);
    const files = Array.from(event.dataTransfer?.files || []);
    const paths = files.map((f) => f?.path).filter(Boolean);
    if (paths.length === 0) return;
    if (!ENABLE_DRAG_DROP_IMPORT) {
      const now = Date.now();
      if (!disabledToastAt || now - disabledToastAt > 3500) {
        disabledToastAt = now;
        showToast("Drag/drop disabled. Click anywhere to add a photo.", "tip", 2400);
      }
      return;
    }
    const world = canvasScreenCssToWorldCss(canvasCssPointFromEvent(event));
    await importLocalPathsAtCanvasPoint(paths, world, {
      source: "drop",
      idPrefix: "drop",
      enforceIntentLimit: true,
    });
  };

  const dndTargets = [els.canvasWrap, els.overlayCanvas].filter(Boolean);
  for (const target of dndTargets) {
    target.addEventListener("dragenter", handleDragEnter, { passive: false });
    target.addEventListener("dragleave", handleDragLeave, { passive: false });
    target.addEventListener("dragover", handleDragOver, { passive: false });
    target.addEventListener("drop", (event) => {
      handleDrop(event).catch((err) => console.error(err));
    });
  }
}

function installUi() {
  if (els.appMenuToggle && els.appMenu) {
    const toggle = els.appMenuToggle;
    const menu = els.appMenu;

    let hideTimer = null;
    const isOpen = () => menu.classList.contains("is-open");
    const close = () => {
      menu.classList.remove("is-open");
      toggle.setAttribute("aria-expanded", "false");
      clearTimeout(hideTimer);
      hideTimer = setTimeout(() => {
        if (menu.classList.contains("is-open")) return;
        menu.classList.add("hidden");
      }, 220);
    };
    const open = () => {
      clearTimeout(hideTimer);
      menu.classList.remove("hidden");
      // Ensure the closed-state styles apply for one frame so the drawer can animate.
      requestAnimationFrame(() => {
        if (!menu.classList.contains("hidden")) menu.classList.add("is-open");
      });
      toggle.setAttribute("aria-expanded", "true");
    };

    toggle.addEventListener("click", (event) => {
      bumpInteraction();
      event?.stopPropagation?.();
      if (isOpen()) close();
      else open();
    });

    menu.addEventListener("click", (event) => {
      event?.stopPropagation?.();
      const btn = event?.target?.closest ? event.target.closest("button[data-menu-close]") : null;
      if (btn) close();
    });

    window.addEventListener(
      "click",
      (event) => {
        if (!isOpen()) return;
        const t = event?.target;
        if (t && (toggle.contains(t) || menu.contains(t))) return;
        close();
      },
      { capture: true }
    );

    window.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      if (key !== "Escape") return;
      if (!isOpen()) return;
      close();
    });
  }

  if (els.reelAdminToggle) {
    updateReelSizeButton();
    els.reelAdminToggle.addEventListener("click", () => {
      bumpInteraction();
      toggleReelSizeLock();
      ensureCanvasSize();
    });
  }

  if (!reelPresetWindowResizeAttached) {
    reelPresetWindowResizeAttached = true;
    window.addEventListener("resize", () => {
      if (!isReelSizeLocked()) return;
      setReelSizeLock(true);
      ensureCanvasSize();
    });
  }

  if (els.newRun)
    els.newRun.addEventListener("click", () => {
      bumpInteraction();
      runWithUserError("Create run", () => createRun(), {
        retryHint: "Check permissions and try again.",
      });
    });
  if (els.motherWheelMenu) {
    els.motherWheelMenu.addEventListener("click", (event) => {
      event?.stopPropagation?.();
      const btn = event?.target?.closest ? event.target.closest("button[data-action]") : null;
      if (!btn || !els.motherWheelMenu.contains(btn)) return;
      bumpInteraction();
      const action = String(btn.dataset?.action || "").trim();
      if (!action) return;
      dispatchMotherWheelAction(action).catch((err) => {
        console.error(err);
        showToast(err?.message || "Mother wheel action failed.", "error", 2400);
      });
    });

    window.addEventListener(
      "pointerdown",
      (event) => {
        if (!isMotherWheelOpen()) return;
        const target = event?.target;
        if (target && els.motherWheelMenu.contains(target)) return;
        closeMotherWheelMenu({ immediate: false });
      },
      { capture: true }
    );

    window.addEventListener("keydown", (event) => {
      if (!isMotherWheelOpen()) return;
      const key = String(event?.key || "");
      if (key === "Escape") closeMotherWheelMenu({ immediate: false });
    });
  }
  if (els.openRun)
    els.openRun.addEventListener("click", () => {
      bumpInteraction();
      runWithUserError("Open run", () => openExistingRun(), {
        retryHint: "Choose a valid run folder and retry.",
      });
    });
  if (els.import)
    els.import.addEventListener("click", () => {
      bumpInteraction();
      runWithUserError("Import photos", () => importPhotos(), {
        retryHint: "Choose supported image files and retry.",
      });
    });
  if (els.export)
    els.export.addEventListener("click", () => {
      bumpInteraction();
      runWithUserError("Export run", () => exportRun(), {
        retryHint: "Ensure the run directory is writable and retry.",
      });
    });

  if (els.motherAbilityIcon) {
    if (!els.motherAbilityIcon.textContent) {
      els.motherAbilityIcon.textContent = "â†’";
    }
    els.motherAbilityIcon.addEventListener("click", () => {
      // Cycling proposals should not invalidate intent hypothesis state.
      bumpInteraction({ semantic: false });
      const beforeMode = motherV2NormalizeTransformationMode(state.motherIdle?.intent?.transformation_mode);
      const cycled = motherV2CycleProposal(1);
      if (cycled) {
        recordUserEvent("mother_next_proposal", {});
        const idle = state.motherIdle;
        appendMotherTraceLog({
          kind: "proposal_next",
          traceId: idle?.telemetry?.traceId || null,
          actionVersion: Number(idle?.actionVersion) || 0,
          optimization_target: motherCurrentOptimizationTarget(),
          from_mode: beforeMode || null,
          to_mode: motherV2NormalizeTransformationMode(idle?.intent?.transformation_mode),
          proposal_candidates: motherV2ProposalCandidateSummary(idle?.intent || null, { limit: MOTHER_V2_MAX_RANKED_PROPOSALS }),
        }).catch(() => {});
      } else {
        const phase = state.motherIdle?.phase || motherIdleInitialState();
        if (phase !== MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING) {
          showToast("Next proposal appears during intent hypothesis.", "tip", 1800);
        } else {
          showToast("No additional proposals available.", "tip", 1600);
        }
        return;
      }
    });
  }
  if (els.motherConfirm) {
    els.motherConfirm.addEventListener("click", () => {
      startMotherTakeover().catch(() => {});
    });
  }
  if (els.motherStop) {
    els.motherStop.addEventListener("click", () => {
      stopMotherTakeover();
    });
  }
  if (els.motherMoodToggle) {
    els.motherMoodToggle.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      setMotherMoodMenuOpen(!motherMoodMenuIsOpen());
    });
  }
  if (els.motherMoodMenu) {
    els.motherMoodMenu.addEventListener("click", (event) => {
      const btn = event?.target?.closest ? event.target.closest("button[data-mood]") : null;
      if (!btn || !els.motherMoodMenu.contains(btn)) return;
      event.preventDefault();
      event.stopPropagation();
      setMotherMood(btn.dataset?.mood || "");
      setMotherMoodMenuOpen(false);
      requestRender();
    });
  }
  if (els.motherPanel) {
    els.motherPanel.addEventListener("pointerenter", () => {
      motherV2RevealHints({ engaged: false, ms: 1700 });
    });
    els.motherPanel.addEventListener("pointerleave", () => {
      if (!state.motherIdle?.advancedOpen && !state.motherIdle?.optionReveal) {
        motherV2HideHints();
      }
    });
    els.motherPanel.addEventListener("focusin", () => {
      motherV2RevealHints({ engaged: true, ms: 2100 });
    });
    els.motherPanel.addEventListener("focusout", () => {
      if (!state.motherIdle?.advancedOpen && !state.motherIdle?.optionReveal) {
        motherV2HideHints();
      }
    });
  }
  if (els.motherRefineToggle) {
    els.motherRefineToggle.addEventListener("click", () => {
      bumpInteraction();
      motherV2SetAdvancedOpen(!Boolean(state.motherIdle?.advancedOpen));
    });
  }

  const onAdvancedRoleChange = (roleKey, value) => {
    const idle = state.motherIdle;
    if (!idle || !MOTHER_V2_ROLE_KEYS.includes(roleKey)) return;
    const imageId = String(value || "").trim();
    const nextIds = imageId && state.imagesById.has(imageId) ? [imageId] : [];
    motherV2SetRoleIds(roleKey, nextIds);
    if (idle.intent && typeof idle.intent === "object") {
      idle.intent.roles = motherV2RoleMapClone();
    }
    motherV2InvalidateOfferingForStructureEdit("advanced_role_edit");
    motherV2RevealHints({ engaged: true, ms: 1800 });
    renderMotherReadout();
    requestRender();
  };

  if (els.motherRoleSubject) {
    els.motherRoleSubject.addEventListener("change", () => onAdvancedRoleChange("subject", els.motherRoleSubject.value));
  }
  if (els.motherRoleModel) {
    els.motherRoleModel.addEventListener("change", () => onAdvancedRoleChange("model", els.motherRoleModel.value));
  }
  if (els.motherRoleMediator) {
    els.motherRoleMediator.addEventListener("change", () => onAdvancedRoleChange("mediator", els.motherRoleMediator.value));
  }
  if (els.motherRoleObject) {
    els.motherRoleObject.addEventListener("change", () => onAdvancedRoleChange("object", els.motherRoleObject.value));
  }
  if (els.motherTransformationMode) {
    els.motherTransformationMode.addEventListener("change", () => {
      const idle = state.motherIdle;
      if (!idle || !idle.intent || typeof idle.intent !== "object") return;
      const mode = motherV2NormalizeTransformationMode(els.motherTransformationMode.value);
      idle.intent.transformation_mode = mode;
      idle.intent.summary = motherV2ProposalSentence(idle.intent);
      motherV2InvalidateOfferingForStructureEdit("advanced_mode_edit");
      motherV2RevealHints({ engaged: true, ms: 1800 });
      renderMotherReadout();
      requestRender();
    });
  }
  window.addEventListener("keydown", (event) => {
    if (String(event?.key || "") !== "Alt") return;
    if (event.metaKey || event.ctrlKey) return;
    const target = event?.target;
    const tag = target?.tagName ? String(target.tagName).toLowerCase() : "";
    const isEditable = Boolean(
      target &&
        (target.isContentEditable ||
          tag === "input" ||
          tag === "textarea" ||
          tag === "select")
    );
    if (isEditable) return;
    wheelForcePanHeld = true;
  });
  window.addEventListener("keyup", (event) => {
    if (String(event?.key || "") !== "Alt") return;
    wheelForcePanHeld = false;
  });
  window.addEventListener("keydown", (event) => {
    const key = String(event?.key || "").toLowerCase();
    if (key !== MOTHER_OPTION_REVEAL_HOLD_KEY) return;
    if (event.metaKey || event.ctrlKey || event.altKey) return;
    const target = event?.target;
    const tag = target?.tagName ? String(target.tagName).toLowerCase() : "";
    const isEditable = Boolean(
      target &&
        (target.isContentEditable ||
          tag === "input" ||
          tag === "textarea" ||
          tag === "select")
    );
    if (isEditable) return;
    const idle = state.motherIdle;
    if (!idle) return;
    if (idle.optionReveal) return;
    idle.optionReveal = true;
    motherV2RevealHints({ engaged: true, ms: 1800 });
    renderMotherReadout();
    requestRender();
  });
  window.addEventListener("keyup", (event) => {
    const key = String(event?.key || "").toLowerCase();
    if (key !== MOTHER_OPTION_REVEAL_HOLD_KEY) return;
    const idle = state.motherIdle;
    if (!idle) return;
    idle.optionReveal = false;
    if (!idle.advancedOpen) {
      motherV2HideHints({ immediate: true });
    }
    renderMotherReadout();
    requestRender();
  });
  window.addEventListener("blur", () => {
    wheelForcePanHeld = false;
    const idle = state.motherIdle;
    if (!idle) return;
    idle.optionReveal = false;
    if (!idle.advancedOpen) {
      motherV2HideHints({ immediate: true });
    }
  });

  if (els.canvasContextSuggestBtn) {
    els.canvasContextSuggestBtn.addEventListener("click", () => {
      bumpInteraction();
      const rec = state.canvasContextSuggestion;
      if (!rec?.action) return;
      triggerCanvasContextSuggestedAction(rec.action).catch((err) => {
        const msg = err?.message || String(err);
        showToast(msg, "error", 2600);
      });
    });
  }

  if (els.dropHint) {
    const openPicker = (event) => {
      if (els.dropHint.classList.contains("hidden")) return;
      event?.preventDefault?.();
      event?.stopPropagation?.();
      const ptCss =
        event && typeof event.clientX === "number" && typeof event.clientY === "number" && els.canvasWrap
          ? (() => {
              const rect = els.canvasWrap.getBoundingClientRect();
              return { x: event.clientX - rect.left, y: event.clientY - rect.top };
            })()
          : _defaultImportPointCss();
      const opened = openMotherWheelMenuAt(ptCss);
      if (opened) {
        recordUserEvent("mother_wheel_open", {
          x: Math.round(Number(ptCss.x) || 0),
          y: Math.round(Number(ptCss.y) || 0),
        });
      }
    };
    els.dropHint.addEventListener("click", openPicker);
    els.dropHint.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      if (key === "Enter" || key === " ") {
        openPicker(event);
      }
    });
  }

  if (els.settingsToggle && els.settingsDrawer) {
    els.settingsToggle.addEventListener("click", () => {
      bumpInteraction();
      els.settingsDrawer.classList.remove("hidden");
      refreshKeyStatus().catch(() => {});
      refreshPortraitsDirReadout().catch(() => {});
      renderAestheticOnboardingStatus();
      promptBenchmarkRenderReadout();
    });
  }
  if (els.settingsClose && els.settingsDrawer) {
    els.settingsClose.addEventListener("click", () => {
      bumpInteraction();
      els.settingsDrawer.classList.add("hidden");
    });
  }
  if (els.aestheticOnboardingOpen) {
    els.aestheticOnboardingOpen.addEventListener("click", () => {
      bumpInteraction();
      if (els.settingsDrawer) els.settingsDrawer.classList.add("hidden");
      openAestheticOnboardingModal({ force: true, source: "settings" });
    });
  }
  if (els.openrouterOnboardingOpen) {
    els.openrouterOnboardingOpen.addEventListener("click", () => {
      bumpInteraction();
      if (els.settingsDrawer) els.settingsDrawer.classList.add("hidden");
      openOpenRouterOnboardingModal({ force: true, source: "settings" });
    });
  }
  if (els.openrouterOnboardingReset) {
    els.openrouterOnboardingReset.addEventListener("click", () => {
      bumpInteraction();
      clearOpenRouterOnboardingProfile();
      renderOpenRouterOnboardingStatus();
      showToast("OpenRouter onboarding state cleared.", "tip", 2200);
    });
  }
  if (els.aestheticOnboardingClear) {
    els.aestheticOnboardingClear.addEventListener("click", () => {
      bumpInteraction();
      clearAestheticOnboardingProfile();
      renderAestheticOnboardingStatus();
      showToast("Aesthetic preference cleared.", "tip", 2200);
    });
  }
  if (els.openrouterOnboardingBody) {
    els.openrouterOnboardingBody.addEventListener("click", (event) => {
      const btn = event?.target?.closest ? event.target.closest("[data-openrouter-action]") : null;
      if (!btn || !els.openrouterOnboardingBody.contains(btn)) return;
      const action = String(btn.dataset?.openrouterAction || "").trim();
      if (action === "save") {
        bumpInteraction();
        submitOpenRouterOnboardingKey().catch((err) => {
          console.error(err);
        });
      }
    });
    els.openrouterOnboardingBody.addEventListener("input", (event) => {
      const target = event?.target;
      if (!target || target.id !== "openrouter-onboarding-key-input") return;
      openrouterOnboardingState.draft.apiKey = String(target.value || "");
    });
    els.openrouterOnboardingBody.addEventListener("keydown", (event) => {
      const target = event?.target;
      if (!target || target.id !== "openrouter-onboarding-key-input") return;
      const key = String(event?.key || "");
      if (key !== "Enter") return;
      event.preventDefault();
      bumpInteraction();
      submitOpenRouterOnboardingKey().catch((err) => {
        console.error(err);
      });
    });
  }
  if (els.openrouterOnboardingBack) {
    els.openrouterOnboardingBack.addEventListener("click", () => {
      bumpInteraction();
      if (!openrouterOnboardingState.open || openrouterOnboardingState.stepIndex <= 0) return;
      openrouterOnboardingState.stepIndex -= 1;
      openrouterOnboardingState.statusMessage = "";
      openrouterOnboardingState.statusError = false;
      renderOpenRouterOnboardingStep({ animate: true });
    });
  }
  if (els.openrouterOnboardingNext) {
    els.openrouterOnboardingNext.addEventListener("click", () => {
      bumpInteraction();
      handleOpenRouterOnboardingNextAction();
    });
  }
  if (els.openrouterOnboardingSkip) {
    els.openrouterOnboardingSkip.addEventListener("click", (event) => {
      event.preventDefault();
      if (openrouterOnboardingState.submitting) return;
      bumpInteraction();
      skipOpenRouterOnboarding();
    });
  }
  if (els.openrouterOnboardingClose) {
    els.openrouterOnboardingClose.addEventListener("click", () => {
      bumpInteraction();
      if (openrouterOnboardingState.stepIndex >= 2) {
        closeOpenRouterOnboardingModal();
      } else {
        skipOpenRouterOnboarding();
      }
    });
  }
  if (els.openrouterOnboardingModal) {
    els.openrouterOnboardingModal.addEventListener("pointerdown", (event) => {
      if (event?.target !== els.openrouterOnboardingModal) return;
      bumpInteraction();
      if (openrouterOnboardingState.stepIndex >= 2) {
        closeOpenRouterOnboardingModal();
      } else {
        skipOpenRouterOnboarding();
      }
    });
  }
  if (els.aestheticOnboardingBody) {
    els.aestheticOnboardingBody.addEventListener("click", (event) => {
      const btn = event?.target?.closest ? event.target.closest("[data-aesthetic-select][data-aesthetic-value]") : null;
      if (!btn || !els.aestheticOnboardingBody.contains(btn)) return;
      const answerKey = String(btn.dataset?.aestheticSelect || "").trim();
      const answerValue = String(btn.dataset?.aestheticValue || "").trim();
      if (!answerKey || !answerValue) return;
      if (!(answerKey in aestheticOnboardingState.answers)) return;
      aestheticOnboardingState.answers[answerKey] = answerValue;
      renderAestheticOnboardingStep({ animate: false });
    });
  }
  if (els.aestheticOnboardingBack) {
    els.aestheticOnboardingBack.addEventListener("click", () => {
      bumpInteraction();
      if (!aestheticOnboardingState.open || aestheticOnboardingState.stepIndex <= 0) return;
      aestheticOnboardingState.stepIndex -= 1;
      renderAestheticOnboardingStep({ animate: true });
    });
  }
  if (els.aestheticOnboardingNext) {
    els.aestheticOnboardingNext.addEventListener("click", () => {
      bumpInteraction();
      if (!aestheticOnboardingState.open || aestheticOnboardingState.applying) return;
      if (aestheticOnboardingState.stepIndex < 3) {
        if (!canAdvanceAestheticStep(aestheticOnboardingState.stepIndex)) return;
        aestheticOnboardingState.stepIndex += 1;
        renderAestheticOnboardingStep({ animate: true });
        return;
      }
      finalizeAestheticOnboarding({ applyRecommendation: true }).catch((err) => {
        console.error(err);
        showToast(err?.message || "Could not apply aesthetic model.", "error", 2600);
      });
    });
  }
  if (els.aestheticOnboardingSkip) {
    els.aestheticOnboardingSkip.addEventListener("click", () => {
      bumpInteraction();
      skipAestheticOnboarding();
    });
  }
  if (els.aestheticOnboardingClose) {
    els.aestheticOnboardingClose.addEventListener("click", () => {
      bumpInteraction();
      skipAestheticOnboarding();
    });
  }
  if (els.aestheticOnboardingModal) {
    els.aestheticOnboardingModal.addEventListener("pointerdown", (event) => {
      if (event?.target !== els.aestheticOnboardingModal) return;
      bumpInteraction();
      skipAestheticOnboarding();
    });
  }
  renderOpenRouterOnboardingStatus();
  renderAestheticOnboardingStatus();

  if (els.portraitsDirPick) {
    els.portraitsDirPick.addEventListener("click", () => {
      pickPortraitsDir().catch((e) => console.error(e));
    });
  }
  if (els.portraitsDirClear) {
    els.portraitsDirClear.addEventListener("click", () => {
      bumpInteraction();
      localStorage.removeItem(PORTRAITS_DIR_LS_KEY);
      clearPortraitsDirOnDisk().catch(() => {});
      invalidatePortraitMediaCache();
      renderPortraitsDirReadout();
      ensurePortraitIndex().catch(() => {});
      updatePortraitIdle({ fromSettings: true });
    });
  }

  if (els.timelineToggle) {
    els.timelineToggle.addEventListener("click", () => {
      bumpInteraction();
      openTimeline();
    });
  }
  if (els.timelineClose) {
    els.timelineClose.addEventListener("click", () => {
      bumpInteraction();
      closeTimeline();
    });
  }
  if (els.timelineOverlay) {
    els.timelineOverlay.addEventListener("pointerdown", (event) => {
      if (event?.target === els.timelineOverlay) {
        bumpInteraction();
        closeTimeline();
      }
    });
  }
  if (els.timelineStrip) {
    els.timelineStrip.addEventListener("click", (event) => {
      const card = event?.target?.closest ? event.target.closest(".timeline-card[data-node-id]") : null;
      if (!card || !els.timelineStrip.contains(card)) return;
      const nodeId = card.dataset?.nodeId;
      if (!nodeId) return;
      bumpInteraction();
      jumpToTimelineNode(nodeId).catch((err) => console.error(err));
    });
    els.timelineStrip.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      if (key !== "Enter" && key !== " ") return;
      const card = event?.target?.closest ? event.target.closest(".timeline-card[data-node-id]") : null;
      if (!card || !els.timelineStrip.contains(card)) return;
      const nodeId = card.dataset?.nodeId;
      if (!nodeId) return;
      event.preventDefault();
      bumpInteraction();
      jumpToTimelineNode(nodeId).catch((err) => console.error(err));
    });
  }

  if (els.memoryToggle) {
    els.memoryToggle.checked = settings.memory;
    els.memoryToggle.addEventListener("change", () => {
      bumpInteraction();
      settings.memory = els.memoryToggle.checked;
      localStorage.setItem("brood.memory", settings.memory ? "1" : "0");
      setStatus("Engine: memory applies next run");
    });
  }
  if (els.alwaysOnVisionToggle) {
    els.alwaysOnVisionToggle.checked = settings.alwaysOnVision;
    if (!ALWAYS_ON_CANVAS_CONTEXT_ENABLED) {
      els.alwaysOnVisionToggle.checked = false;
      els.alwaysOnVisionToggle.disabled = true;
      els.alwaysOnVisionToggle.title = "Always-on canvas context is disabled. Mother intent realtime remains active.";
      settings.alwaysOnVision = false;
      if (state.alwaysOnVision) {
        state.alwaysOnVision.enabled = false;
        state.alwaysOnVision.pending = false;
        state.alwaysOnVision.pendingPath = null;
        state.alwaysOnVision.pendingAt = 0;
        state.alwaysOnVision.contentDirty = false;
        state.alwaysOnVision.dirtyReason = null;
        state.alwaysOnVision.disabledReason = null;
        state.alwaysOnVision.rtState = "off";
        state.alwaysOnVision.lastText = null;
      }
      state.canvasContextSuggestion = null;
      updateAlwaysOnVisionReadout();
      renderQuickActions();
    } else {
      els.alwaysOnVisionToggle.disabled = false;
      els.alwaysOnVisionToggle.title = "";
      els.alwaysOnVisionToggle.addEventListener("change", () => {
        bumpInteraction();
        settings.alwaysOnVision = els.alwaysOnVisionToggle.checked;
        localStorage.setItem("brood.alwaysOnVision", settings.alwaysOnVision ? "1" : "0");
        if (state.alwaysOnVision) {
          state.alwaysOnVision.enabled = settings.alwaysOnVision;
          state.alwaysOnVision.pending = false;
          state.alwaysOnVision.pendingPath = null;
          state.alwaysOnVision.pendingAt = 0;
          state.alwaysOnVision.contentDirty = false;
          state.alwaysOnVision.dirtyReason = null;
          state.alwaysOnVision.disabledReason = null;
          state.alwaysOnVision.rtState = settings.alwaysOnVision ? "connecting" : "off";
          if (!settings.alwaysOnVision) state.alwaysOnVision.lastText = null;
        }
        state.canvasContextSuggestion = null;
        updateAlwaysOnVisionReadout();
        renderQuickActions();
        if (settings.alwaysOnVision) {
          setStatus("Engine: always-on vision enabled");
          markAlwaysOnVisionDirty("aov_enable");
          ensureEngineSpawned({ reason: "always-on vision" })
            .then((ok) => {
              if (!ok) return;
              return invoke("write_pty", { data: `${PTY_COMMANDS.CANVAS_CONTEXT_RT_START}\n` }).catch(() => {});
            })
            .catch(() => {});
          scheduleAlwaysOnVision({ immediate: true });
        } else {
          setStatus("Engine: always-on vision disabled");
          updatePortraitIdle({ fromSettings: true });
          if (state.ptySpawned) {
            invoke("write_pty", { data: `${PTY_COMMANDS.CANVAS_CONTEXT_RT_STOP}\n` }).catch(() => {});
          }
        }
      });
    }
  }
  if (els.autoAcceptSuggestedAbilityToggle) {
    els.autoAcceptSuggestedAbilityToggle.checked = settings.autoAcceptSuggestedAbility;
    els.autoAcceptSuggestedAbilityToggle.addEventListener("change", () => {
      bumpInteraction();
      settings.autoAcceptSuggestedAbility = els.autoAcceptSuggestedAbilityToggle.checked;
      localStorage.setItem("brood.autoAcceptSuggestedAbility", settings.autoAcceptSuggestedAbility ? "1" : "0");
      if (state.autoAcceptSuggestedAbility) {
        state.autoAcceptSuggestedAbility.enabled = settings.autoAcceptSuggestedAbility;
        state.autoAcceptSuggestedAbility.passes = 0;
        state.autoAcceptSuggestedAbility.lastAcceptedAt = 0;
        state.autoAcceptSuggestedAbility.inFlight = false;
      }
      // If there's already a suggestion visible, the next render will auto-accept.
      renderCanvasContextSuggestion();
    });
  }
  if (els.textModel) {
    els.textModel.value = settings.textModel;
    els.textModel.addEventListener("change", () => {
      bumpInteraction();
      settings.textModel = els.textModel.value;
      localStorage.setItem("brood.textModel", settings.textModel);
      updatePortraitIdle({ fromSettings: true });
      if (state.ptySpawned) {
        invoke("write_pty", { data: `${PTY_COMMANDS.TEXT_MODEL} ${settings.textModel}\n` }).catch(() => {});
      }
    });
  }
  if (els.imageModel) {
    els.imageModel.value = settings.imageModel;
    els.imageModel.addEventListener("change", () => {
      bumpInteraction();
      applyImageModelSetting(els.imageModel.value, { announce: false }).catch(() => {});
    });
  }
  if (els.promptStrategyMode) {
    els.promptStrategyMode.value = normalizePromptStrategyMode(settings.promptStrategyMode);
    els.promptStrategyMode.addEventListener("change", () => {
      bumpInteraction();
      settings.promptStrategyMode = normalizePromptStrategyMode(els.promptStrategyMode.value);
      localStorage.setItem(PROMPT_STRATEGY_MODE_KEY, settings.promptStrategyMode);
      if (els.promptStrategyMode.value !== settings.promptStrategyMode) {
        els.promptStrategyMode.value = settings.promptStrategyMode;
      }
      promptBenchmarkRenderReadout();
    });
  }
  if (els.promptRepeatFullToggle) {
    els.promptRepeatFullToggle.checked = Boolean(settings.promptRepeatFull);
    els.promptRepeatFullToggle.addEventListener("change", () => {
      bumpInteraction();
      settings.promptRepeatFull = Boolean(els.promptRepeatFullToggle.checked);
      localStorage.setItem(PROMPT_REPEAT_FULL_KEY, settings.promptRepeatFull ? "1" : "0");
      promptBenchmarkRenderReadout();
    });
  }
  if (els.promptBenchmarkReset) {
    els.promptBenchmarkReset.addEventListener("click", () => {
      bumpInteraction();
      promptBenchmarkReset();
      showToast("Prompt benchmark cleared.", "tip", 1600);
    });
  }
  promptBenchmarkRenderReadout();

  if (els.annotateClose) {
    els.annotateClose.addEventListener("click", () => {
      bumpInteraction();
      state.annotateDraft = null;
      state.annotateBox = null;
      hideAnnotatePanel();
      scheduleVisualPromptWrite();
      requestRender();
    });
  }
  if (els.annotateCancel) {
    els.annotateCancel.addEventListener("click", () => {
      bumpInteraction();
      state.annotateDraft = null;
      state.annotateBox = null;
      hideAnnotatePanel();
      scheduleVisualPromptWrite();
      requestRender();
    });
  }
  if (els.annotateSend) {
    els.annotateSend.addEventListener("click", () => {
      aiAnnotateEdit().catch((e) => console.error(e));
    });
  }
  if (els.annotateText) {
    els.annotateText.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      const mod = Boolean(event?.metaKey || event?.ctrlKey);
      if (mod && key === "Enter") {
        event.preventDefault();
        aiAnnotateEdit().catch((e) => console.error(e));
      }
    });
  }

  if (els.promptGenerateClose) {
    els.promptGenerateClose.addEventListener("click", () => {
      bumpInteraction();
      hidePromptGeneratePanel();
    });
  }
  if (els.promptGenerateCancel) {
    els.promptGenerateCancel.addEventListener("click", () => {
      bumpInteraction();
      hidePromptGeneratePanel();
    });
  }
  if (els.promptGenerateSend) {
    els.promptGenerateSend.addEventListener("click", () => {
      runPromptGenerateFromPanel().catch((e) => console.error(e));
    });
  }
  if (els.promptGenerateModel) {
    els.promptGenerateModel.addEventListener("change", () => {
      capturePromptGenerateDraftFromUi();
    });
  }
  if (els.promptGenerateText) {
    els.promptGenerateText.addEventListener("input", () => {
      capturePromptGenerateDraftFromUi();
    });
    els.promptGenerateText.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      const mod = Boolean(event?.metaKey || event?.ctrlKey);
      if (mod && key === "Enter") {
        event.preventDefault();
        runPromptGenerateFromPanel().catch((e) => console.error(e));
      }
    });
  }

  if (els.markClose) {
    els.markClose.addEventListener("click", () => {
      bumpInteraction();
      hideMarkPanel();
      requestRender();
    });
  }
  if (els.markSave) {
    els.markSave.addEventListener("click", () => {
      bumpInteraction();
      updateActiveCircleLabel(String(els.markText?.value || ""));
      hideMarkPanel();
      requestRender();
      showToast("Circle label saved.", "tip", 1400);
    });
  }
  if (els.markDelete) {
    els.markDelete.addEventListener("click", () => {
      bumpInteraction();
      const ok = deleteActiveCircle();
      if (ok) showToast("Circle deleted.", "tip", 1400);
    });
  }
  if (els.markText) {
    els.markText.addEventListener("keydown", (event) => {
      const key = String(event?.key || "");
      const mod = Boolean(event?.metaKey || event?.ctrlKey);
      if (mod && key === "Enter") {
        event.preventDefault();
        updateActiveCircleLabel(String(els.markText?.value || ""));
        hideMarkPanel();
        requestRender();
        showToast("Circle label saved.", "tip", 1400);
      }
    });
  }

  if (els.imageMenu) {
    els.imageMenu.addEventListener("click", (event) => {
      const btn = event?.target?.closest ? event.target.closest("button[data-action]") : null;
      if (!btn || !els.imageMenu.contains(btn)) return;
      bumpInteraction();
      const action = btn.dataset?.action;
      if (!action) return;
      if (action === "cancel") {
        hideImageMenu();
        return;
      }
      if (action === "remove") {
        const targetId = state.imageMenuTargetId;
        hideImageMenu();
        if (targetId) {
          removeImageFromCanvas(targetId).catch((err) => console.error(err));
        }
      }
    });
  }

  document.addEventListener("pointerdown", (event) => {
    if (!els.imageMenu || els.imageMenu.classList.contains("hidden")) return;
    const hit = event?.target?.closest ? event.target.closest("#image-menu") : null;
    if (hit) return;
    hideImageMenu();
  });

  document.addEventListener("pointerdown", (event) => {
    if (!els.promptGeneratePanel || els.promptGeneratePanel.classList.contains("hidden")) return;
    const hit = event?.target?.closest ? event.target.closest("#prompt-generate-panel") : null;
    if (hit) return;
    hidePromptGeneratePanel();
  });

  document.addEventListener("pointerdown", (event) => {
    if (!motherMoodMenuIsOpen()) return;
    const hit = event?.target?.closest ? event.target.closest("#canvas-mood-status") : null;
    if (hit) return;
    setMotherMoodMenuOpen(false);
  });

  if (els.filmstrip) {
    els.filmstrip.addEventListener("click", (event) => {
      const thumb = event?.target?.closest ? event.target.closest(".thumb") : null;
      if (!thumb || !els.filmstrip.contains(thumb)) return;
      const id = thumb.dataset?.id;
      if (!id) return;
      bumpInteraction({ semantic: false });
      setActiveImage(id).catch(() => {});
    });
  }

  document.addEventListener("keydown", (event) => {
    const rawKey = String(event?.key || "");
    const key = rawKey.toLowerCase();
    if (key === "escape" && motherMoodMenuIsOpen()) {
      setMotherMoodMenuOpen(false);
      return;
    }
    const target = event?.target;
    const tag = target?.tagName ? String(target.tagName).toLowerCase() : "";
    const isEditable = Boolean(
      target &&
        (target.isContentEditable ||
          tag === "input" ||
          tag === "textarea" ||
          tag === "select")
    );
    const hasModifier = Boolean(event?.metaKey || event?.ctrlKey || event?.altKey);

		    if (key === "escape") {
		      if (state.motherIdle?.offerDetailsOpen || state.motherResultDetailsOpenId) {
		        motherCloseOverlayDetails();
		        requestRender();
		        return;
		      }
		      if (aestheticOnboardingState.open) {
		        skipAestheticOnboarding();
		        return;
		      }
		      if (isMotherWheelOpen()) {
		        closeMotherWheelMenu({ immediate: false });
		        return;
		      }
		      if (els.settingsDrawer && !els.settingsDrawer.classList.contains("hidden")) {
		        els.settingsDrawer.classList.add("hidden");
		        return;
		      }
	        if (els.markPanel && !els.markPanel.classList.contains("hidden")) {
	          hideMarkPanel();
	          requestRender();
	          return;
	        }
	        if (els.imageMenu && !els.imageMenu.classList.contains("hidden")) {
	          hideImageMenu();
	          return;
	        }
		      if (els.annotatePanel && !els.annotatePanel.classList.contains("hidden")) {
		        state.annotateDraft = null;
		        state.annotateBox = null;
		        hideAnnotatePanel();
	          scheduleVisualPromptWrite();
		        requestRender();
		        return;
		      }
          if (els.promptGeneratePanel && !els.promptGeneratePanel.classList.contains("hidden")) {
            hidePromptGeneratePanel();
            return;
          }
		      clearSelection();
		      return;
		    }

	    if (aestheticOnboardingState.open) return;

		    if (isEditable || hasModifier) return;

      if (rawKey === "ArrowLeft" || rawKey === "ArrowRight" || rawKey === "ArrowUp" || rawKey === "ArrowDown") {
        if (!state.images || state.images.length === 0) return;
        bumpInteraction({ semantic: false });
        event.preventDefault();
        const dpr = getDpr();
        const baseStep = Math.round(40 * dpr);
        const step = event.shiftKey ? baseStep * 3 : baseStep;
        let dx = 0;
        let dy = 0;
        if (rawKey === "ArrowLeft") dx = step;
        if (rawKey === "ArrowRight") dx = -step;
        if (rawKey === "ArrowUp") dy = step;
        if (rawKey === "ArrowDown") dy = -step;
        if (state.canvasMode === "multi") {
          state.multiView.offsetX = (Number(state.multiView?.offsetX) || 0) + dx;
          state.multiView.offsetY = (Number(state.multiView?.offsetY) || 0) + dy;
        } else {
          state.view.offsetX = (Number(state.view?.offsetX) || 0) + dx;
          state.view.offsetY = (Number(state.view?.offsetY) || 0) + dy;
        }
        renderHudReadout();
        requestRender();
        return;
      }

      if (state.mother?.running) {
        const motherBlockedShortcut =
          key === "backspace" ||
          key === "delete" ||
          key === "l" ||
          key === "v" ||
          key === "b" ||
          key === "r" ||
          key === "m" ||
          key === "f" ||
          key === "x" ||
          key === "j" ||
          /^[1-9]$/.test(rawKey);
        if (motherBlockedShortcut) {
          showToast("Mother is running. Click Stop to regain control.", "tip", 2200);
        }
        return;
      }

      const motherPhase = state.motherIdle?.phase || motherIdleInitialState();
      const motherUndoAvailable = motherV2CommitUndoAvailable();
      if (key === "v") {
        if (
          motherPhase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING ||
          motherPhase === MOTHER_IDLE_STATES.OFFERING
        ) {
          event.preventDefault();
          startMotherTakeover().catch(() => {});
          return;
        }
      }
      if (key === "m") {
        if (
          motherUndoAvailable ||
          motherPhase === MOTHER_IDLE_STATES.INTENT_HYPOTHESIZING ||
          motherPhase === MOTHER_IDLE_STATES.OFFERING ||
          motherPhase === MOTHER_IDLE_STATES.DRAFTING
        ) {
          event.preventDefault();
          stopMotherTakeover();
          return;
        }
      }
      if (key === "r" && motherPhase === MOTHER_IDLE_STATES.OFFERING) {
        event.preventDefault();
        const idle = state.motherIdle;
        if (idle) {
          for (const draft of Array.isArray(idle.drafts) ? idle.drafts : []) {
            if (draft?.path) removeFile(String(draft.path)).catch(() => {});
            if (draft?.receiptPath) removeFile(String(draft.receiptPath)).catch(() => {});
          }
          idle.drafts = [];
          idle.selectedDraftId = null;
          idle.hoverDraftId = null;
          motherV2ForcePhase(MOTHER_IDLE_STATES.DRAFTING, "reroll");
          motherIdleDispatchGeneration().catch((err) => {
            motherIdleHandleGenerationFailed(err?.message || "Mother reroll failed.");
          });
        }
        return;
      }

      if (key === "backspace" || key === "delete") {
	      if (state.activeCircle) {
	        const ok = deleteActiveCircle();
	        if (ok) showToast("Circle deleted.", "tip", 1400);
	        return;
      }

      const activeId = String(state.activeId || "").trim();
      const selected = getSelectedIds().filter(Boolean);
      const unique = Array.from(new Set(selected.map((v) => String(v || "").trim()).filter(Boolean)));
      if (!unique.length) return;

      event.preventDefault();
      // Remove non-active selections first to avoid thrashing the engine's active-image state.
      const ordered = activeId ? unique.filter((id) => id !== activeId).concat([activeId]) : unique;
      Promise.resolve()
        .then(async () => {
          for (const id of ordered) {
            await removeImageFromCanvas(id).catch(() => {});
          }
        })
        .catch(() => {});
      return;
    }

	    // HUD action grid 1-9.
	    if (/^[1-9]$/.test(rawKey)) {
        if (intentModeActive()) return;
	      const digit = rawKey;
	      const btn = document.querySelector(`.action-grid .tool[data-hotkey="${digit}"]`);
	      if (btn) {
        btn.click();
        return;
      }
    }

    if (key === "l") {
      if (intentModeActive()) return;
      setTool("lasso");
      return;
    }
    if (key === "x") {
      runWithUserError("Extract DNA", () => runExtractDnaFromSelection(), {
        statusScope: "Director",
        retryHint: "Select at least one image and retry.",
      });
      return;
    }
    if (key === "j") {
      runWithUserError("Soul Leech", () => runSoulLeechFromSelection(), {
        statusScope: "Director",
        retryHint: "Select at least one image and retry.",
      });
      return;
    }
    if (key === "v") {
      setTool("pan");
      return;
    }
    if (key === "b") {
      runWithUserError("Background replace", () => applyBackground("white"), {
        retryHint: "Select an image and try again.",
      });
      return;
    }
    if (key === "r") {
      if (event.shiftKey) {
        runWithUserError("Recast", () => runRecast(), {
          retryHint: "Select an image and retry.",
        });
      } else {
        runWithUserError("Variations", () => runVariations(), {
          retryHint: "Select an image and retry.",
        });
      }
      return;
    }
    if (key === "m") {
      if (intentModeActive()) {
        showToast("Intent Mode: Multi view only (until intent is locked).", "tip", 2200);
        return;
      }
      if (state.images.length < 1) {
        showToast("Import photos to arrange the canvas.", "tip", 2000);
        return;
      }
      setCanvasMode("multi");
      showToast("Multi canvas mode.", "tip", 1400);
      return;
    }
    if (key === "f") {
      resetViewToFit();
      return;
    }
  });
}

async function boot() {
  if (!els.workCanvas || !els.overlayCanvas || !els.effectsCanvas) {
    setStatus("Engine: UI error (missing canvas)", true);
    return;
  }

  setStatus("Engine: bootingâ€¦");
  setRunInfo("No run");
  ensureIntentUiIconsLoaded().catch(() => {});
  refreshKeyStatus().catch(() => {});
  updateAlwaysOnVisionReadout();
  renderQuickActions();
  renderSessionApiCallsReadout();
  clearInterval(topMetricsTickTimer);
  topMetricsTickTimer = setInterval(() => {
    renderSessionApiCallsReadout();
  }, 15_000);
  syncBrandStripHeightVar();
  if (typeof ResizeObserver === "function" && els.brandStrip) {
    try {
      if (brandStripResizeObserver) brandStripResizeObserver.disconnect();
      brandStripResizeObserver = new ResizeObserver(() => {
        syncBrandStripHeightVar();
      });
      brandStripResizeObserver.observe(els.brandStrip);
      requestAnimationFrame(() => syncBrandStripHeightVar());
    } catch {
      // ignore
    }
  }
  ensurePortraitIndex().catch(() => {});
  updatePortraitIdle({ fromSettings: true });
  syncIntentModeClass();
  updateEmptyCanvasHint();
  renderSelectionMeta();
  chooseSpawnNodes();
  renderFilmstrip();
  ensureCanvasSize();
  effectsRuntime = createEffectsRuntime({ canvas: els.effectsCanvas });
  effectsRuntime.resize({
    width: els.workCanvas.width,
    height: els.workCanvas.height,
    dpr: getDpr(),
  });
  effectsRuntime.setSuspended(document.hidden || state.canvasMode !== "multi");
  // Keep decorative canvas bumpers matched to the HUD height.
  const hudShell = els.hud ? els.hud.querySelector(".hud-shell") : null;
  if (typeof ResizeObserver === "function" && (hudShell || els.hud)) {
    try {
      if (hudResizeObserver) hudResizeObserver.disconnect();
      hudResizeObserver = new ResizeObserver(() => {
        syncHudHeightVar();
      });
      hudResizeObserver.observe(hudShell || els.hud);
      requestAnimationFrame(() => syncHudHeightVar());
    } catch {
      // ignore
    }
  }
  installDprWatcher();

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
      stopLarvaAnimator();
      stopMotherGlitchLoop();
    } else {
      ensureLarvaAnimator();
      startMotherGlitchLoop();
    }
    if (effectsRuntime) {
      effectsRuntime.setSuspended(document.hidden || state.canvasMode !== "multi");
    }
  });

  new ResizeObserver(() => {
    ensureCanvasSize();
    scheduleVisualPromptWrite();
    requestRender();
  }).observe(els.canvasWrap);

  installCanvasHandlers();
  installDnD();
  installUi();
  renderMotherMoodStatus();
  setMotherMoodMenuOpen(false);
  if (ENABLE_FILE_BROWSER_DOCK) {
    await initializeFileBrowserDock();
  }
  startMotherGlitchLoop();
  startSpawnTimer();

  const handleEnginePtyExit = async () => {
    try {
      const status = await invoke("get_pty_status");
      if (status?.running) {
        if (state.pendingPtyExit) {
          state.pendingPtyExit = false;
        }
        console.info("[brood] ignored stale pty-exit while PTY remains running");
        return;
      }
    } catch (_) {
      // Best-effort stale-exit guard; fall back to existing handling if unavailable.
    }

    if (state.ptySpawning) {
      state.pendingPtyExit = true;
      console.info("[brood] deferred pty-exit while spawn is in progress");
      return;
    }
    state.pendingPtyExit = false;
    setStatus("Engine: exited", true);
    state.ptySpawned = false;
    resetDescribeQueue({ clearPending: true });
    state.expectingArtifacts = false;
    state.pendingBlend = null;
    state.pendingSwapDna = null;
    state.pendingBridge = null;
    state.pendingExtractDna = null;
    state.pendingSoulLeech = null;
    state.pendingRecast = null;
    state.pendingCreateLayers = null;
    state.pendingPromptGenerate = null;
    for (const [tokenId] of state.effectTokenApplyLocks.entries()) {
      const token = state.effectTokensById.get(tokenId) || null;
      if (token) recoverEffectTokenApply(token);
    }
    state.effectTokenApplyLocks.clear();
    clearPendingReplace();
    state.runningActionKey = null;
    state.engineImageModelRestore = null;
    setImageFxActive(false);
    updatePortraitIdle();
    setDirectorText(null, null);
    renderQuickActions();
  };

  flushDeferredEnginePtyExit = async () => {
    if (!state.pendingPtyExit || state.ptySpawning) return;
    await handleEnginePtyExit();
  };

  await listen("pty-exit", async () => {
    await handleEnginePtyExit();
  });

  // Consume PTY stdout as a fallback for vision describe completion/errors.
  // Desktop normally uses `events.jsonl`, but if event polling is disrupted, this
  // keeps the HUD "DESC" from getting stuck at ANALYZING.
  await listen("pty-data", (event) => {
    const chunk = event?.payload;
    if (typeof chunk !== "string" || !chunk) return;
    ptyLineBuffer += chunk;
    const lines = ptyLineBuffer.split("\n");
    ptyLineBuffer = lines.pop() || "";
    for (const line of lines) {
      _handlePtyLine(line);
    }
  });

  await listen("desktop-automation", (event) => {
    console.log("[desktop-automation] listener hit", event);
    void handleDesktopAutomation(event);
  });

  // Auto-create a run for speed; users can always "Open Run" later.
  await createRun();
  setTimeout(() => {
    maybeAutoOpenOpenRouterOnboarding();
  }, 140);
  await invoke("report_automation_frontend_ready", { ready: true }).catch((err) => {
    console.warn("desktop automation readiness handshake failed", err);
  });
  requestRender();
}

  boot().catch((err) => {
  console.error(err);
  setStatus(`Engine: boot failed (${err?.message || err})`, true);
});
